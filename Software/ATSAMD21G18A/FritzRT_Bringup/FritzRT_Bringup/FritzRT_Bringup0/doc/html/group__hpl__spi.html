<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: HPL SPI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__hpl__spi.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HPL SPI</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__msg.html">spi_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI message to let driver to process.  <a href="structspi__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__xfer.html">spi_xfer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer descriptor for SPI Transfer descriptor holds TX and RX buffers.  <a href="structspi__xfer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__dev.html">spi_dev</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__spi__async__dev__callbacks.html">_spi_async_dev_callbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callbacks offered by SPI driver.  <a href="struct__spi__async__dev__callbacks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__spi__async__dev.html">_spi_async_dev</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI async driver.  <a href="struct__spi__async__dev.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__spi__sync__dev.html">_spi_sync_dev</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga108944a74063db008de048761538192b"><td class="memItemLeft" align="right" valign="top"><a id="ga108944a74063db008de048761538192b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga108944a74063db008de048761538192b">SPI_DUMMY_CHAR</a>&#160;&#160;&#160;0x1ff</td></tr>
<tr class="memdesc:ga108944a74063db008de048761538192b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI Dummy char is used when reading data from the SPI slave. <br /></td></tr>
<tr class="separator:ga108944a74063db008de048761538192b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab37ebaab3686617eb20d5d175e82e6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a>&#160;&#160;&#160;<a class="el" href="struct__spi__async__dev.html">_spi_async_dev</a></td></tr>
<tr class="separator:gaab37ebaab3686617eb20d5d175e82e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e8fd3c7617223ab478f0262dcbd13b"><td class="memItemLeft" align="right" valign="top"><a id="ga45e8fd3c7617223ab478f0262dcbd13b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_spi_m_async_dev_cb_type</b>&#160;&#160;&#160;<a class="el" href="group__hpl__spi.html#ga0f0c72bc59abef8035904e8e267dfde9">_spi_async_dev_cb_type</a></td></tr>
<tr class="separator:ga45e8fd3c7617223ab478f0262dcbd13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7b65368c281e539d81064e45accc8a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gae7b65368c281e539d81064e45accc8a9">_spi_m_async_dev_cb_complete_t</a>&#160;&#160;&#160;<a class="el" href="group__hpl__spi.html#ga446094494e8aacbf4ad1a74c868d9809">_spi_async_dev_cb_complete_t</a></td></tr>
<tr class="separator:gae7b65368c281e539d81064e45accc8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91057ea550ac0806ee96b93ee180c7d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga91057ea550ac0806ee96b93ee180c7d6">_spi_m_async_dev_cb_xfer_t</a>&#160;&#160;&#160;<a class="el" href="group__hpl__spi.html#ga62275ef9b2c245ed2ed183f9d1c98a31">_spi_async_dev_cb_xfer_t</a></td></tr>
<tr class="separator:ga91057ea550ac0806ee96b93ee180c7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63a73aeb4b9cc78590635e10bb0b1e8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a>&#160;&#160;&#160;<a class="el" href="struct__spi__dma__dev.html">_spi_dma_dev</a></td></tr>
<tr class="separator:ga63a73aeb4b9cc78590635e10bb0b1e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga286f603c35e402cc2173463af5ca5185"><td class="memItemLeft" align="right" valign="top"><a id="ga286f603c35e402cc2173463af5ca5185"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_spi_m_dma_dev_cb_type</b>&#160;&#160;&#160;<a class="el" href="hpl__spi__dma_8h.html#a620c54d725b7b6e7f39ebf1c3e67d56f">_spi_dma_dev_cb_type</a></td></tr>
<tr class="separator:ga286f603c35e402cc2173463af5ca5185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7674622aeda62f2981f106e2d8221a5e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a>&#160;&#160;&#160;<a class="el" href="struct__spi__sync__dev.html">_spi_sync_dev</a></td></tr>
<tr class="separator:ga7674622aeda62f2981f106e2d8221a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ac9e8d408bc498841e8e461ad8656aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a>&#160;&#160;&#160;<a class="el" href="struct__spi__async__dev.html">_spi_async_dev</a></td></tr>
<tr class="separator:ga7ac9e8d408bc498841e8e461ad8656aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae620b9ec00192d2ac574fc6a9d963f00"><td class="memItemLeft" align="right" valign="top"><a id="gae620b9ec00192d2ac574fc6a9d963f00"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_spi_s_async_dev_cb_type</b>&#160;&#160;&#160;<a class="el" href="group__hpl__spi.html#ga0f0c72bc59abef8035904e8e267dfde9">_spi_async_dev_cb_type</a></td></tr>
<tr class="separator:gae620b9ec00192d2ac574fc6a9d963f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga756808e81e5dab8f583b37c4c7cfef8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga756808e81e5dab8f583b37c4c7cfef8f">_spi_s_async_dev_cb_complete_t</a>&#160;&#160;&#160;<a class="el" href="group__hpl__spi.html#ga446094494e8aacbf4ad1a74c868d9809">_spi_async_dev_cb_complete_t</a></td></tr>
<tr class="separator:ga756808e81e5dab8f583b37c4c7cfef8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga584d088d30604fde430c5f3f9af1e19a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga584d088d30604fde430c5f3f9af1e19a">_spi_s_async_dev_cb_xfer_t</a>&#160;&#160;&#160;<a class="el" href="group__hpl__spi.html#ga62275ef9b2c245ed2ed183f9d1c98a31">_spi_async_dev_cb_xfer_t</a></td></tr>
<tr class="separator:ga584d088d30604fde430c5f3f9af1e19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36cf082f9d7764b69f43a52f039e7165"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a>&#160;&#160;&#160;<a class="el" href="struct__spi__sync__dev.html">_spi_sync_dev</a></td></tr>
<tr class="separator:ga36cf082f9d7764b69f43a52f039e7165"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga446094494e8aacbf4ad1a74c868d9809"><td class="memItemLeft" align="right" valign="top"><a id="ga446094494e8aacbf4ad1a74c868d9809"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga446094494e8aacbf4ad1a74c868d9809">_spi_async_dev_cb_complete_t</a>) (struct <a class="el" href="struct__spi__async__dev.html">_spi_async_dev</a> *dev, int32_t status)</td></tr>
<tr class="memdesc:ga446094494e8aacbf4ad1a74c868d9809"><td class="mdescLeft">&#160;</td><td class="mdescRight">The prototype for callback on SPI transfer complete. If status code is zero, it indicates the normal completion, that is, SS deactivation. If status code belows zero, it indicates complete. <br /></td></tr>
<tr class="separator:ga446094494e8aacbf4ad1a74c868d9809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62275ef9b2c245ed2ed183f9d1c98a31"><td class="memItemLeft" align="right" valign="top"><a id="ga62275ef9b2c245ed2ed183f9d1c98a31"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga62275ef9b2c245ed2ed183f9d1c98a31">_spi_async_dev_cb_xfer_t</a>) (struct <a class="el" href="struct__spi__async__dev.html">_spi_async_dev</a> *dev)</td></tr>
<tr class="memdesc:ga62275ef9b2c245ed2ed183f9d1c98a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">The prototype for callback on SPI transmit/receive event For TX, the callback is invoked when transmit is done or ready to start transmit. For RX, the callback is invoked when receive is done or ready to read data, see _spi_async_dev_read_one_t on data reading. Without DMA enabled, the callback is invoked on each character event. With DMA enabled, the callback is invoked on DMA buffer done. <br /></td></tr>
<tr class="separator:ga62275ef9b2c245ed2ed183f9d1c98a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9c30fdfffba6be76b4044ccb17b218e5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a> { <a class="el" href="group__hpl__spi.html#gga9c30fdfffba6be76b4044ccb17b218e5a152359b11fb4b43ed0c5485eb0ab0673">SPI_MODE_0</a>, 
<a class="el" href="group__hpl__spi.html#gga9c30fdfffba6be76b4044ccb17b218e5a7c1990cc15e9d69621be8e0e757e634c">SPI_MODE_1</a>, 
<a class="el" href="group__hpl__spi.html#gga9c30fdfffba6be76b4044ccb17b218e5a4d350945d895a4acdc45ae96b0b82fc3">SPI_MODE_2</a>, 
<a class="el" href="group__hpl__spi.html#gga9c30fdfffba6be76b4044ccb17b218e5af06ec36087996d6f328df39866ff5de6">SPI_MODE_3</a>
 }<tr class="memdesc:ga9c30fdfffba6be76b4044ccb17b218e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI transfer modes SPI transfer mode controls clock polarity and clock phase. Mode 0: leading edge is rising edge, data sample on leading edge. Mode 1: leading edge is rising edge, data sample on trailing edge. Mode 2: leading edge is falling edge, data sample on leading edge. Mode 3: leading edge is falling edge, data sample on trailing edge.  <a href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga9c30fdfffba6be76b4044ccb17b218e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a3ef460c2cea333834811806f32d60a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a> { <br />
&#160;&#160;<a class="el" href="group__hpl__spi.html#gga4a3ef460c2cea333834811806f32d60aa545c4eeac3fb7aeaeeb2ad03846f2229">SPI_CHAR_SIZE_8</a> = 0, 
<a class="el" href="group__hpl__spi.html#gga4a3ef460c2cea333834811806f32d60aa811e552b89c9b9c3e6a8651132c51a0a">SPI_CHAR_SIZE_9</a> = 1, 
<a class="el" href="group__hpl__spi.html#gga4a3ef460c2cea333834811806f32d60aa9d1f60998e243ba7e89e000729f094c6">SPI_CHAR_SIZE_10</a> = 2, 
<a class="el" href="group__hpl__spi.html#gga4a3ef460c2cea333834811806f32d60aa44e024c8e69dde6a399893ab546f143f">SPI_CHAR_SIZE_11</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__hpl__spi.html#gga4a3ef460c2cea333834811806f32d60aa1173f1bd9d748952aee7a529f29db7ae">SPI_CHAR_SIZE_12</a> = 4, 
<a class="el" href="group__hpl__spi.html#gga4a3ef460c2cea333834811806f32d60aae4bfe6a81d35bb32649c29ef61ed0149">SPI_CHAR_SIZE_13</a> = 5, 
<a class="el" href="group__hpl__spi.html#gga4a3ef460c2cea333834811806f32d60aa362b90f6a542d1562e07f7083bf01356">SPI_CHAR_SIZE_14</a> = 6, 
<a class="el" href="group__hpl__spi.html#gga4a3ef460c2cea333834811806f32d60aa8e89f50814cf80957ef5a5849712384e">SPI_CHAR_SIZE_15</a> = 7, 
<br />
&#160;&#160;<a class="el" href="group__hpl__spi.html#gga4a3ef460c2cea333834811806f32d60aa86b0b19ae92d22dbfe40f979ce399140">SPI_CHAR_SIZE_16</a> = 8
<br />
 }<tr class="memdesc:ga4a3ef460c2cea333834811806f32d60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI character sizes The character size influence the way the data is sent/received. For char size &lt;= 8 data is stored byte by byte. For char size between 9 ~ 16 data is stored in 2-byte length. Note that the default and recommended char size is 8 bit since it's supported by all system.  <a href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga4a3ef460c2cea333834811806f32d60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa69dbc0601cb5b1e2681400598a4b2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gabaa69dbc0601cb5b1e2681400598a4b2">spi_data_order</a> { <a class="el" href="group__hpl__spi.html#ggabaa69dbc0601cb5b1e2681400598a4b2a7875038b58baad2610da7f3ef2cd0325">SPI_DATA_ORDER_MSB_1ST</a> = 0, 
<a class="el" href="group__hpl__spi.html#ggabaa69dbc0601cb5b1e2681400598a4b2ac8b791b014c96eee8c4880c0a743cd10">SPI_DATA_ORDER_LSB_1ST</a> = 1
 }<tr class="memdesc:gabaa69dbc0601cb5b1e2681400598a4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI data order.  <a href="group__hpl__spi.html#gabaa69dbc0601cb5b1e2681400598a4b2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gabaa69dbc0601cb5b1e2681400598a4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f0c72bc59abef8035904e8e267dfde9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga0f0c72bc59abef8035904e8e267dfde9">_spi_async_dev_cb_type</a> { <a class="el" href="group__hpl__spi.html#gga0f0c72bc59abef8035904e8e267dfde9a2737d518cdb51d60e7b2d7c3d793dc59">SPI_DEV_CB_TX</a>, 
<a class="el" href="group__hpl__spi.html#gga0f0c72bc59abef8035904e8e267dfde9a9bd42857f574c730b26d17c12946f337">SPI_DEV_CB_RX</a>, 
<a class="el" href="group__hpl__spi.html#gga0f0c72bc59abef8035904e8e267dfde9a37eb945faf2d105fc98a372ec31a57e1">SPI_DEV_CB_COMPLETE</a>, 
<a class="el" href="group__hpl__spi.html#gga0f0c72bc59abef8035904e8e267dfde9a2433e69f88c4631aebf9c7471420a747">SPI_DEV_CB_N</a>
 }<tr class="memdesc:ga0f0c72bc59abef8035904e8e267dfde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callbacks the SPI driver must offer in async mode.  <a href="group__hpl__spi.html#ga0f0c72bc59abef8035904e8e267dfde9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga0f0c72bc59abef8035904e8e267dfde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf83a57ec4a0328b8d58c9aa847867445"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gaf83a57ec4a0328b8d58c9aa847867445">_spi_calc_baud_val</a> (struct <a class="el" href="structspi__dev.html">spi_dev</a> *dev, const uint32_t clk, const uint32_t baud)</td></tr>
<tr class="memdesc:gaf83a57ec4a0328b8d58c9aa847867445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the baudrate value for hardware to use to set baudrate.  <a href="#gaf83a57ec4a0328b8d58c9aa847867445">More...</a><br /></td></tr>
<tr class="separator:gaf83a57ec4a0328b8d58c9aa847867445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab967bf854bc706f4bd6ba5a327dc32b1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gab967bf854bc706f4bd6ba5a327dc32b1">_spi_m_async_init</a> (struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *dev, void *const hw)</td></tr>
<tr class="memdesc:gab967bf854bc706f4bd6ba5a327dc32b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SPI for access with interrupts It will load default hardware configuration and software struct.  <a href="#gab967bf854bc706f4bd6ba5a327dc32b1">More...</a><br /></td></tr>
<tr class="separator:gab967bf854bc706f4bd6ba5a327dc32b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4360b2d04093ceebe9c544c1d38703c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gae4360b2d04093ceebe9c544c1d38703c">_spi_m_async_deinit</a> (struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *dev)</td></tr>
<tr class="memdesc:gae4360b2d04093ceebe9c544c1d38703c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SPI for access with interrupts Disable, reset the hardware and the software struct.  <a href="#gae4360b2d04093ceebe9c544c1d38703c">More...</a><br /></td></tr>
<tr class="separator:gae4360b2d04093ceebe9c544c1d38703c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadae03c08b6d35ed7ab360e5a3186819c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gadae03c08b6d35ed7ab360e5a3186819c">_spi_m_async_enable</a> (struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *dev)</td></tr>
<tr class="memdesc:gadae03c08b6d35ed7ab360e5a3186819c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SPI for access with interrupts Enable the SPI and enable callback generation of receive and error interrupts.  <a href="#gadae03c08b6d35ed7ab360e5a3186819c">More...</a><br /></td></tr>
<tr class="separator:gadae03c08b6d35ed7ab360e5a3186819c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeefe807432ef5d2416ba1659b9f807f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gaaeefe807432ef5d2416ba1659b9f807f">_spi_m_async_disable</a> (struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *dev)</td></tr>
<tr class="memdesc:gaaeefe807432ef5d2416ba1659b9f807f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable SPI for access without interrupts Disable SPI and interrupts. Deactivate all CS pins if works as master.  <a href="#gaaeefe807432ef5d2416ba1659b9f807f">More...</a><br /></td></tr>
<tr class="separator:gaaeefe807432ef5d2416ba1659b9f807f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2044d42ba5353a59324da48cebf69e25"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga2044d42ba5353a59324da48cebf69e25">_spi_m_async_set_mode</a> (struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *dev, const enum <a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a> mode)</td></tr>
<tr class="memdesc:ga2044d42ba5353a59324da48cebf69e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI transfer mode Set SPI transfer mode (<a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a>), which controls clock polarity and clock phase. Mode 0: leading edge is rising edge, data sample on leading edge. Mode 1: leading edge is rising edge, data sample on trailing edge. Mode 2: leading edge is falling edge, data sample on leading edge. Mode 3: leading edge is falling edge, data sample on trailing edge.  <a href="#ga2044d42ba5353a59324da48cebf69e25">More...</a><br /></td></tr>
<tr class="separator:ga2044d42ba5353a59324da48cebf69e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3b42aecc24e3edf0b9d608db13056d2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gac3b42aecc24e3edf0b9d608db13056d2">_spi_m_async_set_baudrate</a> (struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *dev, const uint32_t baud_val)</td></tr>
<tr class="memdesc:gac3b42aecc24e3edf0b9d608db13056d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI baudrate.  <a href="#gac3b42aecc24e3edf0b9d608db13056d2">More...</a><br /></td></tr>
<tr class="separator:gac3b42aecc24e3edf0b9d608db13056d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaed0c114955cb90a53932deadd347895"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gaaed0c114955cb90a53932deadd347895">_spi_m_async_set_char_size</a> (struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *dev, const enum <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a> char_size)</td></tr>
<tr class="memdesc:gaaed0c114955cb90a53932deadd347895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI baudrate.  <a href="#gaaed0c114955cb90a53932deadd347895">More...</a><br /></td></tr>
<tr class="separator:gaaed0c114955cb90a53932deadd347895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8228094fcecc7b1f75b2f3f6e1a63a0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gaa8228094fcecc7b1f75b2f3f6e1a63a0">_spi_m_async_set_data_order</a> (struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *dev, const enum <a class="el" href="group__hpl__spi.html#gabaa69dbc0601cb5b1e2681400598a4b2">spi_data_order</a> dord)</td></tr>
<tr class="memdesc:gaa8228094fcecc7b1f75b2f3f6e1a63a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI data order.  <a href="#gaa8228094fcecc7b1f75b2f3f6e1a63a0">More...</a><br /></td></tr>
<tr class="separator:gaa8228094fcecc7b1f75b2f3f6e1a63a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1be1b6a4ab1e574d1d5b7e678063a98b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga1be1b6a4ab1e574d1d5b7e678063a98b">_spi_m_async_enable_tx</a> (struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *dev, bool state)</td></tr>
<tr class="memdesc:ga1be1b6a4ab1e574d1d5b7e678063a98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupt on character output.  <a href="#ga1be1b6a4ab1e574d1d5b7e678063a98b">More...</a><br /></td></tr>
<tr class="separator:ga1be1b6a4ab1e574d1d5b7e678063a98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fc2dc760cf191c7979e2a568bfe33a4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga8fc2dc760cf191c7979e2a568bfe33a4">_spi_m_async_enable_rx</a> (struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *dev, bool state)</td></tr>
<tr class="memdesc:ga8fc2dc760cf191c7979e2a568bfe33a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupt on character input.  <a href="#ga8fc2dc760cf191c7979e2a568bfe33a4">More...</a><br /></td></tr>
<tr class="separator:ga8fc2dc760cf191c7979e2a568bfe33a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f88fe411dd9a3bda81b0c035eaf3e80"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga0f88fe411dd9a3bda81b0c035eaf3e80">_spi_m_async_enable_ss_detect</a> (struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *dev, bool state)</td></tr>
<tr class="memdesc:ga0f88fe411dd9a3bda81b0c035eaf3e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupt on Slave Select (SS) rising.  <a href="#ga0f88fe411dd9a3bda81b0c035eaf3e80">More...</a><br /></td></tr>
<tr class="separator:ga0f88fe411dd9a3bda81b0c035eaf3e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0210fb0efa281b97063ac82606c30cae"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga0210fb0efa281b97063ac82606c30cae">_spi_m_async_read_one</a> (struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *dev)</td></tr>
<tr class="memdesc:ga0210fb0efa281b97063ac82606c30cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one character to SPI device instance.  <a href="#ga0210fb0efa281b97063ac82606c30cae">More...</a><br /></td></tr>
<tr class="separator:ga0210fb0efa281b97063ac82606c30cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e4ef571a2b01b191ade58f21686f13c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga6e4ef571a2b01b191ade58f21686f13c">_spi_m_async_write_one</a> (struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *dev, uint16_t data)</td></tr>
<tr class="memdesc:ga6e4ef571a2b01b191ade58f21686f13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one character to assigned buffer.  <a href="#ga6e4ef571a2b01b191ade58f21686f13c">More...</a><br /></td></tr>
<tr class="separator:ga6e4ef571a2b01b191ade58f21686f13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ded12d6ee42cc5265a9d5c43e042315"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga8ded12d6ee42cc5265a9d5c43e042315">_spi_m_async_register_callback</a> (struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *dev, const enum _spi_m_async_dev_cb_type cb_type, const <a class="el" href="group__doc__driver__hal__utils__macro.html#gae40b38bc5f5a5bd452bdd59c67d9a9cf">FUNC_PTR</a> func)</td></tr>
<tr class="memdesc:ga8ded12d6ee42cc5265a9d5c43e042315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the SPI device callback.  <a href="#ga8ded12d6ee42cc5265a9d5c43e042315">More...</a><br /></td></tr>
<tr class="separator:ga8ded12d6ee42cc5265a9d5c43e042315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a45200688acd1d51a83fb1cbe013ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga78a45200688acd1d51a83fb1cbe013ec">_spi_m_async_set_irq_state</a> (struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *const device, const enum _spi_m_async_dev_cb_type type, const bool state)</td></tr>
<tr class="memdesc:ga78a45200688acd1d51a83fb1cbe013ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable SPI master interrupt.  <a href="#ga78a45200688acd1d51a83fb1cbe013ec">More...</a><br /></td></tr>
<tr class="separator:ga78a45200688acd1d51a83fb1cbe013ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6168cbfdef164f4980a99601f0ca4e6d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga6168cbfdef164f4980a99601f0ca4e6d">_spi_m_dma_init</a> (struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *dev, void *const hw)</td></tr>
<tr class="memdesc:ga6168cbfdef164f4980a99601f0ca4e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SPI for access with interrupts It will load default hardware configuration and software struct.  <a href="#ga6168cbfdef164f4980a99601f0ca4e6d">More...</a><br /></td></tr>
<tr class="separator:ga6168cbfdef164f4980a99601f0ca4e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcbacc2873e0fa5a00620ca13f376ddd"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gabcbacc2873e0fa5a00620ca13f376ddd">_spi_m_dma_deinit</a> (struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *dev)</td></tr>
<tr class="memdesc:gabcbacc2873e0fa5a00620ca13f376ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SPI for access with interrupts Disable, reset the hardware and the software struct.  <a href="#gabcbacc2873e0fa5a00620ca13f376ddd">More...</a><br /></td></tr>
<tr class="separator:gabcbacc2873e0fa5a00620ca13f376ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84487738869d6a3a349d71507e504946"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga84487738869d6a3a349d71507e504946">_spi_m_dma_enable</a> (struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *dev)</td></tr>
<tr class="memdesc:ga84487738869d6a3a349d71507e504946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SPI for access with interrupts Enable the SPI and enable callback generation of receive and error interrupts.  <a href="#ga84487738869d6a3a349d71507e504946">More...</a><br /></td></tr>
<tr class="separator:ga84487738869d6a3a349d71507e504946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4923cdd8808adfcff6286c3a22680773"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga4923cdd8808adfcff6286c3a22680773">_spi_m_dma_disable</a> (struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *dev)</td></tr>
<tr class="memdesc:ga4923cdd8808adfcff6286c3a22680773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable SPI for access without interrupts Disable SPI and interrupts. Deactivate all CS pins if works as master.  <a href="#ga4923cdd8808adfcff6286c3a22680773">More...</a><br /></td></tr>
<tr class="separator:ga4923cdd8808adfcff6286c3a22680773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447e3d2a41c2332c652b906f4ec77b03"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga447e3d2a41c2332c652b906f4ec77b03">_spi_m_dma_set_mode</a> (struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *dev, const enum <a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a> mode)</td></tr>
<tr class="memdesc:ga447e3d2a41c2332c652b906f4ec77b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI transfer mode Set SPI transfer mode (<a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a>), which controls clock polarity and clock phase. Mode 0: leading edge is rising edge, data sample on leading edge. Mode 1: leading edge is rising edge, data sample on trailing edge. Mode 2: leading edge is falling edge, data sample on leading edge. Mode 3: leading edge is falling edge, data sample on trailing edge.  <a href="#ga447e3d2a41c2332c652b906f4ec77b03">More...</a><br /></td></tr>
<tr class="separator:ga447e3d2a41c2332c652b906f4ec77b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99577599f4159b1e739a34f3b485fb45"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga99577599f4159b1e739a34f3b485fb45">_spi_m_dma_set_baudrate</a> (struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *dev, const uint32_t baud_val)</td></tr>
<tr class="memdesc:ga99577599f4159b1e739a34f3b485fb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI baudrate.  <a href="#ga99577599f4159b1e739a34f3b485fb45">More...</a><br /></td></tr>
<tr class="separator:ga99577599f4159b1e739a34f3b485fb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga566bf1203a9a6c7576cd75c413b771b0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga566bf1203a9a6c7576cd75c413b771b0">_spi_m_dma_set_char_size</a> (struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *dev, const enum <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a> char_size)</td></tr>
<tr class="memdesc:ga566bf1203a9a6c7576cd75c413b771b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI baudrate.  <a href="#ga566bf1203a9a6c7576cd75c413b771b0">More...</a><br /></td></tr>
<tr class="separator:ga566bf1203a9a6c7576cd75c413b771b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga854f4bbf489e7706a61da7234abccae9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga854f4bbf489e7706a61da7234abccae9">_spi_m_dma_set_data_order</a> (struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *dev, const enum <a class="el" href="group__hpl__spi.html#gabaa69dbc0601cb5b1e2681400598a4b2">spi_data_order</a> dord)</td></tr>
<tr class="memdesc:ga854f4bbf489e7706a61da7234abccae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI data order.  <a href="#ga854f4bbf489e7706a61da7234abccae9">More...</a><br /></td></tr>
<tr class="separator:ga854f4bbf489e7706a61da7234abccae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14c36b87921d43cd194fdd99220b4b8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga14c36b87921d43cd194fdd99220b4b8f">_spi_m_dma_register_callback</a> (struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *dev, enum <a class="el" href="hpl__spi__dma_8h.html#a620c54d725b7b6e7f39ebf1c3e67d56f">_spi_dma_dev_cb_type</a>, <a class="el" href="hpl__spi__dma_8h.html#ae7c46033731e549163962bd7c79cab78">_spi_dma_cb_t</a> func)</td></tr>
<tr class="memdesc:ga14c36b87921d43cd194fdd99220b4b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the SPI device callback.  <a href="#ga14c36b87921d43cd194fdd99220b4b8f">More...</a><br /></td></tr>
<tr class="separator:ga14c36b87921d43cd194fdd99220b4b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga554fa0d30abe52ef12ec3046d12bbec2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga554fa0d30abe52ef12ec3046d12bbec2">_spi_m_dma_transfer</a> (struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *dev, uint8_t const *txbuf, uint8_t *const rxbuf, const uint16_t length)</td></tr>
<tr class="memdesc:ga554fa0d30abe52ef12ec3046d12bbec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do SPI data transfer (TX &amp; RX) with DMA Log the TX &amp; RX buffers and transfer them in background. It never blocks.  <a href="#ga554fa0d30abe52ef12ec3046d12bbec2">More...</a><br /></td></tr>
<tr class="separator:ga554fa0d30abe52ef12ec3046d12bbec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba635e6ad210d1428315ddd399647e2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga1ba635e6ad210d1428315ddd399647e2">_spi_m_sync_init</a> (struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *dev, void *const hw)</td></tr>
<tr class="memdesc:ga1ba635e6ad210d1428315ddd399647e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SPI for access without interrupts It will load default hardware configuration and software struct.  <a href="#ga1ba635e6ad210d1428315ddd399647e2">More...</a><br /></td></tr>
<tr class="separator:ga1ba635e6ad210d1428315ddd399647e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e206004864513902ccd1c79a4d59d8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gaf4e206004864513902ccd1c79a4d59d8">_spi_m_sync_deinit</a> (struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *dev)</td></tr>
<tr class="memdesc:gaf4e206004864513902ccd1c79a4d59d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize SPI Disable, reset the hardware and the software struct.  <a href="#gaf4e206004864513902ccd1c79a4d59d8">More...</a><br /></td></tr>
<tr class="separator:gaf4e206004864513902ccd1c79a4d59d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c9ed3535e73ac73198d7a06829ce260"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga3c9ed3535e73ac73198d7a06829ce260">_spi_m_sync_enable</a> (struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *dev)</td></tr>
<tr class="memdesc:ga3c9ed3535e73ac73198d7a06829ce260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SPI for access without interrupts.  <a href="#ga3c9ed3535e73ac73198d7a06829ce260">More...</a><br /></td></tr>
<tr class="separator:ga3c9ed3535e73ac73198d7a06829ce260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f98d26555a08dae45c7d80da8a6b1e9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga1f98d26555a08dae45c7d80da8a6b1e9">_spi_m_sync_disable</a> (struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *dev)</td></tr>
<tr class="memdesc:ga1f98d26555a08dae45c7d80da8a6b1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable SPI for access without interrupts Disable SPI. Deactivate all CS pins if works as master.  <a href="#ga1f98d26555a08dae45c7d80da8a6b1e9">More...</a><br /></td></tr>
<tr class="separator:ga1f98d26555a08dae45c7d80da8a6b1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa658db2528d45e511ca80ade9feb2f8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gafa658db2528d45e511ca80ade9feb2f8">_spi_m_sync_set_mode</a> (struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *dev, const enum <a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a> mode)</td></tr>
<tr class="memdesc:gafa658db2528d45e511ca80ade9feb2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI transfer mode Set SPI transfer mode (<a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a>), which controls clock polarity and clock phase. Mode 0: leading edge is rising edge, data sample on leading edge. Mode 1: leading edge is rising edge, data sample on trailing edge. Mode 2: leading edge is falling edge, data sample on leading edge. Mode 3: leading edge is falling edge, data sample on trailing edge.  <a href="#gafa658db2528d45e511ca80ade9feb2f8">More...</a><br /></td></tr>
<tr class="separator:gafa658db2528d45e511ca80ade9feb2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9afbba219e80a3afa273c19c889dae3a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga9afbba219e80a3afa273c19c889dae3a">_spi_m_sync_set_baudrate</a> (struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *dev, const uint32_t baud_val)</td></tr>
<tr class="memdesc:ga9afbba219e80a3afa273c19c889dae3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI baudrate.  <a href="#ga9afbba219e80a3afa273c19c889dae3a">More...</a><br /></td></tr>
<tr class="separator:ga9afbba219e80a3afa273c19c889dae3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3dbaa2147cc8f859c11a6fd2bf04a13"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gab3dbaa2147cc8f859c11a6fd2bf04a13">_spi_m_sync_set_char_size</a> (struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *dev, const enum <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a> char_size)</td></tr>
<tr class="memdesc:gab3dbaa2147cc8f859c11a6fd2bf04a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI baudrate.  <a href="#gab3dbaa2147cc8f859c11a6fd2bf04a13">More...</a><br /></td></tr>
<tr class="separator:gab3dbaa2147cc8f859c11a6fd2bf04a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83403f5f3a201292ac93622f20278221"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga83403f5f3a201292ac93622f20278221">_spi_m_sync_set_data_order</a> (struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *dev, const enum <a class="el" href="group__hpl__spi.html#gabaa69dbc0601cb5b1e2681400598a4b2">spi_data_order</a> dord)</td></tr>
<tr class="memdesc:ga83403f5f3a201292ac93622f20278221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI data order.  <a href="#ga83403f5f3a201292ac93622f20278221">More...</a><br /></td></tr>
<tr class="separator:ga83403f5f3a201292ac93622f20278221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c3dd5d93fc342e6436bbce037b8b424"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga7c3dd5d93fc342e6436bbce037b8b424">_spi_m_sync_trans</a> (struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *dev, const struct <a class="el" href="structspi__msg.html">spi_msg</a> *msg)</td></tr>
<tr class="memdesc:ga7c3dd5d93fc342e6436bbce037b8b424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the whole message without interrupt Transfer the message, it will keep waiting until the message finish or error.  <a href="#ga7c3dd5d93fc342e6436bbce037b8b424">More...</a><br /></td></tr>
<tr class="separator:ga7c3dd5d93fc342e6436bbce037b8b424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7029f17c278df8b26d1b3dabc209a6c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gab7029f17c278df8b26d1b3dabc209a6c">_spi_s_async_init</a> (struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *dev, void *const hw)</td></tr>
<tr class="memdesc:gab7029f17c278df8b26d1b3dabc209a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SPI for access with interrupts It will load default hardware configuration and software struct.  <a href="#gab7029f17c278df8b26d1b3dabc209a6c">More...</a><br /></td></tr>
<tr class="separator:gab7029f17c278df8b26d1b3dabc209a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeb792ee0ed50ffd0dd57d94211cd9ed"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gaeeb792ee0ed50ffd0dd57d94211cd9ed">_spi_s_async_deinit</a> (struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *dev)</td></tr>
<tr class="memdesc:gaeeb792ee0ed50ffd0dd57d94211cd9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SPI for access with interrupts Disable, reset the hardware and the software struct.  <a href="#gaeeb792ee0ed50ffd0dd57d94211cd9ed">More...</a><br /></td></tr>
<tr class="separator:gaeeb792ee0ed50ffd0dd57d94211cd9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga506b300340ae2cd06b640f47e05f9fee"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga506b300340ae2cd06b640f47e05f9fee">_spi_s_async_enable</a> (struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *dev)</td></tr>
<tr class="memdesc:ga506b300340ae2cd06b640f47e05f9fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SPI for access with interrupts Enable the SPI and enable callback generation of receive and error interrupts.  <a href="#ga506b300340ae2cd06b640f47e05f9fee">More...</a><br /></td></tr>
<tr class="separator:ga506b300340ae2cd06b640f47e05f9fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb0c400081a9de6a4ff574be671d788c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gaeb0c400081a9de6a4ff574be671d788c">_spi_s_async_disable</a> (struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *dev)</td></tr>
<tr class="memdesc:gaeb0c400081a9de6a4ff574be671d788c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable SPI for access without interrupts Disable SPI and interrupts. Deactivate all CS pins if works as master.  <a href="#gaeb0c400081a9de6a4ff574be671d788c">More...</a><br /></td></tr>
<tr class="separator:gaeb0c400081a9de6a4ff574be671d788c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf01869e506fd07f13dcf6afbcf07d7e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gadf01869e506fd07f13dcf6afbcf07d7e">_spi_s_async_set_mode</a> (struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *dev, const enum <a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a> mode)</td></tr>
<tr class="memdesc:gadf01869e506fd07f13dcf6afbcf07d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI transfer mode Set SPI transfer mode (<a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a>), which controls clock polarity and clock phase. Mode 0: leading edge is rising edge, data sample on leading edge. Mode 1: leading edge is rising edge, data sample on trailing edge. Mode 2: leading edge is falling edge, data sample on leading edge. Mode 3: leading edge is falling edge, data sample on trailing edge.  <a href="#gadf01869e506fd07f13dcf6afbcf07d7e">More...</a><br /></td></tr>
<tr class="separator:gadf01869e506fd07f13dcf6afbcf07d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa004cfed65f6200145d623ade4c23bb7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gaa004cfed65f6200145d623ade4c23bb7">_spi_s_async_set_char_size</a> (struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *dev, const enum <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a> char_size)</td></tr>
<tr class="memdesc:gaa004cfed65f6200145d623ade4c23bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI baudrate.  <a href="#gaa004cfed65f6200145d623ade4c23bb7">More...</a><br /></td></tr>
<tr class="separator:gaa004cfed65f6200145d623ade4c23bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e8f1969cbefb53284f84f7dbcc71565"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga3e8f1969cbefb53284f84f7dbcc71565">_spi_s_async_set_data_order</a> (struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *dev, const enum <a class="el" href="group__hpl__spi.html#gabaa69dbc0601cb5b1e2681400598a4b2">spi_data_order</a> dord)</td></tr>
<tr class="memdesc:ga3e8f1969cbefb53284f84f7dbcc71565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI data order.  <a href="#ga3e8f1969cbefb53284f84f7dbcc71565">More...</a><br /></td></tr>
<tr class="separator:ga3e8f1969cbefb53284f84f7dbcc71565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95cc445c703d422f1043bdbae0ffd7b3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga95cc445c703d422f1043bdbae0ffd7b3">_spi_s_async_enable_tx</a> (struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *dev, bool state)</td></tr>
<tr class="memdesc:ga95cc445c703d422f1043bdbae0ffd7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupt on character output.  <a href="#ga95cc445c703d422f1043bdbae0ffd7b3">More...</a><br /></td></tr>
<tr class="separator:ga95cc445c703d422f1043bdbae0ffd7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6434080b193c1e9546e90db3d01dab81"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga6434080b193c1e9546e90db3d01dab81">_spi_s_async_enable_rx</a> (struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *dev, bool state)</td></tr>
<tr class="memdesc:ga6434080b193c1e9546e90db3d01dab81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupt on character input.  <a href="#ga6434080b193c1e9546e90db3d01dab81">More...</a><br /></td></tr>
<tr class="separator:ga6434080b193c1e9546e90db3d01dab81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga850ea6c15d3c93959f618b363f445182"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga850ea6c15d3c93959f618b363f445182">_spi_s_async_enable_ss_detect</a> (struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *dev, bool state)</td></tr>
<tr class="memdesc:ga850ea6c15d3c93959f618b363f445182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupt on Slave Select (SS) rising.  <a href="#ga850ea6c15d3c93959f618b363f445182">More...</a><br /></td></tr>
<tr class="separator:ga850ea6c15d3c93959f618b363f445182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbb3e58ab1b546b509917700cd3b8f5f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gacbb3e58ab1b546b509917700cd3b8f5f">_spi_s_async_read_one</a> (struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *dev)</td></tr>
<tr class="memdesc:gacbb3e58ab1b546b509917700cd3b8f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one character to SPI device instance.  <a href="#gacbb3e58ab1b546b509917700cd3b8f5f">More...</a><br /></td></tr>
<tr class="separator:gacbb3e58ab1b546b509917700cd3b8f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc1092adc8163cb6297ba493f1723b30"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gadc1092adc8163cb6297ba493f1723b30">_spi_s_async_write_one</a> (struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *dev, uint16_t data)</td></tr>
<tr class="memdesc:gadc1092adc8163cb6297ba493f1723b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one character to assigned buffer.  <a href="#gadc1092adc8163cb6297ba493f1723b30">More...</a><br /></td></tr>
<tr class="separator:gadc1092adc8163cb6297ba493f1723b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58235b4c4fdd06abd22569c9728c2c6f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga58235b4c4fdd06abd22569c9728c2c6f">_spi_s_async_register_callback</a> (struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *dev, const enum _spi_s_async_dev_cb_type cb_type, const <a class="el" href="group__doc__driver__hal__utils__macro.html#gae40b38bc5f5a5bd452bdd59c67d9a9cf">FUNC_PTR</a> func)</td></tr>
<tr class="memdesc:ga58235b4c4fdd06abd22569c9728c2c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the SPI device callback.  <a href="#ga58235b4c4fdd06abd22569c9728c2c6f">More...</a><br /></td></tr>
<tr class="separator:ga58235b4c4fdd06abd22569c9728c2c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bfff6aba1ac04a156b33b435497ed5a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga9bfff6aba1ac04a156b33b435497ed5a">_spi_s_sync_init</a> (struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *dev, void *const hw)</td></tr>
<tr class="memdesc:ga9bfff6aba1ac04a156b33b435497ed5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SPI for access without interrupts It will load default hardware configuration and software struct.  <a href="#ga9bfff6aba1ac04a156b33b435497ed5a">More...</a><br /></td></tr>
<tr class="separator:ga9bfff6aba1ac04a156b33b435497ed5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f2703d1bbc1ae9e5924119709f6fadf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga6f2703d1bbc1ae9e5924119709f6fadf">_spi_s_sync_deinit</a> (struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *dev)</td></tr>
<tr class="memdesc:ga6f2703d1bbc1ae9e5924119709f6fadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SPI for access with interrupts Disable, reset the hardware and the software struct.  <a href="#ga6f2703d1bbc1ae9e5924119709f6fadf">More...</a><br /></td></tr>
<tr class="separator:ga6f2703d1bbc1ae9e5924119709f6fadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92a6db85ee5f31aa57b1aa4e712f14e7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga92a6db85ee5f31aa57b1aa4e712f14e7">_spi_s_sync_enable</a> (struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *dev)</td></tr>
<tr class="memdesc:ga92a6db85ee5f31aa57b1aa4e712f14e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SPI for access without interrupts.  <a href="#ga92a6db85ee5f31aa57b1aa4e712f14e7">More...</a><br /></td></tr>
<tr class="separator:ga92a6db85ee5f31aa57b1aa4e712f14e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece136abe12e7e2945fcb7b28d1bb5e1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gaece136abe12e7e2945fcb7b28d1bb5e1">_spi_s_sync_disable</a> (struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *dev)</td></tr>
<tr class="memdesc:gaece136abe12e7e2945fcb7b28d1bb5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable SPI for access without interrupts Disable SPI. Deactivate all CS pins if works as master.  <a href="#gaece136abe12e7e2945fcb7b28d1bb5e1">More...</a><br /></td></tr>
<tr class="separator:gaece136abe12e7e2945fcb7b28d1bb5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc0439caabbb1ed80874e97c7ba67a7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga0dc0439caabbb1ed80874e97c7ba67a7">_spi_s_sync_set_mode</a> (struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *dev, const enum <a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a> mode)</td></tr>
<tr class="memdesc:ga0dc0439caabbb1ed80874e97c7ba67a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI transfer mode Set SPI transfer mode (<a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a>), which controls clock polarity and clock phase. Mode 0: leading edge is rising edge, data sample on leading edge. Mode 1: leading edge is rising edge, data sample on trailing edge. Mode 2: leading edge is falling edge, data sample on leading edge. Mode 3: leading edge is falling edge, data sample on trailing edge.  <a href="#ga0dc0439caabbb1ed80874e97c7ba67a7">More...</a><br /></td></tr>
<tr class="separator:ga0dc0439caabbb1ed80874e97c7ba67a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga986f5f676a69c705d5239fd53193864a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga986f5f676a69c705d5239fd53193864a">_spi_s_sync_set_char_size</a> (struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *dev, const enum <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a> char_size)</td></tr>
<tr class="memdesc:ga986f5f676a69c705d5239fd53193864a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI baudrate.  <a href="#ga986f5f676a69c705d5239fd53193864a">More...</a><br /></td></tr>
<tr class="separator:ga986f5f676a69c705d5239fd53193864a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cab059286805d618d2bc11da8e43d94"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga5cab059286805d618d2bc11da8e43d94">_spi_s_sync_set_data_order</a> (struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *dev, const enum <a class="el" href="group__hpl__spi.html#gabaa69dbc0601cb5b1e2681400598a4b2">spi_data_order</a> dord)</td></tr>
<tr class="memdesc:ga5cab059286805d618d2bc11da8e43d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI data order.  <a href="#ga5cab059286805d618d2bc11da8e43d94">More...</a><br /></td></tr>
<tr class="separator:ga5cab059286805d618d2bc11da8e43d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b51eaa184b1d70f894ad55e773df3b9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga9b51eaa184b1d70f894ad55e773df3b9">_spi_s_sync_enable_tx</a> (struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *dev, bool state)</td></tr>
<tr class="memdesc:ga9b51eaa184b1d70f894ad55e773df3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupt on character output.  <a href="#ga9b51eaa184b1d70f894ad55e773df3b9">More...</a><br /></td></tr>
<tr class="separator:ga9b51eaa184b1d70f894ad55e773df3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dd07ddcb66c0451c56c4fa2a6a12818"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga2dd07ddcb66c0451c56c4fa2a6a12818">_spi_s_sync_enable_rx</a> (struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *dev, bool state)</td></tr>
<tr class="memdesc:ga2dd07ddcb66c0451c56c4fa2a6a12818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupt on character input.  <a href="#ga2dd07ddcb66c0451c56c4fa2a6a12818">More...</a><br /></td></tr>
<tr class="separator:ga2dd07ddcb66c0451c56c4fa2a6a12818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bc398fcaa495592607952f4f0a2f55e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga3bc398fcaa495592607952f4f0a2f55e">_spi_s_sync_read_one</a> (struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *dev)</td></tr>
<tr class="memdesc:ga3bc398fcaa495592607952f4f0a2f55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one character to SPI device instance.  <a href="#ga3bc398fcaa495592607952f4f0a2f55e">More...</a><br /></td></tr>
<tr class="separator:ga3bc398fcaa495592607952f4f0a2f55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5c691af95be44b8f2139379df54ba80"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gaa5c691af95be44b8f2139379df54ba80">_spi_s_sync_write_one</a> (struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *dev, uint16_t data)</td></tr>
<tr class="memdesc:gaa5c691af95be44b8f2139379df54ba80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one character to assigned buffer.  <a href="#gaa5c691af95be44b8f2139379df54ba80">More...</a><br /></td></tr>
<tr class="separator:gaa5c691af95be44b8f2139379df54ba80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96d0ba31c615fdd4340205bc27106df8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga96d0ba31c615fdd4340205bc27106df8">_spi_s_sync_is_tx_ready</a> (struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *dev)</td></tr>
<tr class="memdesc:ga96d0ba31c615fdd4340205bc27106df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if TX ready.  <a href="#ga96d0ba31c615fdd4340205bc27106df8">More...</a><br /></td></tr>
<tr class="separator:ga96d0ba31c615fdd4340205bc27106df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga632f8c72ffd769bc392e730e0ad805d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga632f8c72ffd769bc392e730e0ad805d8">_spi_s_sync_is_rx_ready</a> (struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *dev)</td></tr>
<tr class="memdesc:ga632f8c72ffd769bc392e730e0ad805d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if RX character ready.  <a href="#ga632f8c72ffd769bc392e730e0ad805d8">More...</a><br /></td></tr>
<tr class="separator:ga632f8c72ffd769bc392e730e0ad805d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa51db7f4f9251689e45272535b1f2051"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#gaa51db7f4f9251689e45272535b1f2051">_spi_s_sync_is_ss_deactivated</a> (struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *dev)</td></tr>
<tr class="memdesc:gaa51db7f4f9251689e45272535b1f2051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if SS deactiviation detected.  <a href="#gaa51db7f4f9251689e45272535b1f2051">More...</a><br /></td></tr>
<tr class="separator:gaa51db7f4f9251689e45272535b1f2051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a55be7580939b887c193397e632d3f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hpl__spi.html#ga8a55be7580939b887c193397e632d3f2">_spi_s_sync_is_error</a> (struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *dev)</td></tr>
<tr class="memdesc:ga8a55be7580939b887c193397e632d3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if error is detected.  <a href="#ga8a55be7580939b887c193397e632d3f2">More...</a><br /></td></tr>
<tr class="separator:ga8a55be7580939b887c193397e632d3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="hpl_spi_rev"></a>
Revision History</h1>
<ul>
<li>v1.0.0 Initial Release </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaab37ebaab3686617eb20d5d175e82e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab37ebaab3686617eb20d5d175e82e6a">&#9670;&nbsp;</a></span>_spi_m_async_dev</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _spi_m_async_dev&#160;&#160;&#160;<a class="el" href="struct__spi__async__dev.html">_spi_async_dev</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses common SPI async device driver. </p>

</div>
</div>
<a id="gae7b65368c281e539d81064e45accc8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7b65368c281e539d81064e45accc8a9">&#9670;&nbsp;</a></span>_spi_m_async_dev_cb_complete_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _spi_m_async_dev_cb_complete_t&#160;&#160;&#160;<a class="el" href="group__hpl__spi.html#ga446094494e8aacbf4ad1a74c868d9809">_spi_async_dev_cb_complete_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses common SPI async device driver complete callback type. </p>

</div>
</div>
<a id="ga91057ea550ac0806ee96b93ee180c7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91057ea550ac0806ee96b93ee180c7d6">&#9670;&nbsp;</a></span>_spi_m_async_dev_cb_xfer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _spi_m_async_dev_cb_xfer_t&#160;&#160;&#160;<a class="el" href="group__hpl__spi.html#ga62275ef9b2c245ed2ed183f9d1c98a31">_spi_async_dev_cb_xfer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses common SPI async device driver transfer callback type. </p>

</div>
</div>
<a id="ga63a73aeb4b9cc78590635e10bb0b1e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63a73aeb4b9cc78590635e10bb0b1e8b">&#9670;&nbsp;</a></span>_spi_m_dma_dev</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _spi_m_dma_dev&#160;&#160;&#160;<a class="el" href="struct__spi__dma__dev.html">_spi_dma_dev</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses common SPI dma device driver. </p>

</div>
</div>
<a id="ga7674622aeda62f2981f106e2d8221a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7674622aeda62f2981f106e2d8221a5e">&#9670;&nbsp;</a></span>_spi_m_sync_dev</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _spi_m_sync_dev&#160;&#160;&#160;<a class="el" href="struct__spi__sync__dev.html">_spi_sync_dev</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses common SPI async device driver. </p>

</div>
</div>
<a id="ga7ac9e8d408bc498841e8e461ad8656aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ac9e8d408bc498841e8e461ad8656aa">&#9670;&nbsp;</a></span>_spi_s_async_dev</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _spi_s_async_dev&#160;&#160;&#160;<a class="el" href="struct__spi__async__dev.html">_spi_async_dev</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses common SPI async device driver. </p>

</div>
</div>
<a id="ga756808e81e5dab8f583b37c4c7cfef8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga756808e81e5dab8f583b37c4c7cfef8f">&#9670;&nbsp;</a></span>_spi_s_async_dev_cb_complete_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _spi_s_async_dev_cb_complete_t&#160;&#160;&#160;<a class="el" href="group__hpl__spi.html#ga446094494e8aacbf4ad1a74c868d9809">_spi_async_dev_cb_complete_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses common SPI async device driver complete callback type. </p>

</div>
</div>
<a id="ga584d088d30604fde430c5f3f9af1e19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga584d088d30604fde430c5f3f9af1e19a">&#9670;&nbsp;</a></span>_spi_s_async_dev_cb_xfer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _spi_s_async_dev_cb_xfer_t&#160;&#160;&#160;<a class="el" href="group__hpl__spi.html#ga62275ef9b2c245ed2ed183f9d1c98a31">_spi_async_dev_cb_xfer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses common SPI async device driver transfer callback type. </p>

</div>
</div>
<a id="ga36cf082f9d7764b69f43a52f039e7165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36cf082f9d7764b69f43a52f039e7165">&#9670;&nbsp;</a></span>_spi_s_sync_dev</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _spi_s_sync_dev&#160;&#160;&#160;<a class="el" href="struct__spi__sync__dev.html">_spi_sync_dev</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses common SPI async device driver. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga0f0c72bc59abef8035904e8e267dfde9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f0c72bc59abef8035904e8e267dfde9">&#9670;&nbsp;</a></span>_spi_async_dev_cb_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hpl__spi.html#ga0f0c72bc59abef8035904e8e267dfde9">_spi_async_dev_cb_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callbacks the SPI driver must offer in async mode. </p>
<p>The callback types </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0f0c72bc59abef8035904e8e267dfde9a2737d518cdb51d60e7b2d7c3d793dc59"></a>SPI_DEV_CB_TX&#160;</td><td class="fielddoc"><p>Callback type for transmit, see <a class="el" href="group__hpl__spi.html#ga62275ef9b2c245ed2ed183f9d1c98a31">_spi_async_dev_cb_xfer_t</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0f0c72bc59abef8035904e8e267dfde9a9bd42857f574c730b26d17c12946f337"></a>SPI_DEV_CB_RX&#160;</td><td class="fielddoc"><p>Callback type for receive, see <a class="el" href="group__hpl__spi.html#ga62275ef9b2c245ed2ed183f9d1c98a31">_spi_async_dev_cb_xfer_t</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0f0c72bc59abef8035904e8e267dfde9a37eb945faf2d105fc98a372ec31a57e1"></a>SPI_DEV_CB_COMPLETE&#160;</td><td class="fielddoc"><p>Callback type for <a class="el" href="group__hpl__spi.html#ga446094494e8aacbf4ad1a74c868d9809">_spi_async_dev_cb_complete_t</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0f0c72bc59abef8035904e8e267dfde9a2433e69f88c4631aebf9c7471420a747"></a>SPI_DEV_CB_N&#160;</td><td class="fielddoc"><p>Number of callbacks. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4a3ef460c2cea333834811806f32d60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a3ef460c2cea333834811806f32d60a">&#9670;&nbsp;</a></span>spi_char_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI character sizes The character size influence the way the data is sent/received. For char size &lt;= 8 data is stored byte by byte. For char size between 9 ~ 16 data is stored in 2-byte length. Note that the default and recommended char size is 8 bit since it's supported by all system. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4a3ef460c2cea333834811806f32d60aa545c4eeac3fb7aeaeeb2ad03846f2229"></a>SPI_CHAR_SIZE_8&#160;</td><td class="fielddoc"><p>Character size is 8 bit. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a3ef460c2cea333834811806f32d60aa811e552b89c9b9c3e6a8651132c51a0a"></a>SPI_CHAR_SIZE_9&#160;</td><td class="fielddoc"><p>Character size is 9 bit. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a3ef460c2cea333834811806f32d60aa9d1f60998e243ba7e89e000729f094c6"></a>SPI_CHAR_SIZE_10&#160;</td><td class="fielddoc"><p>Character size is 10 bit. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a3ef460c2cea333834811806f32d60aa44e024c8e69dde6a399893ab546f143f"></a>SPI_CHAR_SIZE_11&#160;</td><td class="fielddoc"><p>Character size is 11 bit. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a3ef460c2cea333834811806f32d60aa1173f1bd9d748952aee7a529f29db7ae"></a>SPI_CHAR_SIZE_12&#160;</td><td class="fielddoc"><p>Character size is 12 bit. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a3ef460c2cea333834811806f32d60aae4bfe6a81d35bb32649c29ef61ed0149"></a>SPI_CHAR_SIZE_13&#160;</td><td class="fielddoc"><p>Character size is 13 bit. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a3ef460c2cea333834811806f32d60aa362b90f6a542d1562e07f7083bf01356"></a>SPI_CHAR_SIZE_14&#160;</td><td class="fielddoc"><p>Character size is 14 bit. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a3ef460c2cea333834811806f32d60aa8e89f50814cf80957ef5a5849712384e"></a>SPI_CHAR_SIZE_15&#160;</td><td class="fielddoc"><p>Character size is 15 bit. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a3ef460c2cea333834811806f32d60aa86b0b19ae92d22dbfe40f979ce399140"></a>SPI_CHAR_SIZE_16&#160;</td><td class="fielddoc"><p>Character size is 16 bit. </p>
</td></tr>
</table>

</div>
</div>
<a id="gabaa69dbc0601cb5b1e2681400598a4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaa69dbc0601cb5b1e2681400598a4b2">&#9670;&nbsp;</a></span>spi_data_order</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hpl__spi.html#gabaa69dbc0601cb5b1e2681400598a4b2">spi_data_order</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI data order. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabaa69dbc0601cb5b1e2681400598a4b2a7875038b58baad2610da7f3ef2cd0325"></a>SPI_DATA_ORDER_MSB_1ST&#160;</td><td class="fielddoc"><p>MSB goes first. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabaa69dbc0601cb5b1e2681400598a4b2ac8b791b014c96eee8c4880c0a743cd10"></a>SPI_DATA_ORDER_LSB_1ST&#160;</td><td class="fielddoc"><p>LSB goes first. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9c30fdfffba6be76b4044ccb17b218e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c30fdfffba6be76b4044ccb17b218e5">&#9670;&nbsp;</a></span>spi_transfer_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI transfer modes SPI transfer mode controls clock polarity and clock phase. Mode 0: leading edge is rising edge, data sample on leading edge. Mode 1: leading edge is rising edge, data sample on trailing edge. Mode 2: leading edge is falling edge, data sample on leading edge. Mode 3: leading edge is falling edge, data sample on trailing edge. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9c30fdfffba6be76b4044ccb17b218e5a152359b11fb4b43ed0c5485eb0ab0673"></a>SPI_MODE_0&#160;</td><td class="fielddoc"><p>Leading edge is rising edge, data sample on leading edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9c30fdfffba6be76b4044ccb17b218e5a7c1990cc15e9d69621be8e0e757e634c"></a>SPI_MODE_1&#160;</td><td class="fielddoc"><p>Leading edge is rising edge, data sample on trailing edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9c30fdfffba6be76b4044ccb17b218e5a4d350945d895a4acdc45ae96b0b82fc3"></a>SPI_MODE_2&#160;</td><td class="fielddoc"><p>Leading edge is falling edge, data sample on leading edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9c30fdfffba6be76b4044ccb17b218e5af06ec36087996d6f328df39866ff5de6"></a>SPI_MODE_3&#160;</td><td class="fielddoc"><p>Leading edge is falling edge, data sample on trailing edge. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf83a57ec4a0328b8d58c9aa847867445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf83a57ec4a0328b8d58c9aa847867445">&#9670;&nbsp;</a></span>_spi_calc_baud_val()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_calc_baud_val </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspi__dev.html">spi_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>clk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the baudrate value for hardware to use to set baudrate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clk</td><td>Clock frequency (Hz) for baudrate generation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baud</td><td>Target baudrate (bps). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error or baudrate value. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>Baudrate value. </td></tr>
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>Calculation fail. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae4360b2d04093ceebe9c544c1d38703c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4360b2d04093ceebe9c544c1d38703c">&#9670;&nbsp;</a></span>_spi_m_async_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_async_deinit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize SPI for access with interrupts Disable, reset the hardware and the software struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaeefe807432ef5d2416ba1659b9f807f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeefe807432ef5d2416ba1659b9f807f">&#9670;&nbsp;</a></span>_spi_m_async_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_async_disable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable SPI for access without interrupts Disable SPI and interrupts. Deactivate all CS pins if works as master. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadae03c08b6d35ed7ab360e5a3186819c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadae03c08b6d35ed7ab360e5a3186819c">&#9670;&nbsp;</a></span>_spi_m_async_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_async_enable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable SPI for access with interrupts Enable the SPI and enable callback generation of receive and error interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>Input parameter problem. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI hardware not ready (resetting). </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8fc2dc760cf191c7979e2a568bfe33a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fc2dc760cf191c7979e2a568bfe33a4">&#9670;&nbsp;</a></span>_spi_m_async_enable_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_async_enable_rx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable interrupt on character input. </p>
<p>Enable interrupt when a new character is ready to be read from the SPI device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>true = enable input interrupts false = disable input interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code  0 OK Status </dd></dl>

</div>
</div>
<a id="ga0f88fe411dd9a3bda81b0c035eaf3e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f88fe411dd9a3bda81b0c035eaf3e80">&#9670;&nbsp;</a></span>_spi_m_async_enable_ss_detect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_async_enable_ss_detect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable interrupt on Slave Select (SS) rising. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>true = enable input interrupts false = disable input interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code  0 OK Status </dd></dl>

</div>
</div>
<a id="ga1be1b6a4ab1e574d1d5b7e678063a98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1be1b6a4ab1e574d1d5b7e678063a98b">&#9670;&nbsp;</a></span>_spi_m_async_enable_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_async_enable_tx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable interrupt on character output. </p>
<p>Enable interrupt when a new character can be written to the SPI device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>true = enable output interrupt false = disable output interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Ok status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab967bf854bc706f4bd6ba5a327dc32b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab967bf854bc706f4bd6ba5a327dc32b1">&#9670;&nbsp;</a></span>_spi_m_async_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_async_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>hw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize SPI for access with interrupts It will load default hardware configuration and software struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hw</td><td>Pointer to the hardware base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>Input parameter problem. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI hardware not ready (resetting). </td></tr>
    <tr><td class="paramname">ERR_DENIED</td><td>SPI has been enabled. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0210fb0efa281b97063ac82606c30cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0210fb0efa281b97063ac82606c30cae">&#9670;&nbsp;</a></span>_spi_m_async_read_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t _spi_m_async_read_one </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one character to SPI device instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Character read from SPI module </dd></dl>

</div>
</div>
<a id="ga8ded12d6ee42cc5265a9d5c43e042315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ded12d6ee42cc5265a9d5c43e042315">&#9670;&nbsp;</a></span>_spi_m_async_register_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_async_register_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum _spi_m_async_dev_cb_type&#160;</td>
          <td class="paramname"><em>cb_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__doc__driver__hal__utils__macro.html#gae40b38bc5f5a5bd452bdd59c67d9a9cf">FUNC_PTR</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the SPI device callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_type</td><td>The callback type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The callback function to register. NULL to disable callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always 0. </dd></dl>

</div>
</div>
<a id="gac3b42aecc24e3edf0b9d608db13056d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3b42aecc24e3edf0b9d608db13056d2">&#9670;&nbsp;</a></span>_spi_m_async_set_baudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_async_set_baudrate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baud_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI baudrate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baud_val</td><td>The SPI baudrate value, see <a class="el" href="group__hpl__spi.html#gaf83a57ec4a0328b8d58c9aa847867445">_spi_calc_baud_val()</a> on how it's generated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaed0c114955cb90a53932deadd347895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaed0c114955cb90a53932deadd347895">&#9670;&nbsp;</a></span>_spi_m_async_set_char_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_async_set_char_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a>&#160;</td>
          <td class="paramname"><em>char_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI baudrate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">char_size</td><td>The character size, see <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>The character size is not supported. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8228094fcecc7b1f75b2f3f6e1a63a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8228094fcecc7b1f75b2f3f6e1a63a0">&#9670;&nbsp;</a></span>_spi_m_async_set_data_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_async_set_data_order </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__hpl__spi.html#gabaa69dbc0601cb5b1e2681400598a4b2">spi_data_order</a>&#160;</td>
          <td class="paramname"><em>dord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI data order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dord</td><td>SPI data order (LSB/MSB first). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>The character size is not supported. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga78a45200688acd1d51a83fb1cbe013ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78a45200688acd1d51a83fb1cbe013ec">&#9670;&nbsp;</a></span>_spi_m_async_set_irq_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _spi_m_async_set_irq_state </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *const&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum _spi_m_async_dev_cb_type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable SPI master interrupt. </p>
<p>param[in] device The pointer to SPI master device instance param[in] type The type of interrupt to disable/enable if applicable param[in] state Enable or disable </p>

</div>
</div>
<a id="ga2044d42ba5353a59324da48cebf69e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2044d42ba5353a59324da48cebf69e25">&#9670;&nbsp;</a></span>_spi_m_async_set_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_async_set_mode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI transfer mode Set SPI transfer mode (<a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a>), which controls clock polarity and clock phase. Mode 0: leading edge is rising edge, data sample on leading edge. Mode 1: leading edge is rising edge, data sample on trailing edge. Mode 2: leading edge is falling edge, data sample on leading edge. Mode 3: leading edge is falling edge, data sample on trailing edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The SPI transfer mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e4ef571a2b01b191ade58f21686f13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e4ef571a2b01b191ade58f21686f13c">&#9670;&nbsp;</a></span>_spi_m_async_write_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_async_write_one </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#gaab37ebaab3686617eb20d5d175e82e6a">_spi_m_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write one character to assigned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code of write operation </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Write operation OK </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabcbacc2873e0fa5a00620ca13f376ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcbacc2873e0fa5a00620ca13f376ddd">&#9670;&nbsp;</a></span>_spi_m_dma_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_dma_deinit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize SPI for access with interrupts Disable, reset the hardware and the software struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ERR_NONE is operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4923cdd8808adfcff6286c3a22680773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4923cdd8808adfcff6286c3a22680773">&#9670;&nbsp;</a></span>_spi_m_dma_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_dma_disable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable SPI for access without interrupts Disable SPI and interrupts. Deactivate all CS pins if works as master. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ERR_NONE is operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga84487738869d6a3a349d71507e504946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84487738869d6a3a349d71507e504946">&#9670;&nbsp;</a></span>_spi_m_dma_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_dma_enable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable SPI for access with interrupts Enable the SPI and enable callback generation of receive and error interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>Input parameter problem. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI hardware not ready (resetting). </td></tr>
    <tr><td class="paramname">0</td><td>ERR_NONE is operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6168cbfdef164f4980a99601f0ca4e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6168cbfdef164f4980a99601f0ca4e6d">&#9670;&nbsp;</a></span>_spi_m_dma_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_dma_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>hw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize SPI for access with interrupts It will load default hardware configuration and software struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hw</td><td>Pointer to the hardware base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>Input parameter problem. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI hardware not ready (resetting). </td></tr>
    <tr><td class="paramname">ERR_DENIED</td><td>SPI has been enabled. </td></tr>
    <tr><td class="paramname">0</td><td>ERR_NONE is operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga14c36b87921d43cd194fdd99220b4b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14c36b87921d43cd194fdd99220b4b8f">&#9670;&nbsp;</a></span>_spi_m_dma_register_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _spi_m_dma_register_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum&#160;</td>
          <td class="paramname"><em>_spi_dma_dev_cb_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="hpl__spi__dma_8h.html#ae7c46033731e549163962bd7c79cab78">_spi_dma_cb_t</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the SPI device callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_type</td><td>The callback type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The callback function to register. NULL to disable callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always 0. </dd></dl>

</div>
</div>
<a id="ga99577599f4159b1e739a34f3b485fb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99577599f4159b1e739a34f3b485fb45">&#9670;&nbsp;</a></span>_spi_m_dma_set_baudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_dma_set_baudrate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baud_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI baudrate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baud_val</td><td>The SPI baudrate value, see <a class="el" href="group__hpl__spi.html#gaf83a57ec4a0328b8d58c9aa847867445">_spi_calc_baud_val()</a> on how it's generated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga566bf1203a9a6c7576cd75c413b771b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga566bf1203a9a6c7576cd75c413b771b0">&#9670;&nbsp;</a></span>_spi_m_dma_set_char_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_dma_set_char_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a>&#160;</td>
          <td class="paramname"><em>char_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI baudrate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">char_size</td><td>The character size, see <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>The character size is not supported. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga854f4bbf489e7706a61da7234abccae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga854f4bbf489e7706a61da7234abccae9">&#9670;&nbsp;</a></span>_spi_m_dma_set_data_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_dma_set_data_order </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__hpl__spi.html#gabaa69dbc0601cb5b1e2681400598a4b2">spi_data_order</a>&#160;</td>
          <td class="paramname"><em>dord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI data order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dord</td><td>SPI data order (LSB/MSB first). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>The character size is not supported. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga447e3d2a41c2332c652b906f4ec77b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga447e3d2a41c2332c652b906f4ec77b03">&#9670;&nbsp;</a></span>_spi_m_dma_set_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_dma_set_mode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI transfer mode Set SPI transfer mode (<a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a>), which controls clock polarity and clock phase. Mode 0: leading edge is rising edge, data sample on leading edge. Mode 1: leading edge is rising edge, data sample on trailing edge. Mode 2: leading edge is falling edge, data sample on leading edge. Mode 3: leading edge is falling edge, data sample on trailing edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The SPI transfer mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>ERR_NONE is operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga554fa0d30abe52ef12ec3046d12bbec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga554fa0d30abe52ef12ec3046d12bbec2">&#9670;&nbsp;</a></span>_spi_m_dma_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_dma_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga63a73aeb4b9cc78590635e10bb0b1e8b">_spi_m_dma_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>txbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>rxbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do SPI data transfer (TX &amp; RX) with DMA Log the TX &amp; RX buffers and transfer them in background. It never blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txbuf</td><td>Pointer to the transfer information (spi_transfer). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rxbuf</td><td>Pointer to the receiver information (spi_receive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>spi transfer data length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_NONE</td><td>Success. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>Busy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf4e206004864513902ccd1c79a4d59d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4e206004864513902ccd1c79a4d59d8">&#9670;&nbsp;</a></span>_spi_m_sync_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_sync_deinit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinitialize SPI Disable, reset the hardware and the software struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f98d26555a08dae45c7d80da8a6b1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f98d26555a08dae45c7d80da8a6b1e9">&#9670;&nbsp;</a></span>_spi_m_sync_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_sync_disable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable SPI for access without interrupts Disable SPI. Deactivate all CS pins if works as master. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c9ed3535e73ac73198d7a06829ce260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c9ed3535e73ac73198d7a06829ce260">&#9670;&nbsp;</a></span>_spi_m_sync_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_sync_enable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable SPI for access without interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_BUSY</td><td>SPI hardware not ready (resetting). </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ba635e6ad210d1428315ddd399647e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ba635e6ad210d1428315ddd399647e2">&#9670;&nbsp;</a></span>_spi_m_sync_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_sync_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>hw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize SPI for access without interrupts It will load default hardware configuration and software struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hw</td><td>Pointer to the hardware base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>Input parameter problem. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI hardware not ready (resetting). </td></tr>
    <tr><td class="paramname">ERR_DENIED</td><td>SPI has been enabled. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9afbba219e80a3afa273c19c889dae3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9afbba219e80a3afa273c19c889dae3a">&#9670;&nbsp;</a></span>_spi_m_sync_set_baudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_sync_set_baudrate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baud_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI baudrate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baud_val</td><td>The SPI baudrate value, see <a class="el" href="group__hpl__spi.html#gaf83a57ec4a0328b8d58c9aa847867445">_spi_calc_baud_val()</a> on how it's generated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab3dbaa2147cc8f859c11a6fd2bf04a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3dbaa2147cc8f859c11a6fd2bf04a13">&#9670;&nbsp;</a></span>_spi_m_sync_set_char_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_sync_set_char_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a>&#160;</td>
          <td class="paramname"><em>char_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI baudrate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">char_size</td><td>The character size, see <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>The character size is not supported. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga83403f5f3a201292ac93622f20278221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83403f5f3a201292ac93622f20278221">&#9670;&nbsp;</a></span>_spi_m_sync_set_data_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_sync_set_data_order </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__hpl__spi.html#gabaa69dbc0601cb5b1e2681400598a4b2">spi_data_order</a>&#160;</td>
          <td class="paramname"><em>dord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI data order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dord</td><td>SPI data order (LSB/MSB first). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>The character size is not supported. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafa658db2528d45e511ca80ade9feb2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa658db2528d45e511ca80ade9feb2f8">&#9670;&nbsp;</a></span>_spi_m_sync_set_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_sync_set_mode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI transfer mode Set SPI transfer mode (<a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a>), which controls clock polarity and clock phase. Mode 0: leading edge is rising edge, data sample on leading edge. Mode 1: leading edge is rising edge, data sample on trailing edge. Mode 2: leading edge is falling edge, data sample on leading edge. Mode 3: leading edge is falling edge, data sample on trailing edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The SPI transfer mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c3dd5d93fc342e6436bbce037b8b424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c3dd5d93fc342e6436bbce037b8b424">&#9670;&nbsp;</a></span>_spi_m_sync_trans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_m_sync_trans </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7674622aeda62f2981f106e2d8221a5e">_spi_m_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspi__msg.html">spi_msg</a> *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer the whole message without interrupt Transfer the message, it will keep waiting until the message finish or error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to the message instance to process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error or number of characters transferred. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_BUSY</td><td>SPI hardware is not ready to start transfer (not enabled, busy applying settings, ...). </td></tr>
    <tr><td class="paramname">SPI_ERR_OVERFLOW</td><td>Overflow error. </td></tr>
    <tr><td class="paramname">&gt;=0</td><td>Number of characters transferred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeeb792ee0ed50ffd0dd57d94211cd9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeb792ee0ed50ffd0dd57d94211cd9ed">&#9670;&nbsp;</a></span>_spi_s_async_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_async_deinit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize SPI for access with interrupts Disable, reset the hardware and the software struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb0c400081a9de6a4ff574be671d788c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb0c400081a9de6a4ff574be671d788c">&#9670;&nbsp;</a></span>_spi_s_async_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_async_disable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable SPI for access without interrupts Disable SPI and interrupts. Deactivate all CS pins if works as master. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga506b300340ae2cd06b640f47e05f9fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga506b300340ae2cd06b640f47e05f9fee">&#9670;&nbsp;</a></span>_spi_s_async_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_async_enable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable SPI for access with interrupts Enable the SPI and enable callback generation of receive and error interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>Input parameter problem. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI hardware not ready (resetting). </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6434080b193c1e9546e90db3d01dab81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6434080b193c1e9546e90db3d01dab81">&#9670;&nbsp;</a></span>_spi_s_async_enable_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_async_enable_rx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable interrupt on character input. </p>
<p>Enable interrupt when a new character is ready to be read from the SPI device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>true = enable input interrupts false = disable input interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code  0 OK Status </dd></dl>

</div>
</div>
<a id="ga850ea6c15d3c93959f618b363f445182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga850ea6c15d3c93959f618b363f445182">&#9670;&nbsp;</a></span>_spi_s_async_enable_ss_detect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_async_enable_ss_detect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable interrupt on Slave Select (SS) rising. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>true = enable input interrupts false = disable input interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code  0 OK Status </dd></dl>

</div>
</div>
<a id="ga95cc445c703d422f1043bdbae0ffd7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95cc445c703d422f1043bdbae0ffd7b3">&#9670;&nbsp;</a></span>_spi_s_async_enable_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_async_enable_tx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable interrupt on character output. </p>
<p>Enable interrupt when a new character can be written to the SPI device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>true = enable output interrupt false = disable output interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Ok status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7029f17c278df8b26d1b3dabc209a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7029f17c278df8b26d1b3dabc209a6c">&#9670;&nbsp;</a></span>_spi_s_async_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_async_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>hw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize SPI for access with interrupts It will load default hardware configuration and software struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hw</td><td>Pointer to the hardware base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>Input parameter problem. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI hardware not ready (resetting). </td></tr>
    <tr><td class="paramname">ERR_DENIED</td><td>SPI has been enabled. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacbb3e58ab1b546b509917700cd3b8f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbb3e58ab1b546b509917700cd3b8f5f">&#9670;&nbsp;</a></span>_spi_s_async_read_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t _spi_s_async_read_one </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one character to SPI device instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Character read from SPI module </dd></dl>

</div>
</div>
<a id="ga58235b4c4fdd06abd22569c9728c2c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58235b4c4fdd06abd22569c9728c2c6f">&#9670;&nbsp;</a></span>_spi_s_async_register_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_async_register_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum _spi_s_async_dev_cb_type&#160;</td>
          <td class="paramname"><em>cb_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__doc__driver__hal__utils__macro.html#gae40b38bc5f5a5bd452bdd59c67d9a9cf">FUNC_PTR</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the SPI device callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_type</td><td>The callback type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The callback function to register. NULL to disable callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always 0. </dd></dl>

</div>
</div>
<a id="gaa004cfed65f6200145d623ade4c23bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa004cfed65f6200145d623ade4c23bb7">&#9670;&nbsp;</a></span>_spi_s_async_set_char_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_async_set_char_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a>&#160;</td>
          <td class="paramname"><em>char_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI baudrate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">char_size</td><td>The character size, see <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>The character size is not supported. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3e8f1969cbefb53284f84f7dbcc71565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e8f1969cbefb53284f84f7dbcc71565">&#9670;&nbsp;</a></span>_spi_s_async_set_data_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_async_set_data_order </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__hpl__spi.html#gabaa69dbc0601cb5b1e2681400598a4b2">spi_data_order</a>&#160;</td>
          <td class="paramname"><em>dord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI data order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dord</td><td>SPI data order (LSB/MSB first). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>The character size is not supported. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf01869e506fd07f13dcf6afbcf07d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf01869e506fd07f13dcf6afbcf07d7e">&#9670;&nbsp;</a></span>_spi_s_async_set_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_async_set_mode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI transfer mode Set SPI transfer mode (<a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a>), which controls clock polarity and clock phase. Mode 0: leading edge is rising edge, data sample on leading edge. Mode 1: leading edge is rising edge, data sample on trailing edge. Mode 2: leading edge is falling edge, data sample on leading edge. Mode 3: leading edge is falling edge, data sample on trailing edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The SPI transfer mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadc1092adc8163cb6297ba493f1723b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc1092adc8163cb6297ba493f1723b30">&#9670;&nbsp;</a></span>_spi_s_async_write_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_async_write_one </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga7ac9e8d408bc498841e8e461ad8656aa">_spi_s_async_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write one character to assigned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code of write operation </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Write operation OK </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6f2703d1bbc1ae9e5924119709f6fadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f2703d1bbc1ae9e5924119709f6fadf">&#9670;&nbsp;</a></span>_spi_s_sync_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_sync_deinit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize SPI for access with interrupts Disable, reset the hardware and the software struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaece136abe12e7e2945fcb7b28d1bb5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaece136abe12e7e2945fcb7b28d1bb5e1">&#9670;&nbsp;</a></span>_spi_s_sync_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_sync_disable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable SPI for access without interrupts Disable SPI. Deactivate all CS pins if works as master. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92a6db85ee5f31aa57b1aa4e712f14e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92a6db85ee5f31aa57b1aa4e712f14e7">&#9670;&nbsp;</a></span>_spi_s_sync_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_sync_enable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable SPI for access without interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_BUSY</td><td>SPI hardware not ready (resetting). </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2dd07ddcb66c0451c56c4fa2a6a12818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dd07ddcb66c0451c56c4fa2a6a12818">&#9670;&nbsp;</a></span>_spi_s_sync_enable_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_sync_enable_rx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable interrupt on character input. </p>
<p>Enable interrupt when a new character is ready to be read from the SPI device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>true = enable input interrupts false = disable input interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK Status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9b51eaa184b1d70f894ad55e773df3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b51eaa184b1d70f894ad55e773df3b9">&#9670;&nbsp;</a></span>_spi_s_sync_enable_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_sync_enable_tx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable interrupt on character output. </p>
<p>Enable interrupt when a new character can be written to the SPI device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>true = enable output interrupt false = disable output interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Ok status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9bfff6aba1ac04a156b33b435497ed5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bfff6aba1ac04a156b33b435497ed5a">&#9670;&nbsp;</a></span>_spi_s_sync_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_sync_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>hw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize SPI for access without interrupts It will load default hardware configuration and software struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hw</td><td>Pointer to the hardware base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>Input parameter problem. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI hardware not ready (resetting). </td></tr>
    <tr><td class="paramname">ERR_DENIED</td><td>SPI has been enabled. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a55be7580939b887c193397e632d3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a55be7580939b887c193397e632d3f2">&#9670;&nbsp;</a></span>_spi_s_sync_is_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _spi_s_sync_is_error </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if error is detected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error detection state </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error detected </td></tr>
    <tr><td class="paramname">false</td><td>Error not detected </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga632f8c72ffd769bc392e730e0ad805d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga632f8c72ffd769bc392e730e0ad805d8">&#9670;&nbsp;</a></span>_spi_s_sync_is_rx_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _spi_s_sync_is_rx_ready </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if RX character ready. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RX character ready state </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>RX character ready </td></tr>
    <tr><td class="paramname">false</td><td>RX character not ready </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa51db7f4f9251689e45272535b1f2051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa51db7f4f9251689e45272535b1f2051">&#9670;&nbsp;</a></span>_spi_s_sync_is_ss_deactivated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _spi_s_sync_is_ss_deactivated </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if SS deactiviation detected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SS deactiviation state </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>SS deactiviation detected </td></tr>
    <tr><td class="paramname">false</td><td>SS deactiviation not detected </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga96d0ba31c615fdd4340205bc27106df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96d0ba31c615fdd4340205bc27106df8">&#9670;&nbsp;</a></span>_spi_s_sync_is_tx_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _spi_s_sync_is_tx_ready </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if TX ready. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TX ready state </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>TX ready </td></tr>
    <tr><td class="paramname">false</td><td>TX not ready </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3bc398fcaa495592607952f4f0a2f55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bc398fcaa495592607952f4f0a2f55e">&#9670;&nbsp;</a></span>_spi_s_sync_read_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t _spi_s_sync_read_one </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one character to SPI device instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Character read from SPI module </dd></dl>

</div>
</div>
<a id="ga986f5f676a69c705d5239fd53193864a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga986f5f676a69c705d5239fd53193864a">&#9670;&nbsp;</a></span>_spi_s_sync_set_char_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_sync_set_char_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a>&#160;</td>
          <td class="paramname"><em>char_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI baudrate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">char_size</td><td>The character size, see <a class="el" href="group__hpl__spi.html#ga4a3ef460c2cea333834811806f32d60a">spi_char_size</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>The character size is not supported. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5cab059286805d618d2bc11da8e43d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cab059286805d618d2bc11da8e43d94">&#9670;&nbsp;</a></span>_spi_s_sync_set_data_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_sync_set_data_order </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__hpl__spi.html#gabaa69dbc0601cb5b1e2681400598a4b2">spi_data_order</a>&#160;</td>
          <td class="paramname"><em>dord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI data order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dord</td><td>SPI data order (LSB/MSB first). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_INVALID_ARG</td><td>The character size is not supported. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0dc0439caabbb1ed80874e97c7ba67a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dc0439caabbb1ed80874e97c7ba67a7">&#9670;&nbsp;</a></span>_spi_s_sync_set_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_sync_set_mode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI transfer mode Set SPI transfer mode (<a class="el" href="group__hpl__spi.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a>), which controls clock polarity and clock phase. Mode 0: leading edge is rising edge, data sample on leading edge. Mode 1: leading edge is rising edge, data sample on trailing edge. Mode 2: leading edge is falling edge, data sample on leading edge. Mode 3: leading edge is falling edge, data sample on trailing edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The SPI transfer mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_BUSY</td><td>SPI is not ready to accept new setting. </td></tr>
    <tr><td class="paramname">0</td><td>Operation done successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa5c691af95be44b8f2139379df54ba80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5c691af95be44b8f2139379df54ba80">&#9670;&nbsp;</a></span>_spi_s_sync_write_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t _spi_s_sync_write_one </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__hpl__spi.html#ga36cf082f9d7764b69f43a52f039e7165">_spi_s_sync_dev</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write one character to assigned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dev</td><td>Pointer to the SPI device instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code of write operation </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Write operation OK </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
