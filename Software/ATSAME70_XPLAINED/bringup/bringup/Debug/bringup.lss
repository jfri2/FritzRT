
bringup.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004610  00400000  00400000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000006c  20400000  00404610  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000ca0  2040006c  0040467c  0002006c  2**2
                  ALLOC
  3 .heap         00000204  20400d0c  0040531c  0002006c  2**0
                  ALLOC
  4 .stack        00000400  20400f10  00405520  0002006c  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  0002006c  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  0002009a  2**0
                  CONTENTS, READONLY
  7 .debug_info   000208bd  00000000  00000000  000200f3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000043b6  00000000  00000000  000409b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000ce0  00000000  00000000  00044d66  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00001160  00000000  00000000  00045a46  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0003d136  00000000  00000000  00046ba6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00015ce9  00000000  00000000  00083cdc  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0012646b  00000000  00000000  000999c5  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  0000232c  00000000  00000000  001bfe30  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000ec29  00000000  00000000  001c215c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	10 13 40 20 c9 01 40 00 c5 01 40 00 c5 01 40 00     ..@ ..@...@...@.
  400010:	c5 01 40 00 c5 01 40 00 c5 01 40 00 00 00 00 00     ..@...@...@.....
	...
  40002c:	41 20 40 00 c5 01 40 00 00 00 00 00 e1 20 40 00     A @...@...... @.
  40003c:	45 21 40 00 c5 01 40 00 c5 01 40 00 c5 01 40 00     E!@...@...@...@.
  40004c:	c5 01 40 00 c5 01 40 00 c5 01 40 00 c5 01 40 00     ..@...@...@...@.
  40005c:	c5 01 40 00 c5 01 40 00 00 00 00 00 c5 01 40 00     ..@...@.......@.
  40006c:	c5 01 40 00 c5 01 40 00 c5 01 40 00 c5 01 40 00     ..@...@...@...@.
  40007c:	c5 01 40 00 c5 01 40 00 c5 01 40 00 c5 01 40 00     ..@...@...@...@.
  40008c:	c5 01 40 00 c5 01 40 00 6d 0d 40 00 c5 01 40 00     ..@...@.m.@...@.
  40009c:	c5 01 40 00 c5 01 40 00 c5 01 40 00 c5 01 40 00     ..@...@...@...@.
  4000ac:	c5 01 40 00 c5 01 40 00 c5 01 40 00 c5 01 40 00     ..@...@...@...@.
  4000bc:	c5 01 40 00 c5 01 40 00 c5 01 40 00 15 12 40 00     ..@...@...@...@.
  4000cc:	c5 01 40 00 00 00 00 00 c5 01 40 00 00 00 00 00     ..@.......@.....
  4000dc:	c5 01 40 00 c5 01 40 00 c5 01 40 00 c5 01 40 00     ..@...@...@...@.
  4000ec:	c5 01 40 00 c5 01 40 00 c5 01 40 00 c5 01 40 00     ..@...@...@...@.
  4000fc:	c5 01 40 00 c5 01 40 00 c5 01 40 00 c5 01 40 00     ..@...@...@...@.
  40010c:	c5 01 40 00 c5 01 40 00 00 00 00 00 00 00 00 00     ..@...@.........
  40011c:	00 00 00 00 c5 01 40 00 c5 01 40 00 c5 01 40 00     ......@...@...@.
  40012c:	c5 01 40 00 c5 01 40 00 00 00 00 00 c5 01 40 00     ..@...@.......@.
  40013c:	c5 01 40 00                                         ..@.

00400140 <__do_global_dtors_aux>:
  400140:	b510      	push	{r4, lr}
  400142:	4c05      	ldr	r4, [pc, #20]	; (400158 <__do_global_dtors_aux+0x18>)
  400144:	7823      	ldrb	r3, [r4, #0]
  400146:	b933      	cbnz	r3, 400156 <__do_global_dtors_aux+0x16>
  400148:	4b04      	ldr	r3, [pc, #16]	; (40015c <__do_global_dtors_aux+0x1c>)
  40014a:	b113      	cbz	r3, 400152 <__do_global_dtors_aux+0x12>
  40014c:	4804      	ldr	r0, [pc, #16]	; (400160 <__do_global_dtors_aux+0x20>)
  40014e:	f3af 8000 	nop.w
  400152:	2301      	movs	r3, #1
  400154:	7023      	strb	r3, [r4, #0]
  400156:	bd10      	pop	{r4, pc}
  400158:	2040006c 	.word	0x2040006c
  40015c:	00000000 	.word	0x00000000
  400160:	00404610 	.word	0x00404610

00400164 <frame_dummy>:
  400164:	4b0c      	ldr	r3, [pc, #48]	; (400198 <frame_dummy+0x34>)
  400166:	b143      	cbz	r3, 40017a <frame_dummy+0x16>
  400168:	480c      	ldr	r0, [pc, #48]	; (40019c <frame_dummy+0x38>)
  40016a:	490d      	ldr	r1, [pc, #52]	; (4001a0 <frame_dummy+0x3c>)
  40016c:	b510      	push	{r4, lr}
  40016e:	f3af 8000 	nop.w
  400172:	480c      	ldr	r0, [pc, #48]	; (4001a4 <frame_dummy+0x40>)
  400174:	6803      	ldr	r3, [r0, #0]
  400176:	b923      	cbnz	r3, 400182 <frame_dummy+0x1e>
  400178:	bd10      	pop	{r4, pc}
  40017a:	480a      	ldr	r0, [pc, #40]	; (4001a4 <frame_dummy+0x40>)
  40017c:	6803      	ldr	r3, [r0, #0]
  40017e:	b933      	cbnz	r3, 40018e <frame_dummy+0x2a>
  400180:	4770      	bx	lr
  400182:	4b09      	ldr	r3, [pc, #36]	; (4001a8 <frame_dummy+0x44>)
  400184:	2b00      	cmp	r3, #0
  400186:	d0f7      	beq.n	400178 <frame_dummy+0x14>
  400188:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  40018c:	4718      	bx	r3
  40018e:	4b06      	ldr	r3, [pc, #24]	; (4001a8 <frame_dummy+0x44>)
  400190:	2b00      	cmp	r3, #0
  400192:	d0f5      	beq.n	400180 <frame_dummy+0x1c>
  400194:	4718      	bx	r3
  400196:	bf00      	nop
  400198:	00000000 	.word	0x00000000
  40019c:	00404610 	.word	0x00404610
  4001a0:	20400070 	.word	0x20400070
  4001a4:	00404610 	.word	0x00404610
  4001a8:	00000000 	.word	0x00000000

004001ac <app_init>:
/*!
* @brief @todo
* @return void
*/
void app_init(void)
{
  4001ac:	4770      	bx	lr
	...

004001b0 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
**/
void atmel_start_init(void)
{
  4001b0:	b508      	push	{r3, lr}
	system_init();
  4001b2:	4b02      	ldr	r3, [pc, #8]	; (4001bc <atmel_start_init+0xc>)
  4001b4:	4798      	blx	r3
	usb_init();
  4001b6:	4b02      	ldr	r3, [pc, #8]	; (4001c0 <atmel_start_init+0x10>)
  4001b8:	4798      	blx	r3
  4001ba:	bd08      	pop	{r3, pc}
  4001bc:	00400329 	.word	0x00400329
  4001c0:	00404489 	.word	0x00404489

004001c4 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4001c4:	e7fe      	b.n	4001c4 <Dummy_Handler>
	...

004001c8 <Reset_Handler>:
{
  4001c8:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
  4001ca:	4b17      	ldr	r3, [pc, #92]	; (400228 <Reset_Handler+0x60>)
  4001cc:	4a17      	ldr	r2, [pc, #92]	; (40022c <Reset_Handler+0x64>)
  4001ce:	429a      	cmp	r2, r3
  4001d0:	d010      	beq.n	4001f4 <Reset_Handler+0x2c>
                for (; pDest < &_erelocate;) {
  4001d2:	4b17      	ldr	r3, [pc, #92]	; (400230 <Reset_Handler+0x68>)
  4001d4:	4a14      	ldr	r2, [pc, #80]	; (400228 <Reset_Handler+0x60>)
  4001d6:	429a      	cmp	r2, r3
  4001d8:	d20c      	bcs.n	4001f4 <Reset_Handler+0x2c>
  4001da:	3b01      	subs	r3, #1
  4001dc:	1a9b      	subs	r3, r3, r2
  4001de:	f023 0303 	bic.w	r3, r3, #3
  4001e2:	3304      	adds	r3, #4
  4001e4:	4413      	add	r3, r2
  4001e6:	4911      	ldr	r1, [pc, #68]	; (40022c <Reset_Handler+0x64>)
                        *pDest++ = *pSrc++;
  4001e8:	f851 0b04 	ldr.w	r0, [r1], #4
  4001ec:	f842 0b04 	str.w	r0, [r2], #4
                for (; pDest < &_erelocate;) {
  4001f0:	429a      	cmp	r2, r3
  4001f2:	d1f9      	bne.n	4001e8 <Reset_Handler+0x20>
        for (pDest = &_szero; pDest < &_ezero;) {
  4001f4:	4b0f      	ldr	r3, [pc, #60]	; (400234 <Reset_Handler+0x6c>)
  4001f6:	4a10      	ldr	r2, [pc, #64]	; (400238 <Reset_Handler+0x70>)
  4001f8:	429a      	cmp	r2, r3
  4001fa:	d20a      	bcs.n	400212 <Reset_Handler+0x4a>
  4001fc:	3b01      	subs	r3, #1
  4001fe:	1a9b      	subs	r3, r3, r2
  400200:	f023 0303 	bic.w	r3, r3, #3
  400204:	3304      	adds	r3, #4
  400206:	4413      	add	r3, r2
                *pDest++ = 0;
  400208:	2100      	movs	r1, #0
  40020a:	f842 1b04 	str.w	r1, [r2], #4
        for (pDest = &_szero; pDest < &_ezero;) {
  40020e:	4293      	cmp	r3, r2
  400210:	d1fb      	bne.n	40020a <Reset_Handler+0x42>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  400212:	4a0a      	ldr	r2, [pc, #40]	; (40023c <Reset_Handler+0x74>)
  400214:	4b0a      	ldr	r3, [pc, #40]	; (400240 <Reset_Handler+0x78>)
  400216:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  40021a:	6093      	str	r3, [r2, #8]
        __libc_init_array();
  40021c:	4b09      	ldr	r3, [pc, #36]	; (400244 <Reset_Handler+0x7c>)
  40021e:	4798      	blx	r3
        main();
  400220:	4b09      	ldr	r3, [pc, #36]	; (400248 <Reset_Handler+0x80>)
  400222:	4798      	blx	r3
  400224:	e7fe      	b.n	400224 <Reset_Handler+0x5c>
  400226:	bf00      	nop
  400228:	20400000 	.word	0x20400000
  40022c:	00404610 	.word	0x00404610
  400230:	2040006c 	.word	0x2040006c
  400234:	20400d0c 	.word	0x20400d0c
  400238:	2040006c 	.word	0x2040006c
  40023c:	e000ed00 	.word	0xe000ed00
  400240:	00400000 	.word	0x00400000
  400244:	00404495 	.word	0x00404495
  400248:	00401e45 	.word	0x00401e45

0040024c <CTRL_SPI_PORT_init>:
}

static inline void hri_pio_set_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  40024c:	4b11      	ldr	r3, [pc, #68]	; (400294 <CTRL_SPI_PORT_init+0x48>)
  40024e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400250:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
  400254:	671a      	str	r2, [r3, #112]	; 0x70
}

static inline void hri_pio_clear_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400256:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400258:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
  40025c:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  40025e:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
  400262:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  400264:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400266:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  40026a:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  40026c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40026e:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  400272:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400274:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  400278:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  40027a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  40027c:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
  400280:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400282:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400284:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
  400288:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  40028a:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  40028e:	605a      	str	r2, [r3, #4]
  400290:	4770      	bx	lr
  400292:	bf00      	nop
  400294:	400e1400 	.word	0x400e1400

00400298 <CTRL_SPI_CLOCK_init>:
}

static inline hri_pmc_pcsr0_reg_t hri_pmc_get_PCSR0_reg(const void *const hw, hri_pmc_pcsr0_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400298:	4b04      	ldr	r3, [pc, #16]	; (4002ac <CTRL_SPI_CLOCK_init+0x14>)
  40029a:	699b      	ldr	r3, [r3, #24]
 *
 */
static inline void _pmc_enable_periph_clock(uint32_t periph_id)
{
	if (periph_id < 32) {
		if (!hri_pmc_get_PCSR0_reg(PMC, (1 << periph_id))) {
  40029c:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
  4002a0:	d103      	bne.n	4002aa <CTRL_SPI_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4002a2:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  4002a6:	4b01      	ldr	r3, [pc, #4]	; (4002ac <CTRL_SPI_CLOCK_init+0x14>)
  4002a8:	611a      	str	r2, [r3, #16]
  4002aa:	4770      	bx	lr
  4002ac:	400e0600 	.word	0x400e0600

004002b0 <CTRL_SPI_init>:

	_pmc_enable_periph_clock(ID_SPI0);
}

void CTRL_SPI_init(void)
{
  4002b0:	b510      	push	{r4, lr}

	CTRL_SPI_CLOCK_init();
  4002b2:	4b06      	ldr	r3, [pc, #24]	; (4002cc <CTRL_SPI_init+0x1c>)
  4002b4:	4798      	blx	r3

	spi_m_os_init(&CTRL_SPI, SPI0);
  4002b6:	4c06      	ldr	r4, [pc, #24]	; (4002d0 <CTRL_SPI_init+0x20>)
  4002b8:	4906      	ldr	r1, [pc, #24]	; (4002d4 <CTRL_SPI_init+0x24>)
  4002ba:	4620      	mov	r0, r4
  4002bc:	4b06      	ldr	r3, [pc, #24]	; (4002d8 <CTRL_SPI_init+0x28>)
  4002be:	4798      	blx	r3
	spi_m_os_enable(&CTRL_SPI);
  4002c0:	4620      	mov	r0, r4
  4002c2:	4b06      	ldr	r3, [pc, #24]	; (4002dc <CTRL_SPI_init+0x2c>)
  4002c4:	4798      	blx	r3
	CTRL_SPI_PORT_init();
  4002c6:	4b06      	ldr	r3, [pc, #24]	; (4002e0 <CTRL_SPI_init+0x30>)
  4002c8:	4798      	blx	r3
  4002ca:	bd10      	pop	{r4, pc}
  4002cc:	00400299 	.word	0x00400299
  4002d0:	20400cd0 	.word	0x20400cd0
  4002d4:	40008000 	.word	0x40008000
  4002d8:	004005b1 	.word	0x004005b1
  4002dc:	00400635 	.word	0x00400635
  4002e0:	0040024d 	.word	0x0040024d

004002e4 <delay_driver_init>:
}

void delay_driver_init(void)
{
  4002e4:	b508      	push	{r3, lr}
	delay_init(SysTick);
  4002e6:	4802      	ldr	r0, [pc, #8]	; (4002f0 <delay_driver_init+0xc>)
  4002e8:	4b02      	ldr	r3, [pc, #8]	; (4002f4 <delay_driver_init+0x10>)
  4002ea:	4798      	blx	r3
  4002ec:	bd08      	pop	{r3, pc}
  4002ee:	bf00      	nop
  4002f0:	e000e010 	.word	0xe000e010
  4002f4:	004003c9 	.word	0x004003c9

004002f8 <USB_DEVICE_INSTANCE_CLOCK_init>:
}

static inline hri_pmc_pcsr1_reg_t hri_pmc_get_PCSR1_reg(const void *const hw, hri_pmc_pcsr1_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Pmc *)hw)->PMC_PCSR1;
  4002f8:	4b05      	ldr	r3, [pc, #20]	; (400310 <USB_DEVICE_INSTANCE_CLOCK_init+0x18>)
  4002fa:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
			hri_pmc_set_PCSR0_reg(PMC, (1 << periph_id));
		}
	} else {
		periph_id -= 32;
		if (!hri_pmc_get_PCSR1_reg(PMC, (1 << periph_id))) {
  4002fe:	f013 0f04 	tst.w	r3, #4
  400302:	d103      	bne.n	40030c <USB_DEVICE_INSTANCE_CLOCK_init+0x14>
	((Pmc *)hw)->PMC_PCER1 = mask;
  400304:	2204      	movs	r2, #4
  400306:	4b02      	ldr	r3, [pc, #8]	; (400310 <USB_DEVICE_INSTANCE_CLOCK_init+0x18>)
  400308:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  40030c:	4770      	bx	lr
  40030e:	bf00      	nop
  400310:	400e0600 	.word	0x400e0600

00400314 <USB_DEVICE_INSTANCE_init>:
{
	_pmc_enable_periph_clock(ID_USBHS);
}

void USB_DEVICE_INSTANCE_init(void)
{
  400314:	b508      	push	{r3, lr}
	USB_DEVICE_INSTANCE_CLOCK_init();
  400316:	4b02      	ldr	r3, [pc, #8]	; (400320 <USB_DEVICE_INSTANCE_init+0xc>)
  400318:	4798      	blx	r3
	usb_d_init();
  40031a:	4b02      	ldr	r3, [pc, #8]	; (400324 <USB_DEVICE_INSTANCE_init+0x10>)
  40031c:	4798      	blx	r3
  40031e:	bd08      	pop	{r3, pc}
  400320:	004002f9 	.word	0x004002f9
  400324:	004008b9 	.word	0x004008b9

00400328 <system_init>:
}

void system_init(void)
{
  400328:	b508      	push	{r3, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
  40032a:	4b19      	ldr	r3, [pc, #100]	; (400390 <system_init+0x68>)
  40032c:	4798      	blx	r3
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  40032e:	4b19      	ldr	r3, [pc, #100]	; (400394 <system_init+0x6c>)
  400330:	699b      	ldr	r3, [r3, #24]
		if (!hri_pmc_get_PCSR0_reg(PMC, (1 << periph_id))) {
  400332:	f413 5f80 	tst.w	r3, #4096	; 0x1000
  400336:	d103      	bne.n	400340 <system_init+0x18>
	((Pmc *)hw)->PMC_PCER0 = mask;
  400338:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  40033c:	4b15      	ldr	r3, [pc, #84]	; (400394 <system_init+0x6c>)
  40033e:	611a      	str	r2, [r3, #16]
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400340:	4b14      	ldr	r3, [pc, #80]	; (400394 <system_init+0x6c>)
  400342:	699b      	ldr	r3, [r3, #24]
  400344:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  400348:	d103      	bne.n	400352 <system_init+0x2a>
	((Pmc *)hw)->PMC_PCER0 = mask;
  40034a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  40034e:	4b11      	ldr	r3, [pc, #68]	; (400394 <system_init+0x6c>)
  400350:	611a      	str	r2, [r3, #16]
}

static inline void hri_wdt_set_MR_WDDIS_bit(const void *const hw)
{
	WDT_CRITICAL_SECTION_ENTER();
	((Wdt *)hw)->WDT_MR |= WDT_MR_WDDIS;
  400352:	4a11      	ldr	r2, [pc, #68]	; (400398 <system_init+0x70>)
  400354:	6853      	ldr	r3, [r2, #4]
  400356:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  40035a:	6053      	str	r3, [r2, #4]
	((Pio *)hw)->PIO_OER = mask;
  40035c:	4b0f      	ldr	r3, [pc, #60]	; (40039c <system_init+0x74>)
  40035e:	f44f 7280 	mov.w	r2, #256	; 0x100
  400362:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_SODR = mask;
  400364:	631a      	str	r2, [r3, #48]	; 0x30
	((Pio *)hw)->PIO_PER = mask;
  400366:	601a      	str	r2, [r3, #0]
	((Pio *)hw)->PIO_OER = mask;
  400368:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  40036c:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_SODR = mask;
  40036e:	631a      	str	r2, [r3, #48]	; 0x30
	((Pio *)hw)->PIO_PER = mask;
  400370:	601a      	str	r2, [r3, #0]
	((Pio *)hw)->PIO_OER = mask;
  400372:	f503 7300 	add.w	r3, r3, #512	; 0x200
  400376:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  40037a:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_SODR = mask;
  40037c:	631a      	str	r2, [r3, #48]	; 0x30
	((Pio *)hw)->PIO_PER = mask;
  40037e:	601a      	str	r2, [r3, #0]
	                   // <true"> High
	                   true);

	gpio_set_pin_function(PIN_SPI_CTRL_CS, GPIO_PIN_FUNCTION_OFF);

	CTRL_SPI_init();
  400380:	4b07      	ldr	r3, [pc, #28]	; (4003a0 <system_init+0x78>)
  400382:	4798      	blx	r3

	delay_driver_init();
  400384:	4b07      	ldr	r3, [pc, #28]	; (4003a4 <system_init+0x7c>)
  400386:	4798      	blx	r3

	USB_DEVICE_INSTANCE_init();
  400388:	4b07      	ldr	r3, [pc, #28]	; (4003a8 <system_init+0x80>)
  40038a:	4798      	blx	r3
  40038c:	bd08      	pop	{r3, pc}
  40038e:	bf00      	nop
  400390:	00400c69 	.word	0x00400c69
  400394:	400e0600 	.word	0x400e0600
  400398:	400e1850 	.word	0x400e1850
  40039c:	400e1200 	.word	0x400e1200
  4003a0:	004002b1 	.word	0x004002b1
  4003a4:	004002e5 	.word	0x004002e5
  4003a8:	00400315 	.word	0x00400315

004003ac <atomic_enter_critical>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  4003ac:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
  4003b0:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  4003b2:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  4003b4:	f3bf 8f5f 	dmb	sy
  4003b8:	4770      	bx	lr

004003ba <atomic_leave_critical>:
  4003ba:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
  4003be:	6803      	ldr	r3, [r0, #0]

    \param [in]    priMask  Priority Mask
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  4003c0:	f383 8810 	msr	PRIMASK, r3
  4003c4:	4770      	bx	lr
	...

004003c8 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
  4003c8:	b508      	push	{r3, lr}
	_delay_init(hardware = hw);
  4003ca:	4b02      	ldr	r3, [pc, #8]	; (4003d4 <delay_init+0xc>)
  4003cc:	6018      	str	r0, [r3, #0]
  4003ce:	4b02      	ldr	r3, [pc, #8]	; (4003d8 <delay_init+0x10>)
  4003d0:	4798      	blx	r3
  4003d2:	bd08      	pop	{r3, pc}
  4003d4:	20400088 	.word	0x20400088
  4003d8:	00400fe9 	.word	0x00400fe9

004003dc <spi_m_os_io_write>:
 *  \param[in] length size Size of the data in number of characters.
 *
 *  \return length on success, or an error code on failure.
 */
static int32_t spi_m_os_io_write(struct io_descriptor *io, const uint8_t *const buf, const uint16_t length)
{
  4003dc:	b570      	push	{r4, r5, r6, lr}
  4003de:	4615      	mov	r5, r2
	ASSERT(io && buf);
  4003e0:	4604      	mov	r4, r0
  4003e2:	460e      	mov	r6, r1
  4003e4:	2800      	cmp	r0, #0
  4003e6:	bf18      	it	ne
  4003e8:	2900      	cmpne	r1, #0
  4003ea:	bf14      	ite	ne
  4003ec:	2001      	movne	r0, #1
  4003ee:	2000      	moveq	r0, #0
  4003f0:	226e      	movs	r2, #110	; 0x6e
  4003f2:	4910      	ldr	r1, [pc, #64]	; (400434 <spi_m_os_io_write+0x58>)
  4003f4:	4b10      	ldr	r3, [pc, #64]	; (400438 <spi_m_os_io_write+0x5c>)
  4003f6:	4798      	blx	r3
	struct spi_m_os_descriptor *spi = CONTAINER_OF(io, struct spi_m_os_descriptor, io);

	spi->xfer.rxbuf = NULL;
  4003f8:	2300      	movs	r3, #0
  4003fa:	6123      	str	r3, [r4, #16]
	spi->xfer.txbuf = (uint8_t *)buf;
  4003fc:	60e6      	str	r6, [r4, #12]
	spi->xfer.size  = length;
  4003fe:	6165      	str	r5, [r4, #20]
	spi->xfercnt    = 0;
  400400:	61a3      	str	r3, [r4, #24]
	spi->error      = ERR_NONE;
  400402:	61e3      	str	r3, [r4, #28]

	_spi_m_async_enable_tx(&spi->dev, true);
  400404:	2101      	movs	r1, #1
  400406:	f1a4 001c 	sub.w	r0, r4, #28
  40040a:	4b0c      	ldr	r3, [pc, #48]	; (40043c <spi_m_os_io_write+0x60>)
  40040c:	4798      	blx	r3

	if (sem_down(&spi->xfer_sem, ~0) < 0) {
  40040e:	f04f 31ff 	mov.w	r1, #4294967295
  400412:	f104 0008 	add.w	r0, r4, #8
  400416:	4b0a      	ldr	r3, [pc, #40]	; (400440 <spi_m_os_io_write+0x64>)
  400418:	4798      	blx	r3
  40041a:	2800      	cmp	r0, #0
  40041c:	db06      	blt.n	40042c <spi_m_os_io_write+0x50>
		return ERR_TIMEOUT;
	}

	if (spi->error) {
  40041e:	69e3      	ldr	r3, [r4, #28]
		return ERR_IO;
	}

	return length;
  400420:	2b00      	cmp	r3, #0
  400422:	bf0c      	ite	eq
  400424:	4628      	moveq	r0, r5
  400426:	f06f 0005 	mvnne.w	r0, #5
  40042a:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_TIMEOUT;
  40042c:	f06f 0007 	mvn.w	r0, #7
}
  400430:	bd70      	pop	{r4, r5, r6, pc}
  400432:	bf00      	nop
  400434:	00404504 	.word	0x00404504
  400438:	00400c01 	.word	0x00400c01
  40043c:	00400ee9 	.word	0x00400ee9
  400440:	00401ef1 	.word	0x00401ef1

00400444 <spi_m_os_io_read>:
{
  400444:	b570      	push	{r4, r5, r6, lr}
  400446:	4615      	mov	r5, r2
	ASSERT(io && buf);
  400448:	4604      	mov	r4, r0
  40044a:	460e      	mov	r6, r1
  40044c:	2800      	cmp	r0, #0
  40044e:	bf18      	it	ne
  400450:	2900      	cmpne	r1, #0
  400452:	bf14      	ite	ne
  400454:	2001      	movne	r0, #1
  400456:	2000      	moveq	r0, #0
  400458:	2246      	movs	r2, #70	; 0x46
  40045a:	4913      	ldr	r1, [pc, #76]	; (4004a8 <spi_m_os_io_read+0x64>)
  40045c:	4b13      	ldr	r3, [pc, #76]	; (4004ac <spi_m_os_io_read+0x68>)
  40045e:	4798      	blx	r3
	spi->xfer.rxbuf = buf;
  400460:	6126      	str	r6, [r4, #16]
	spi->xfer.txbuf = NULL;
  400462:	2300      	movs	r3, #0
  400464:	60e3      	str	r3, [r4, #12]
	spi->xfer.size  = length;
  400466:	6165      	str	r5, [r4, #20]
	spi->xfercnt    = 0;
  400468:	61a3      	str	r3, [r4, #24]
	spi->error      = ERR_NONE;
  40046a:	61e3      	str	r3, [r4, #28]
	_spi_m_async_enable_rx(&spi->dev, true);
  40046c:	f1a4 061c 	sub.w	r6, r4, #28
  400470:	2101      	movs	r1, #1
  400472:	4630      	mov	r0, r6
  400474:	4b0e      	ldr	r3, [pc, #56]	; (4004b0 <spi_m_os_io_read+0x6c>)
  400476:	4798      	blx	r3
	_spi_m_async_write_one(&spi->dev, SPI_DUMMY_CHAR);
  400478:	f240 11ff 	movw	r1, #511	; 0x1ff
  40047c:	4630      	mov	r0, r6
  40047e:	4b0d      	ldr	r3, [pc, #52]	; (4004b4 <spi_m_os_io_read+0x70>)
  400480:	4798      	blx	r3
	if (sem_down(&spi->xfer_sem, ~0) < 0) {
  400482:	f04f 31ff 	mov.w	r1, #4294967295
  400486:	f104 0008 	add.w	r0, r4, #8
  40048a:	4b0b      	ldr	r3, [pc, #44]	; (4004b8 <spi_m_os_io_read+0x74>)
  40048c:	4798      	blx	r3
  40048e:	2800      	cmp	r0, #0
  400490:	db06      	blt.n	4004a0 <spi_m_os_io_read+0x5c>
	if (spi->error) {
  400492:	69e3      	ldr	r3, [r4, #28]
	return length;
  400494:	2b00      	cmp	r3, #0
  400496:	bf0c      	ite	eq
  400498:	4628      	moveq	r0, r5
  40049a:	f06f 0005 	mvnne.w	r0, #5
  40049e:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_TIMEOUT;
  4004a0:	f06f 0007 	mvn.w	r0, #7
}
  4004a4:	bd70      	pop	{r4, r5, r6, pc}
  4004a6:	bf00      	nop
  4004a8:	00404504 	.word	0x00404504
  4004ac:	00400c01 	.word	0x00400c01
  4004b0:	00400f1d 	.word	0x00400f1d
  4004b4:	00400f5d 	.word	0x00400f5d
  4004b8:	00401ef1 	.word	0x00401ef1

004004bc <spi_m_os_error>:
 */
static void spi_m_os_error(struct _spi_m_async_dev *dev, int32_t status)
{
	struct spi_m_os_descriptor *spi = CONTAINER_OF(dev, struct spi_m_os_descriptor, dev);

	if (status == 0) {
  4004bc:	b901      	cbnz	r1, 4004c0 <spi_m_os_error+0x4>
  4004be:	4770      	bx	lr
{
  4004c0:	b538      	push	{r3, r4, r5, lr}
  4004c2:	460d      	mov	r5, r1
  4004c4:	4604      	mov	r4, r0
		return;
	}

	_spi_m_async_enable_tx(dev, false);
  4004c6:	2100      	movs	r1, #0
  4004c8:	4b05      	ldr	r3, [pc, #20]	; (4004e0 <spi_m_os_error+0x24>)
  4004ca:	4798      	blx	r3
	_spi_m_async_enable_rx(dev, false);
  4004cc:	2100      	movs	r1, #0
  4004ce:	4620      	mov	r0, r4
  4004d0:	4b04      	ldr	r3, [pc, #16]	; (4004e4 <spi_m_os_error+0x28>)
  4004d2:	4798      	blx	r3

	spi->error = status;
  4004d4:	63a5      	str	r5, [r4, #56]	; 0x38
	sem_up(&spi->xfer_sem);
  4004d6:	f104 0024 	add.w	r0, r4, #36	; 0x24
  4004da:	4b03      	ldr	r3, [pc, #12]	; (4004e8 <spi_m_os_error+0x2c>)
  4004dc:	4798      	blx	r3
  4004de:	bd38      	pop	{r3, r4, r5, pc}
  4004e0:	00400ee9 	.word	0x00400ee9
  4004e4:	00400f1d 	.word	0x00400f1d
  4004e8:	00401ead 	.word	0x00401ead

004004ec <spi_m_os_tx>:
{
  4004ec:	b510      	push	{r4, lr}
  4004ee:	4604      	mov	r4, r0
	if (!(dev->char_size > 1)) {
  4004f0:	7903      	ldrb	r3, [r0, #4]
  4004f2:	2b01      	cmp	r3, #1
		_spi_m_async_write_one(dev, spi->xfer.txbuf[spi->xfercnt++]);
  4004f4:	6a82      	ldr	r2, [r0, #40]	; 0x28
  4004f6:	6b43      	ldr	r3, [r0, #52]	; 0x34
  4004f8:	f103 0101 	add.w	r1, r3, #1
  4004fc:	6341      	str	r1, [r0, #52]	; 0x34
  4004fe:	bf94      	ite	ls
  400500:	5cd1      	ldrbls	r1, [r2, r3]
		_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt++]);
  400502:	f832 1013 	ldrhhi.w	r1, [r2, r3, lsl #1]
  400506:	4b08      	ldr	r3, [pc, #32]	; (400528 <spi_m_os_tx+0x3c>)
  400508:	4798      	blx	r3
	if (spi->xfercnt >= spi->xfer.size) {
  40050a:	6b62      	ldr	r2, [r4, #52]	; 0x34
  40050c:	6b23      	ldr	r3, [r4, #48]	; 0x30
  40050e:	429a      	cmp	r2, r3
  400510:	d200      	bcs.n	400514 <spi_m_os_tx+0x28>
  400512:	bd10      	pop	{r4, pc}
		_spi_m_async_enable_tx(dev, false);
  400514:	2100      	movs	r1, #0
  400516:	4620      	mov	r0, r4
  400518:	4b04      	ldr	r3, [pc, #16]	; (40052c <spi_m_os_tx+0x40>)
  40051a:	4798      	blx	r3
		sem_up(&spi->xfer_sem);
  40051c:	f104 0024 	add.w	r0, r4, #36	; 0x24
  400520:	4b03      	ldr	r3, [pc, #12]	; (400530 <spi_m_os_tx+0x44>)
  400522:	4798      	blx	r3
}
  400524:	e7f5      	b.n	400512 <spi_m_os_tx+0x26>
  400526:	bf00      	nop
  400528:	00400f5d 	.word	0x00400f5d
  40052c:	00400ee9 	.word	0x00400ee9
  400530:	00401ead 	.word	0x00401ead

00400534 <spi_m_os_rx>:
{
  400534:	b570      	push	{r4, r5, r6, lr}
  400536:	4604      	mov	r4, r0
	if (!(dev->char_size > 1)) {
  400538:	7903      	ldrb	r3, [r0, #4]
  40053a:	2b01      	cmp	r3, #1
  40053c:	d914      	bls.n	400568 <spi_m_os_rx+0x34>
		((uint16_t *)spi->xfer.rxbuf)[spi->xfercnt++] = (uint16_t)_spi_m_async_read_one(dev);
  40053e:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
  400540:	6b45      	ldr	r5, [r0, #52]	; 0x34
  400542:	1c6b      	adds	r3, r5, #1
  400544:	6343      	str	r3, [r0, #52]	; 0x34
  400546:	4b16      	ldr	r3, [pc, #88]	; (4005a0 <spi_m_os_rx+0x6c>)
  400548:	4798      	blx	r3
  40054a:	f826 0015 	strh.w	r0, [r6, r5, lsl #1]
	if (spi->xfercnt < spi->xfer.size) {
  40054e:	6b63      	ldr	r3, [r4, #52]	; 0x34
  400550:	6b22      	ldr	r2, [r4, #48]	; 0x30
  400552:	4293      	cmp	r3, r2
  400554:	d21b      	bcs.n	40058e <spi_m_os_rx+0x5a>
		if (spi->xfer.txbuf) {
  400556:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  400558:	b1a2      	cbz	r2, 400584 <spi_m_os_rx+0x50>
			if (dev->char_size == SPI_CHAR_SIZE_8) {
  40055a:	7921      	ldrb	r1, [r4, #4]
  40055c:	b961      	cbnz	r1, 400578 <spi_m_os_rx+0x44>
				_spi_m_async_write_one(dev, spi->xfer.txbuf[spi->xfercnt]);
  40055e:	5cd1      	ldrb	r1, [r2, r3]
  400560:	4620      	mov	r0, r4
  400562:	4b10      	ldr	r3, [pc, #64]	; (4005a4 <spi_m_os_rx+0x70>)
  400564:	4798      	blx	r3
  400566:	bd70      	pop	{r4, r5, r6, pc}
		spi->xfer.rxbuf[spi->xfercnt++] = (uint8_t)_spi_m_async_read_one(dev);
  400568:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
  40056a:	6b45      	ldr	r5, [r0, #52]	; 0x34
  40056c:	1c6b      	adds	r3, r5, #1
  40056e:	6343      	str	r3, [r0, #52]	; 0x34
  400570:	4b0b      	ldr	r3, [pc, #44]	; (4005a0 <spi_m_os_rx+0x6c>)
  400572:	4798      	blx	r3
  400574:	5570      	strb	r0, [r6, r5]
  400576:	e7ea      	b.n	40054e <spi_m_os_rx+0x1a>
				_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt]);
  400578:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
  40057c:	4620      	mov	r0, r4
  40057e:	4b09      	ldr	r3, [pc, #36]	; (4005a4 <spi_m_os_rx+0x70>)
  400580:	4798      	blx	r3
  400582:	bd70      	pop	{r4, r5, r6, pc}
			_spi_m_async_write_one(dev, dev->dummy_byte);
  400584:	88e1      	ldrh	r1, [r4, #6]
  400586:	4620      	mov	r0, r4
  400588:	4b06      	ldr	r3, [pc, #24]	; (4005a4 <spi_m_os_rx+0x70>)
  40058a:	4798      	blx	r3
  40058c:	bd70      	pop	{r4, r5, r6, pc}
		_spi_m_async_enable_rx(dev, false);
  40058e:	2100      	movs	r1, #0
  400590:	4620      	mov	r0, r4
  400592:	4b05      	ldr	r3, [pc, #20]	; (4005a8 <spi_m_os_rx+0x74>)
  400594:	4798      	blx	r3
		sem_up(&spi->xfer_sem);
  400596:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40059a:	4b04      	ldr	r3, [pc, #16]	; (4005ac <spi_m_os_rx+0x78>)
  40059c:	4798      	blx	r3
  40059e:	bd70      	pop	{r4, r5, r6, pc}
  4005a0:	00400f8d 	.word	0x00400f8d
  4005a4:	00400f5d 	.word	0x00400f5d
  4005a8:	00400f1d 	.word	0x00400f1d
  4005ac:	00401ead 	.word	0x00401ead

004005b0 <spi_m_os_init>:

/**
 *  \brief Initialize the SPI HAL instance and hardware for rtos mode.
 */
int32_t spi_m_os_init(struct spi_m_os_descriptor *const spi, void *const hw)
{
  4005b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int32_t rc = 0;

	ASSERT(spi && hw);
  4005b2:	4604      	mov	r4, r0
  4005b4:	460d      	mov	r5, r1
  4005b6:	2800      	cmp	r0, #0
  4005b8:	bf18      	it	ne
  4005ba:	2900      	cmpne	r1, #0
  4005bc:	bf14      	ite	ne
  4005be:	2001      	movne	r0, #1
  4005c0:	2000      	moveq	r0, #0
  4005c2:	22d3      	movs	r2, #211	; 0xd3
  4005c4:	4911      	ldr	r1, [pc, #68]	; (40060c <spi_m_os_init+0x5c>)
  4005c6:	4b12      	ldr	r3, [pc, #72]	; (400610 <spi_m_os_init+0x60>)
  4005c8:	4798      	blx	r3

	rc = _spi_m_async_init(&spi->dev, hw);
  4005ca:	4629      	mov	r1, r5
  4005cc:	4620      	mov	r0, r4
  4005ce:	4b11      	ldr	r3, [pc, #68]	; (400614 <spi_m_os_init+0x64>)
  4005d0:	4798      	blx	r3
	if (rc == ERR_NONE) {
  4005d2:	4606      	mov	r6, r0
  4005d4:	b108      	cbz	r0, 4005da <spi_m_os_init+0x2a>
	spi->io.write = spi_m_os_io_write;

	sem_init(&spi->xfer_sem, 0);

	return ERR_NONE;
}
  4005d6:	4630      	mov	r0, r6
  4005d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_TX, (FUNC_PTR)spi_m_os_tx);
  4005da:	4a0f      	ldr	r2, [pc, #60]	; (400618 <spi_m_os_init+0x68>)
  4005dc:	2100      	movs	r1, #0
  4005de:	4620      	mov	r0, r4
  4005e0:	4f0e      	ldr	r7, [pc, #56]	; (40061c <spi_m_os_init+0x6c>)
  4005e2:	47b8      	blx	r7
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_RX, (FUNC_PTR)spi_m_os_rx);
  4005e4:	4a0e      	ldr	r2, [pc, #56]	; (400620 <spi_m_os_init+0x70>)
  4005e6:	2101      	movs	r1, #1
  4005e8:	4620      	mov	r0, r4
  4005ea:	47b8      	blx	r7
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_COMPLETE, (FUNC_PTR)spi_m_os_error);
  4005ec:	4a0d      	ldr	r2, [pc, #52]	; (400624 <spi_m_os_init+0x74>)
  4005ee:	2102      	movs	r1, #2
  4005f0:	4620      	mov	r0, r4
  4005f2:	47b8      	blx	r7
	spi->dev.prvt = (void *)hw;
  4005f4:	6025      	str	r5, [r4, #0]
	spi->io.read  = spi_m_os_io_read;
  4005f6:	4b0c      	ldr	r3, [pc, #48]	; (400628 <spi_m_os_init+0x78>)
  4005f8:	6223      	str	r3, [r4, #32]
	spi->io.write = spi_m_os_io_write;
  4005fa:	4b0c      	ldr	r3, [pc, #48]	; (40062c <spi_m_os_init+0x7c>)
  4005fc:	61e3      	str	r3, [r4, #28]
	sem_init(&spi->xfer_sem, 0);
  4005fe:	2100      	movs	r1, #0
  400600:	f104 0024 	add.w	r0, r4, #36	; 0x24
  400604:	4b0a      	ldr	r3, [pc, #40]	; (400630 <spi_m_os_init+0x80>)
  400606:	4798      	blx	r3
	return ERR_NONE;
  400608:	e7e5      	b.n	4005d6 <spi_m_os_init+0x26>
  40060a:	bf00      	nop
  40060c:	00404504 	.word	0x00404504
  400610:	00400c01 	.word	0x00400c01
  400614:	00400e41 	.word	0x00400e41
  400618:	004004ed 	.word	0x004004ed
  40061c:	00400fb9 	.word	0x00400fb9
  400620:	00400535 	.word	0x00400535
  400624:	004004bd 	.word	0x004004bd
  400628:	00400445 	.word	0x00400445
  40062c:	004003dd 	.word	0x004003dd
  400630:	00401e75 	.word	0x00401e75

00400634 <spi_m_os_enable>:

/**
 *  \brief Enable SPI.
 */
int32_t spi_m_os_enable(struct spi_m_os_descriptor *const spi)
{
  400634:	b510      	push	{r4, lr}
	ASSERT(spi);
  400636:	4604      	mov	r4, r0
  400638:	22ff      	movs	r2, #255	; 0xff
  40063a:	4907      	ldr	r1, [pc, #28]	; (400658 <spi_m_os_enable+0x24>)
  40063c:	3000      	adds	r0, #0
  40063e:	bf18      	it	ne
  400640:	2001      	movne	r0, #1
  400642:	4b06      	ldr	r3, [pc, #24]	; (40065c <spi_m_os_enable+0x28>)
  400644:	4798      	blx	r3

	if (_spi_m_async_enable(&spi->dev) < 0) {
  400646:	4620      	mov	r0, r4
  400648:	4b05      	ldr	r3, [pc, #20]	; (400660 <spi_m_os_enable+0x2c>)
  40064a:	4798      	blx	r3
  40064c:	2800      	cmp	r0, #0
		return ERR_DENIED;
	}

	return ERR_NONE;
}
  40064e:	bfb4      	ite	lt
  400650:	f06f 0010 	mvnlt.w	r0, #16
  400654:	2000      	movge	r0, #0
  400656:	bd10      	pop	{r4, pc}
  400658:	00404504 	.word	0x00404504
  40065c:	00400c01 	.word	0x00400c01
  400660:	00400e95 	.word	0x00400e95

00400664 <_usb_d_find_ep>:
 */
static int8_t _usb_d_find_ep(const uint8_t ep)
{
	int8_t i;
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
  400664:	4b0f      	ldr	r3, [pc, #60]	; (4006a4 <_usb_d_find_ep+0x40>)
  400666:	7859      	ldrb	r1, [r3, #1]
  400668:	4288      	cmp	r0, r1
  40066a:	d018      	beq.n	40069e <_usb_d_find_ep+0x3a>
{
  40066c:	b430      	push	{r4, r5}
  40066e:	461a      	mov	r2, r3
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
  400670:	2300      	movs	r3, #0
			return i;
		}
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
  400672:	f000 050f 	and.w	r5, r0, #15
  400676:	e007      	b.n	400688 <_usb_d_find_ep+0x24>
  400678:	3301      	adds	r3, #1
  40067a:	b25b      	sxtb	r3, r3
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
  40067c:	2b04      	cmp	r3, #4
  40067e:	d009      	beq.n	400694 <_usb_d_find_ep+0x30>
  400680:	3220      	adds	r2, #32
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
  400682:	7851      	ldrb	r1, [r2, #1]
  400684:	4281      	cmp	r1, r0
  400686:	d007      	beq.n	400698 <_usb_d_find_ep+0x34>
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
  400688:	7814      	ldrb	r4, [r2, #0]
  40068a:	2c00      	cmp	r4, #0
  40068c:	d1f4      	bne.n	400678 <_usb_d_find_ep+0x14>
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
  40068e:	428d      	cmp	r5, r1
  400690:	d1f2      	bne.n	400678 <_usb_d_find_ep+0x14>
  400692:	e001      	b.n	400698 <_usb_d_find_ep+0x34>
			return i;
		}
	}
	return -1;
  400694:	f04f 33ff 	mov.w	r3, #4294967295
}
  400698:	4618      	mov	r0, r3
  40069a:	bc30      	pop	{r4, r5}
  40069c:	4770      	bx	lr
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
  40069e:	2300      	movs	r3, #0
}
  4006a0:	4618      	mov	r0, r3
  4006a2:	4770      	bx	lr
  4006a4:	2040008c 	.word	0x2040008c

004006a8 <usb_d_dummy_cb_false>:
{
	(void)unused0;
	(void)unused1;
	(void)unused2;
	return false;
}
  4006a8:	2000      	movs	r0, #0
  4006aa:	4770      	bx	lr

004006ac <usb_d_cb_trans_more>:
 * \brief Callback invoked when request more data
 * \param[in] ep Endpoint number with transfer direction on bit 8.
 * \param[in] transfered Number of bytes transfered.
 */
static bool usb_d_cb_trans_more(const uint8_t ep, const uint32_t transfered)
{
  4006ac:	b538      	push	{r3, r4, r5, lr}
  4006ae:	4604      	mov	r4, r0
  4006b0:	460d      	mov	r5, r1
	int8_t           ep_index = _usb_d_find_ep(ep);
  4006b2:	4b09      	ldr	r3, [pc, #36]	; (4006d8 <usb_d_cb_trans_more+0x2c>)
  4006b4:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ept->xfer.hdr.state == USB_EP_S_X_DATA) {
  4006b6:	4b09      	ldr	r3, [pc, #36]	; (4006dc <usb_d_cb_trans_more+0x30>)
  4006b8:	eb03 1340 	add.w	r3, r3, r0, lsl #5
  4006bc:	789b      	ldrb	r3, [r3, #2]
  4006be:	2b03      	cmp	r3, #3
  4006c0:	d001      	beq.n	4006c6 <usb_d_cb_trans_more+0x1a>
		return ept->callbacks.more(ep, transfered);
	}
	return false;
  4006c2:	2000      	movs	r0, #0
}
  4006c4:	bd38      	pop	{r3, r4, r5, pc}
		return ept->callbacks.more(ep, transfered);
  4006c6:	4b05      	ldr	r3, [pc, #20]	; (4006dc <usb_d_cb_trans_more+0x30>)
  4006c8:	eb03 1040 	add.w	r0, r3, r0, lsl #5
  4006cc:	6983      	ldr	r3, [r0, #24]
  4006ce:	4629      	mov	r1, r5
  4006d0:	4620      	mov	r0, r4
  4006d2:	4798      	blx	r3
  4006d4:	bd38      	pop	{r3, r4, r5, pc}
  4006d6:	bf00      	nop
  4006d8:	00400665 	.word	0x00400665
  4006dc:	2040008c 	.word	0x2040008c

004006e0 <_usb_d_cb_trans_done>:

/**
 * Callback when USB transactions are finished.
 */
static void _usb_d_cb_trans_done(const uint8_t ep, const int32_t code, const uint32_t transferred)
{
  4006e0:	b5f0      	push	{r4, r5, r6, r7, lr}
  4006e2:	b085      	sub	sp, #20
  4006e4:	4606      	mov	r6, r0
  4006e6:	460d      	mov	r5, r1
  4006e8:	4617      	mov	r7, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
  4006ea:	4b4d      	ldr	r3, [pc, #308]	; (400820 <_usb_d_cb_trans_done+0x140>)
  4006ec:	4798      	blx	r3
  4006ee:	4604      	mov	r4, r0
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];

	if (code == USB_TRANS_DONE) {
  4006f0:	2d00      	cmp	r5, #0
  4006f2:	d15b      	bne.n	4007ac <_usb_d_cb_trans_done+0xcc>
		ept->xfer.hdr.status = USB_XFER_DONE;
  4006f4:	4a4b      	ldr	r2, [pc, #300]	; (400824 <_usb_d_cb_trans_done+0x144>)
  4006f6:	0143      	lsls	r3, r0, #5
  4006f8:	18d1      	adds	r1, r2, r3
  4006fa:	2000      	movs	r0, #0
  4006fc:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
  4006fe:	5cd3      	ldrb	r3, [r2, r3]
  400700:	b173      	cbz	r3, 400720 <_usb_d_cb_trans_done+0x40>
			usb_d_ctrl_trans_done(ept);
			return;
		}
		ept->xfer.hdr.state = USB_EP_S_IDLE;
  400702:	4b48      	ldr	r3, [pc, #288]	; (400824 <_usb_d_cb_trans_done+0x144>)
  400704:	eb03 1344 	add.w	r3, r3, r4, lsl #5
  400708:	2201      	movs	r2, #1
  40070a:	709a      	strb	r2, [r3, #2]
	} else {
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
		ept->xfer.hdr.status = USB_XFER_ERROR;
	}

	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
  40070c:	4845      	ldr	r0, [pc, #276]	; (400824 <_usb_d_cb_trans_done+0x144>)
  40070e:	eb00 1044 	add.w	r0, r0, r4, lsl #5
  400712:	69c3      	ldr	r3, [r0, #28]
  400714:	463a      	mov	r2, r7
  400716:	78c1      	ldrb	r1, [r0, #3]
  400718:	4630      	mov	r0, r6
  40071a:	4798      	blx	r3
}
  40071c:	b005      	add	sp, #20
  40071e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (state == USB_EP_S_X_DATA) {
  400720:	788b      	ldrb	r3, [r1, #2]
  400722:	2b03      	cmp	r3, #3
  400724:	d00b      	beq.n	40073e <_usb_d_cb_trans_done+0x5e>
		ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DONE, ept->xfer.req);
  400726:	483f      	ldr	r0, [pc, #252]	; (400824 <_usb_d_cb_trans_done+0x144>)
  400728:	eb00 1244 	add.w	r2, r0, r4, lsl #5
  40072c:	4614      	mov	r4, r2
  40072e:	69d3      	ldr	r3, [r2, #28]
  400730:	320c      	adds	r2, #12
  400732:	2100      	movs	r1, #0
  400734:	7860      	ldrb	r0, [r4, #1]
  400736:	4798      	blx	r3
		ept->xfer.hdr.state = USB_EP_S_X_SETUP;
  400738:	2302      	movs	r3, #2
  40073a:	70a3      	strb	r3, [r4, #2]
  40073c:	e7ee      	b.n	40071c <_usb_d_cb_trans_done+0x3c>
	bool    req_dir = USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN;
  40073e:	460b      	mov	r3, r1
  400740:	f991 500c 	ldrsb.w	r5, [r1, #12]
		bool err = ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DATA, ept->xfer.req);
  400744:	460a      	mov	r2, r1
  400746:	69ce      	ldr	r6, [r1, #28]
  400748:	320c      	adds	r2, #12
  40074a:	2101      	movs	r1, #1
  40074c:	7858      	ldrb	r0, [r3, #1]
  40074e:	47b0      	blx	r6
		if (err) {
  400750:	b1a0      	cbz	r0, 40077c <_usb_d_cb_trans_done+0x9c>
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
  400752:	4b34      	ldr	r3, [pc, #208]	; (400824 <_usb_d_cb_trans_done+0x144>)
  400754:	eb03 1344 	add.w	r3, r3, r4, lsl #5
  400758:	2205      	movs	r2, #5
  40075a:	709a      	strb	r2, [r3, #2]
			ept->xfer.hdr.status = USB_XFER_HALT;
  40075c:	2202      	movs	r2, #2
  40075e:	70da      	strb	r2, [r3, #3]
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
  400760:	2d00      	cmp	r5, #0
  400762:	db09      	blt.n	400778 <_usb_d_cb_trans_done+0x98>
  400764:	482f      	ldr	r0, [pc, #188]	; (400824 <_usb_d_cb_trans_done+0x144>)
  400766:	eb00 1044 	add.w	r0, r0, r4, lsl #5
  40076a:	7840      	ldrb	r0, [r0, #1]
  40076c:	f040 0080 	orr.w	r0, r0, #128	; 0x80
  400770:	2101      	movs	r1, #1
  400772:	4b2d      	ldr	r3, [pc, #180]	; (400828 <_usb_d_cb_trans_done+0x148>)
  400774:	4798      	blx	r3
  400776:	e7d1      	b.n	40071c <_usb_d_cb_trans_done+0x3c>
  400778:	7858      	ldrb	r0, [r3, #1]
  40077a:	e7f9      	b.n	400770 <_usb_d_cb_trans_done+0x90>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
  40077c:	4829      	ldr	r0, [pc, #164]	; (400824 <_usb_d_cb_trans_done+0x144>)
  40077e:	eb00 1044 	add.w	r0, r0, r4, lsl #5
  400782:	2304      	movs	r3, #4
  400784:	7083      	strb	r3, [r0, #2]
			_usb_d_trans(ept->xfer.hdr.ep, !req_dir, NULL, 0, 1);
  400786:	7843      	ldrb	r3, [r0, #1]
	struct usb_d_transfer trans
  400788:	2200      	movs	r2, #0
  40078a:	9201      	str	r2, [sp, #4]
  40078c:	9202      	str	r2, [sp, #8]
  40078e:	4295      	cmp	r5, r2
  400790:	bfac      	ite	ge
  400792:	f043 0380 	orrge.w	r3, r3, #128	; 0x80
  400796:	f003 030f 	andlt.w	r3, r3, #15
  40079a:	f88d 300c 	strb.w	r3, [sp, #12]
  40079e:	2301      	movs	r3, #1
  4007a0:	f88d 300d 	strb.w	r3, [sp, #13]
	return _usb_d_dev_ep_trans(&trans);
  4007a4:	a801      	add	r0, sp, #4
  4007a6:	4b21      	ldr	r3, [pc, #132]	; (40082c <_usb_d_cb_trans_done+0x14c>)
  4007a8:	4798      	blx	r3
  4007aa:	e7b7      	b.n	40071c <_usb_d_cb_trans_done+0x3c>
	} else if (code == USB_TRANS_STALL) {
  4007ac:	2d01      	cmp	r5, #1
  4007ae:	d00a      	beq.n	4007c6 <_usb_d_cb_trans_done+0xe6>
	} else if (code == USB_TRANS_ABORT) {
  4007b0:	2d02      	cmp	r5, #2
  4007b2:	d01c      	beq.n	4007ee <_usb_d_cb_trans_done+0x10e>
	} else if (code == USB_TRANS_RESET) {
  4007b4:	2d03      	cmp	r5, #3
  4007b6:	d02a      	beq.n	40080e <_usb_d_cb_trans_done+0x12e>
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
  4007b8:	4b1a      	ldr	r3, [pc, #104]	; (400824 <_usb_d_cb_trans_done+0x144>)
  4007ba:	eb03 1340 	add.w	r3, r3, r0, lsl #5
  4007be:	2206      	movs	r2, #6
  4007c0:	709a      	strb	r2, [r3, #2]
		ept->xfer.hdr.status = USB_XFER_ERROR;
  4007c2:	70da      	strb	r2, [r3, #3]
  4007c4:	e7a2      	b.n	40070c <_usb_d_cb_trans_done+0x2c>
		ept->xfer.hdr.status = USB_XFER_HALT;
  4007c6:	4a17      	ldr	r2, [pc, #92]	; (400824 <_usb_d_cb_trans_done+0x144>)
  4007c8:	0143      	lsls	r3, r0, #5
  4007ca:	18d1      	adds	r1, r2, r3
  4007cc:	2002      	movs	r0, #2
  4007ce:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
  4007d0:	5cd3      	ldrb	r3, [r2, r3]
  4007d2:	b12b      	cbz	r3, 4007e0 <_usb_d_cb_trans_done+0x100>
			ept->xfer.hdr.state = USB_EP_S_HALTED;
  4007d4:	4b13      	ldr	r3, [pc, #76]	; (400824 <_usb_d_cb_trans_done+0x144>)
  4007d6:	eb03 1344 	add.w	r3, r3, r4, lsl #5
  4007da:	2205      	movs	r2, #5
  4007dc:	709a      	strb	r2, [r3, #2]
  4007de:	e795      	b.n	40070c <_usb_d_cb_trans_done+0x2c>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
  4007e0:	460b      	mov	r3, r1
  4007e2:	7098      	strb	r0, [r3, #2]
			_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
  4007e4:	2100      	movs	r1, #0
  4007e6:	4630      	mov	r0, r6
  4007e8:	4b0f      	ldr	r3, [pc, #60]	; (400828 <_usb_d_cb_trans_done+0x148>)
  4007ea:	4798      	blx	r3
  4007ec:	e78e      	b.n	40070c <_usb_d_cb_trans_done+0x2c>
		ept->xfer.hdr.status = USB_XFER_ABORT;
  4007ee:	4a0d      	ldr	r2, [pc, #52]	; (400824 <_usb_d_cb_trans_done+0x144>)
  4007f0:	0143      	lsls	r3, r0, #5
  4007f2:	18d1      	adds	r1, r2, r3
  4007f4:	2004      	movs	r0, #4
  4007f6:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
  4007f8:	5cd3      	ldrb	r3, [r2, r3]
  4007fa:	b12b      	cbz	r3, 400808 <_usb_d_cb_trans_done+0x128>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
  4007fc:	4b09      	ldr	r3, [pc, #36]	; (400824 <_usb_d_cb_trans_done+0x144>)
  4007fe:	eb03 1344 	add.w	r3, r3, r4, lsl #5
  400802:	2201      	movs	r2, #1
  400804:	709a      	strb	r2, [r3, #2]
  400806:	e781      	b.n	40070c <_usb_d_cb_trans_done+0x2c>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
  400808:	2302      	movs	r3, #2
  40080a:	708b      	strb	r3, [r1, #2]
			return;
  40080c:	e786      	b.n	40071c <_usb_d_cb_trans_done+0x3c>
		ept->xfer.hdr.state  = USB_EP_S_DISABLED;
  40080e:	4b05      	ldr	r3, [pc, #20]	; (400824 <_usb_d_cb_trans_done+0x144>)
  400810:	eb03 1340 	add.w	r3, r3, r0, lsl #5
  400814:	2200      	movs	r2, #0
  400816:	709a      	strb	r2, [r3, #2]
		ept->xfer.hdr.status = USB_XFER_RESET;
  400818:	2205      	movs	r2, #5
  40081a:	70da      	strb	r2, [r3, #3]
  40081c:	e776      	b.n	40070c <_usb_d_cb_trans_done+0x2c>
  40081e:	bf00      	nop
  400820:	00400665 	.word	0x00400665
  400824:	2040008c 	.word	0x2040008c
  400828:	00401a65 	.word	0x00401a65
  40082c:	00401c21 	.word	0x00401c21

00400830 <usb_d_cb_trans_setup>:
{
  400830:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400834:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
  400836:	4b1c      	ldr	r3, [pc, #112]	; (4008a8 <usb_d_cb_trans_setup+0x78>)
  400838:	4798      	blx	r3
  40083a:	4606      	mov	r6, r0
	uint8_t *        req      = ept->xfer.req;
  40083c:	4c1b      	ldr	r4, [pc, #108]	; (4008ac <usb_d_cb_trans_setup+0x7c>)
  40083e:	eb04 1440 	add.w	r4, r4, r0, lsl #5
  400842:	340c      	adds	r4, #12
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
  400844:	4621      	mov	r1, r4
  400846:	4628      	mov	r0, r5
  400848:	4b19      	ldr	r3, [pc, #100]	; (4008b0 <usb_d_cb_trans_setup+0x80>)
  40084a:	4798      	blx	r3
	if (n != 8) {
  40084c:	b2c0      	uxtb	r0, r0
  40084e:	2808      	cmp	r0, #8
  400850:	d009      	beq.n	400866 <usb_d_cb_trans_setup+0x36>
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
  400852:	2101      	movs	r1, #1
  400854:	4628      	mov	r0, r5
  400856:	4c17      	ldr	r4, [pc, #92]	; (4008b4 <usb_d_cb_trans_setup+0x84>)
  400858:	47a0      	blx	r4
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
  40085a:	2101      	movs	r1, #1
  40085c:	f045 0080 	orr.w	r0, r5, #128	; 0x80
  400860:	47a0      	blx	r4
		return;
  400862:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
  400866:	2100      	movs	r1, #0
  400868:	4628      	mov	r0, r5
  40086a:	4f12      	ldr	r7, [pc, #72]	; (4008b4 <usb_d_cb_trans_setup+0x84>)
  40086c:	47b8      	blx	r7
	_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_CLR);
  40086e:	f045 0880 	orr.w	r8, r5, #128	; 0x80
  400872:	2100      	movs	r1, #0
  400874:	4640      	mov	r0, r8
  400876:	47b8      	blx	r7
	ept->xfer.hdr.state = USB_EP_S_IDLE;
  400878:	4b0c      	ldr	r3, [pc, #48]	; (4008ac <usb_d_cb_trans_setup+0x7c>)
  40087a:	eb03 1346 	add.w	r3, r3, r6, lsl #5
  40087e:	2201      	movs	r2, #1
  400880:	709a      	strb	r2, [r3, #2]
	if (!ept->callbacks.req(ep, req)) {
  400882:	695b      	ldr	r3, [r3, #20]
  400884:	4621      	mov	r1, r4
  400886:	4628      	mov	r0, r5
  400888:	4798      	blx	r3
  40088a:	b108      	cbz	r0, 400890 <usb_d_cb_trans_setup+0x60>
  40088c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ept->xfer.hdr.state = USB_EP_S_HALTED;
  400890:	4b06      	ldr	r3, [pc, #24]	; (4008ac <usb_d_cb_trans_setup+0x7c>)
  400892:	eb03 1646 	add.w	r6, r3, r6, lsl #5
  400896:	2305      	movs	r3, #5
  400898:	70b3      	strb	r3, [r6, #2]
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
  40089a:	2101      	movs	r1, #1
  40089c:	4628      	mov	r0, r5
  40089e:	47b8      	blx	r7
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
  4008a0:	2101      	movs	r1, #1
  4008a2:	4640      	mov	r0, r8
  4008a4:	47b8      	blx	r7
  4008a6:	e7f1      	b.n	40088c <usb_d_cb_trans_setup+0x5c>
  4008a8:	00400665 	.word	0x00400665
  4008ac:	2040008c 	.word	0x2040008c
  4008b0:	00401bbd 	.word	0x00401bbd
  4008b4:	00401a65 	.word	0x00401a65

004008b8 <usb_d_init>:

int32_t usb_d_init(void)
{
  4008b8:	b510      	push	{r4, lr}
	int32_t rc = _usb_d_dev_init();
  4008ba:	4b11      	ldr	r3, [pc, #68]	; (400900 <usb_d_init+0x48>)
  4008bc:	4798      	blx	r3
	uint8_t i;
	if (rc < 0) {
  4008be:	2800      	cmp	r0, #0
  4008c0:	db1c      	blt.n	4008fc <usb_d_init+0x44>
		return rc;
	}
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
  4008c2:	4c10      	ldr	r4, [pc, #64]	; (400904 <usb_d_init+0x4c>)
  4008c4:	2280      	movs	r2, #128	; 0x80
  4008c6:	2100      	movs	r1, #0
  4008c8:	4620      	mov	r0, r4
  4008ca:	4b0f      	ldr	r3, [pc, #60]	; (400908 <usb_d_init+0x50>)
  4008cc:	4798      	blx	r3
  4008ce:	4623      	mov	r3, r4
  4008d0:	f104 0080 	add.w	r0, r4, #128	; 0x80
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
  4008d4:	21ff      	movs	r1, #255	; 0xff
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
  4008d6:	4a0d      	ldr	r2, [pc, #52]	; (40090c <usb_d_init+0x54>)
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
  4008d8:	7059      	strb	r1, [r3, #1]
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
  4008da:	615a      	str	r2, [r3, #20]
		usb_d_inst.ep[i].callbacks.more = (usb_d_ep_cb_more_t)usb_d_dummy_cb_false;
  4008dc:	619a      	str	r2, [r3, #24]
		usb_d_inst.ep[i].callbacks.xfer = (usb_d_ep_cb_xfer_t)usb_d_dummy_cb_false;
  4008de:	61da      	str	r2, [r3, #28]
  4008e0:	3320      	adds	r3, #32
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
  4008e2:	4283      	cmp	r3, r0
  4008e4:	d1f8      	bne.n	4008d8 <usb_d_init+0x20>
	}
	/* Handles device driver endpoint callbacks to build transfer. */
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_SETUP, (FUNC_PTR)usb_d_cb_trans_setup);
  4008e6:	490a      	ldr	r1, [pc, #40]	; (400910 <usb_d_init+0x58>)
  4008e8:	2000      	movs	r0, #0
  4008ea:	4c0a      	ldr	r4, [pc, #40]	; (400914 <usb_d_init+0x5c>)
  4008ec:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_MORE, (FUNC_PTR)usb_d_cb_trans_more);
  4008ee:	490a      	ldr	r1, [pc, #40]	; (400918 <usb_d_init+0x60>)
  4008f0:	2001      	movs	r0, #1
  4008f2:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_DONE, (FUNC_PTR)_usb_d_cb_trans_done);
  4008f4:	4909      	ldr	r1, [pc, #36]	; (40091c <usb_d_init+0x64>)
  4008f6:	2002      	movs	r0, #2
  4008f8:	47a0      	blx	r4
	return ERR_NONE;
  4008fa:	2000      	movs	r0, #0
}
  4008fc:	bd10      	pop	{r4, pc}
  4008fe:	bf00      	nop
  400900:	00401615 	.word	0x00401615
  400904:	2040008c 	.word	0x2040008c
  400908:	004044f3 	.word	0x004044f3
  40090c:	004006a9 	.word	0x004006a9
  400910:	00400831 	.word	0x00400831
  400914:	00401d95 	.word	0x00401d95
  400918:	004006ad 	.word	0x004006ad
  40091c:	004006e1 	.word	0x004006e1

00400920 <usb_d_register_callback>:
{
	_usb_d_dev_deinit();
}

void usb_d_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
  400920:	b508      	push	{r3, lr}
	/* Directly uses device driver callback. */
	_usb_d_dev_register_callback(type, func);
  400922:	4b01      	ldr	r3, [pc, #4]	; (400928 <usb_d_register_callback+0x8>)
  400924:	4798      	blx	r3
  400926:	bd08      	pop	{r3, pc}
  400928:	00401d71 	.word	0x00401d71

0040092c <usb_d_enable>:
}

int32_t usb_d_enable(void)
{
  40092c:	b508      	push	{r3, lr}
	return _usb_d_dev_enable();
  40092e:	4b01      	ldr	r3, [pc, #4]	; (400934 <usb_d_enable+0x8>)
  400930:	4798      	blx	r3
}
  400932:	bd08      	pop	{r3, pc}
  400934:	00401665 	.word	0x00401665

00400938 <usb_d_attach>:
{
	_usb_d_dev_disable();
}

void usb_d_attach(void)
{
  400938:	b508      	push	{r3, lr}
	_usb_d_dev_attach();
  40093a:	4b01      	ldr	r3, [pc, #4]	; (400940 <usb_d_attach+0x8>)
  40093c:	4798      	blx	r3
  40093e:	bd08      	pop	{r3, pc}
  400940:	004016b1 	.word	0x004016b1

00400944 <usb_d_set_address>:
{
	return _usb_d_dev_get_uframe_n();
}

void usb_d_set_address(const uint8_t addr)
{
  400944:	b508      	push	{r3, lr}
	_usb_d_dev_set_address(addr);
  400946:	4b01      	ldr	r3, [pc, #4]	; (40094c <usb_d_set_address+0x8>)
  400948:	4798      	blx	r3
  40094a:	bd08      	pop	{r3, pc}
  40094c:	004016c1 	.word	0x004016c1

00400950 <usb_d_ep_init>:
{
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
}

int32_t usb_d_ep_init(const uint8_t ep, const uint8_t attr, const uint16_t max_pkt_size)
{
  400950:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  400952:	4606      	mov	r6, r0
  400954:	460c      	mov	r4, r1
  400956:	4617      	mov	r7, r2
	int32_t          rc;
	int8_t           ep_index = _usb_d_find_ep(ep);
  400958:	4b0f      	ldr	r3, [pc, #60]	; (400998 <usb_d_ep_init+0x48>)
  40095a:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index >= 0) {
  40095c:	2800      	cmp	r0, #0
  40095e:	da14      	bge.n	40098a <usb_d_ep_init+0x3a>
		return -USB_ERR_REDO;
	} else {
		ep_index = _usb_d_find_ep(0xFF);
  400960:	20ff      	movs	r0, #255	; 0xff
  400962:	4b0d      	ldr	r3, [pc, #52]	; (400998 <usb_d_ep_init+0x48>)
  400964:	4798      	blx	r3
		if (ep_index < 0) {
  400966:	1e05      	subs	r5, r0, #0
  400968:	db12      	blt.n	400990 <usb_d_ep_init+0x40>
			return -USB_ERR_ALLOC_FAIL;
		}
		ept = &usb_d_inst.ep[ep_index];
	}
	rc = _usb_d_dev_ep_init(ep, attr, max_pkt_size);
  40096a:	463a      	mov	r2, r7
  40096c:	4621      	mov	r1, r4
  40096e:	4630      	mov	r0, r6
  400970:	4b0a      	ldr	r3, [pc, #40]	; (40099c <usb_d_ep_init+0x4c>)
  400972:	4798      	blx	r3
	if (rc < 0) {
  400974:	2800      	cmp	r0, #0
  400976:	db0d      	blt.n	400994 <usb_d_ep_init+0x44>
		return rc;
	}
	ept->xfer.hdr.ep   = ep;
  400978:	4b09      	ldr	r3, [pc, #36]	; (4009a0 <usb_d_ep_init+0x50>)
  40097a:	0168      	lsls	r0, r5, #5
  40097c:	181a      	adds	r2, r3, r0
  40097e:	7056      	strb	r6, [r2, #1]
	ept->xfer.hdr.type = attr & USB_EP_XTYPE_MASK;
  400980:	f004 0403 	and.w	r4, r4, #3
  400984:	541c      	strb	r4, [r3, r0]
	return ERR_NONE;
  400986:	2000      	movs	r0, #0
  400988:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -USB_ERR_REDO;
  40098a:	f06f 0013 	mvn.w	r0, #19
  40098e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return -USB_ERR_ALLOC_FAIL;
  400990:	f06f 0014 	mvn.w	r0, #20
}
  400994:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400996:	bf00      	nop
  400998:	00400665 	.word	0x00400665
  40099c:	004016e1 	.word	0x004016e1
  4009a0:	2040008c 	.word	0x2040008c

004009a4 <usb_d_ep0_init>:
{
  4009a4:	b508      	push	{r3, lr}
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
  4009a6:	4602      	mov	r2, r0
  4009a8:	2100      	movs	r1, #0
  4009aa:	4608      	mov	r0, r1
  4009ac:	4b01      	ldr	r3, [pc, #4]	; (4009b4 <usb_d_ep0_init+0x10>)
  4009ae:	4798      	blx	r3
}
  4009b0:	bd08      	pop	{r3, pc}
  4009b2:	bf00      	nop
  4009b4:	00400951 	.word	0x00400951

004009b8 <usb_d_ep_deinit>:

void usb_d_ep_deinit(const uint8_t ep)
{
  4009b8:	b538      	push	{r3, r4, r5, lr}
  4009ba:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
  4009bc:	4b06      	ldr	r3, [pc, #24]	; (4009d8 <usb_d_ep_deinit+0x20>)
  4009be:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index < 0) {
  4009c0:	1e04      	subs	r4, r0, #0
  4009c2:	db07      	blt.n	4009d4 <usb_d_ep_deinit+0x1c>
		return;
	}
	_usb_d_dev_ep_deinit(ep);
  4009c4:	4628      	mov	r0, r5
  4009c6:	4b05      	ldr	r3, [pc, #20]	; (4009dc <usb_d_ep_deinit+0x24>)
  4009c8:	4798      	blx	r3
	ept->xfer.hdr.ep = 0xFF;
  4009ca:	4805      	ldr	r0, [pc, #20]	; (4009e0 <usb_d_ep_deinit+0x28>)
  4009cc:	eb00 1044 	add.w	r0, r0, r4, lsl #5
  4009d0:	23ff      	movs	r3, #255	; 0xff
  4009d2:	7043      	strb	r3, [r0, #1]
  4009d4:	bd38      	pop	{r3, r4, r5, pc}
  4009d6:	bf00      	nop
  4009d8:	00400665 	.word	0x00400665
  4009dc:	00401819 	.word	0x00401819
  4009e0:	2040008c 	.word	0x2040008c

004009e4 <usb_d_ep_enable>:
}

int32_t usb_d_ep_enable(const uint8_t ep)
{
  4009e4:	b538      	push	{r3, r4, r5, lr}
  4009e6:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
  4009e8:	4b0e      	ldr	r3, [pc, #56]	; (400a24 <usb_d_ep_enable+0x40>)
  4009ea:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	int32_t          rc;
	if (ep_index < 0) {
  4009ec:	1e04      	subs	r4, r0, #0
  4009ee:	db16      	blt.n	400a1e <usb_d_ep_enable+0x3a>
		return -USB_ERR_PARAM;
	}
	ept->xfer.hdr.state = (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) ? USB_EP_S_X_SETUP : USB_EP_S_IDLE;
  4009f0:	0163      	lsls	r3, r4, #5
  4009f2:	4a0d      	ldr	r2, [pc, #52]	; (400a28 <usb_d_ep_enable+0x44>)
  4009f4:	5cd3      	ldrb	r3, [r2, r3]
  4009f6:	2b00      	cmp	r3, #0
  4009f8:	bf0c      	ite	eq
  4009fa:	2202      	moveq	r2, #2
  4009fc:	2201      	movne	r2, #1
  4009fe:	4b0a      	ldr	r3, [pc, #40]	; (400a28 <usb_d_ep_enable+0x44>)
  400a00:	eb03 1344 	add.w	r3, r3, r4, lsl #5
  400a04:	709a      	strb	r2, [r3, #2]
	rc                  = _usb_d_dev_ep_enable(ep);
  400a06:	4628      	mov	r0, r5
  400a08:	4b08      	ldr	r3, [pc, #32]	; (400a2c <usb_d_ep_enable+0x48>)
  400a0a:	4798      	blx	r3
	if (rc < 0) {
  400a0c:	2800      	cmp	r0, #0
  400a0e:	db00      	blt.n	400a12 <usb_d_ep_enable+0x2e>
		ept->xfer.hdr.state = USB_EP_S_DISABLED;
	}
	return rc;
}
  400a10:	bd38      	pop	{r3, r4, r5, pc}
		ept->xfer.hdr.state = USB_EP_S_DISABLED;
  400a12:	4b05      	ldr	r3, [pc, #20]	; (400a28 <usb_d_ep_enable+0x44>)
  400a14:	eb03 1444 	add.w	r4, r3, r4, lsl #5
  400a18:	2300      	movs	r3, #0
  400a1a:	70a3      	strb	r3, [r4, #2]
  400a1c:	bd38      	pop	{r3, r4, r5, pc}
		return -USB_ERR_PARAM;
  400a1e:	f06f 0011 	mvn.w	r0, #17
  400a22:	e7f5      	b.n	400a10 <usb_d_ep_enable+0x2c>
  400a24:	00400665 	.word	0x00400665
  400a28:	2040008c 	.word	0x2040008c
  400a2c:	00401875 	.word	0x00401875

00400a30 <usb_d_ep_transfer>:
	}
	return usb_d_inst.ep[ep_index].xfer.req;
}

int32_t usb_d_ep_transfer(const struct usb_d_transfer *xfer)
{
  400a30:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  400a34:	b086      	sub	sp, #24
  400a36:	4604      	mov	r4, r0
	int8_t                ep_index = _usb_d_find_ep(xfer->ep);
  400a38:	7a07      	ldrb	r7, [r0, #8]
  400a3a:	4638      	mov	r0, r7
  400a3c:	4b3f      	ldr	r3, [pc, #252]	; (400b3c <usb_d_ep_transfer+0x10c>)
  400a3e:	4798      	blx	r3
	struct usb_d_ep *     ept      = &usb_d_inst.ep[ep_index];
	bool                  dir = USB_EP_GET_DIR(xfer->ep), zlp = xfer->zlp;
  400a40:	7a65      	ldrb	r5, [r4, #9]
	uint32_t              len = xfer->size;
  400a42:	f8d4 8004 	ldr.w	r8, [r4, #4]
	int32_t               rc;
	volatile uint8_t      state;
	volatile hal_atomic_t flags;

	if (ep_index < 0) {
  400a46:	1e06      	subs	r6, r0, #0
  400a48:	db72      	blt.n	400b30 <usb_d_ep_transfer+0x100>
		return -USB_ERR_PARAM;
	}

	atomic_enter_critical(&flags);
  400a4a:	a804      	add	r0, sp, #16
  400a4c:	4b3c      	ldr	r3, [pc, #240]	; (400b40 <usb_d_ep_transfer+0x110>)
  400a4e:	4798      	blx	r3
	state = ept->xfer.hdr.state;
  400a50:	4b3c      	ldr	r3, [pc, #240]	; (400b44 <usb_d_ep_transfer+0x114>)
  400a52:	eb03 1346 	add.w	r3, r3, r6, lsl #5
  400a56:	789b      	ldrb	r3, [r3, #2]
  400a58:	f88d 3017 	strb.w	r3, [sp, #23]
	if (state == USB_EP_S_IDLE) {
  400a5c:	f89d 3017 	ldrb.w	r3, [sp, #23]
  400a60:	b2db      	uxtb	r3, r3
  400a62:	2b01      	cmp	r3, #1
  400a64:	d011      	beq.n	400a8a <usb_d_ep_transfer+0x5a>
		ept->xfer.hdr.state = USB_EP_S_X_DATA;
		atomic_leave_critical(&flags);
	} else {
		atomic_leave_critical(&flags);
  400a66:	a804      	add	r0, sp, #16
  400a68:	4b37      	ldr	r3, [pc, #220]	; (400b48 <usb_d_ep_transfer+0x118>)
  400a6a:	4798      	blx	r3
		switch (state) {
  400a6c:	f89d 3017 	ldrb.w	r3, [sp, #23]
  400a70:	b2db      	uxtb	r3, r3
  400a72:	2b05      	cmp	r3, #5
  400a74:	d05f      	beq.n	400b36 <usb_d_ep_transfer+0x106>
  400a76:	2b06      	cmp	r3, #6
  400a78:	d023      	beq.n	400ac2 <usb_d_ep_transfer+0x92>
		case USB_EP_S_ERROR:
			return -USB_ERROR;
		case USB_EP_S_DISABLED:
			return -USB_ERR_FUNC;
		default: /* USB_EP_S_X_xxxx  */
			return USB_BUSY;
  400a7a:	2b00      	cmp	r3, #0
  400a7c:	bf0c      	ite	eq
  400a7e:	f06f 0012 	mvneq.w	r0, #18
  400a82:	2001      	movne	r0, #1
		}
	}

	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
	return rc;
}
  400a84:	b006      	add	sp, #24
  400a86:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		ept->xfer.hdr.state = USB_EP_S_X_DATA;
  400a8a:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 400b44 <usb_d_ep_transfer+0x114>
  400a8e:	ea4f 1946 	mov.w	r9, r6, lsl #5
  400a92:	eb0a 0309 	add.w	r3, sl, r9
  400a96:	2203      	movs	r2, #3
  400a98:	709a      	strb	r2, [r3, #2]
		atomic_leave_critical(&flags);
  400a9a:	a804      	add	r0, sp, #16
  400a9c:	4b2a      	ldr	r3, [pc, #168]	; (400b48 <usb_d_ep_transfer+0x118>)
  400a9e:	4798      	blx	r3
	if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
  400aa0:	f81a 3009 	ldrb.w	r3, [sl, r9]
  400aa4:	b183      	cbz	r3, 400ac8 <usb_d_ep_transfer+0x98>
	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
  400aa6:	7a22      	ldrb	r2, [r4, #8]
  400aa8:	3500      	adds	r5, #0
  400aaa:	bf18      	it	ne
  400aac:	2501      	movne	r5, #1
	struct usb_d_transfer trans
  400aae:	6823      	ldr	r3, [r4, #0]
  400ab0:	9301      	str	r3, [sp, #4]
  400ab2:	f8cd 8008 	str.w	r8, [sp, #8]
  400ab6:	f017 0f80 	tst.w	r7, #128	; 0x80
  400aba:	d119      	bne.n	400af0 <usb_d_ep_transfer+0xc0>
  400abc:	f002 030f 	and.w	r3, r2, #15
  400ac0:	e018      	b.n	400af4 <usb_d_ep_transfer+0xc4>
			return -USB_ERROR;
  400ac2:	f06f 000f 	mvn.w	r0, #15
  400ac6:	e7dd      	b.n	400a84 <usb_d_ep_transfer+0x54>
		uint16_t req_len = USB_GET_wLength(ept->xfer.req);
  400ac8:	4b1e      	ldr	r3, [pc, #120]	; (400b44 <usb_d_ep_transfer+0x114>)
  400aca:	eb03 1346 	add.w	r3, r3, r6, lsl #5
  400ace:	7cda      	ldrb	r2, [r3, #19]
  400ad0:	7c9d      	ldrb	r5, [r3, #18]
  400ad2:	eb05 2502 	add.w	r5, r5, r2, lsl #8
  400ad6:	b2ad      	uxth	r5, r5
		if (req_len == 0) {
  400ad8:	b9a5      	cbnz	r5, 400b04 <usb_d_ep_transfer+0xd4>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
  400ada:	4b1a      	ldr	r3, [pc, #104]	; (400b44 <usb_d_ep_transfer+0x114>)
  400adc:	eb03 1646 	add.w	r6, r3, r6, lsl #5
  400ae0:	2304      	movs	r3, #4
  400ae2:	70b3      	strb	r3, [r6, #2]
			len                 = 0;
  400ae4:	2300      	movs	r3, #0
			zlp                 = true;
  400ae6:	2501      	movs	r5, #1
	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
  400ae8:	7a22      	ldrb	r2, [r4, #8]
	struct usb_d_transfer trans
  400aea:	6821      	ldr	r1, [r4, #0]
  400aec:	9101      	str	r1, [sp, #4]
  400aee:	9302      	str	r3, [sp, #8]
  400af0:	f042 0380 	orr.w	r3, r2, #128	; 0x80
  400af4:	f88d 300c 	strb.w	r3, [sp, #12]
  400af8:	f88d 500d 	strb.w	r5, [sp, #13]
	return _usb_d_dev_ep_trans(&trans);
  400afc:	a801      	add	r0, sp, #4
  400afe:	4b13      	ldr	r3, [pc, #76]	; (400b4c <usb_d_ep_transfer+0x11c>)
  400b00:	4798      	blx	r3
	return rc;
  400b02:	e7bf      	b.n	400a84 <usb_d_ep_transfer+0x54>
  400b04:	4643      	mov	r3, r8
  400b06:	45a8      	cmp	r8, r5
  400b08:	bf28      	it	cs
  400b0a:	462b      	movcs	r3, r5
			dir = (USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN);
  400b0c:	4a0d      	ldr	r2, [pc, #52]	; (400b44 <usb_d_ep_transfer+0x114>)
  400b0e:	eb02 1646 	add.w	r6, r2, r6, lsl #5
			if (dir) {
  400b12:	f996 200c 	ldrsb.w	r2, [r6, #12]
  400b16:	2a00      	cmp	r2, #0
  400b18:	db05      	blt.n	400b26 <usb_d_ep_transfer+0xf6>
	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
  400b1a:	7a22      	ldrb	r2, [r4, #8]
	struct usb_d_transfer trans
  400b1c:	6821      	ldr	r1, [r4, #0]
  400b1e:	9101      	str	r1, [sp, #4]
  400b20:	9302      	str	r3, [sp, #8]
	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
  400b22:	2500      	movs	r5, #0
  400b24:	e7ca      	b.n	400abc <usb_d_ep_transfer+0x8c>
				zlp = (req_len > len);
  400b26:	429d      	cmp	r5, r3
  400b28:	bf94      	ite	ls
  400b2a:	2500      	movls	r5, #0
  400b2c:	2501      	movhi	r5, #1
  400b2e:	e7db      	b.n	400ae8 <usb_d_ep_transfer+0xb8>
		return -USB_ERR_PARAM;
  400b30:	f06f 0011 	mvn.w	r0, #17
  400b34:	e7a6      	b.n	400a84 <usb_d_ep_transfer+0x54>
			return USB_HALTED;
  400b36:	2002      	movs	r0, #2
  400b38:	e7a4      	b.n	400a84 <usb_d_ep_transfer+0x54>
  400b3a:	bf00      	nop
  400b3c:	00400665 	.word	0x00400665
  400b40:	004003ad 	.word	0x004003ad
  400b44:	2040008c 	.word	0x2040008c
  400b48:	004003bb 	.word	0x004003bb
  400b4c:	00401c21 	.word	0x00401c21

00400b50 <usb_d_ep_halt>:
	}
	return ERR_NONE;
}

int32_t usb_d_ep_halt(const uint8_t ep, const enum usb_ep_halt_ctrl ctrl)
{
  400b50:	b538      	push	{r3, r4, r5, lr}
  400b52:	4604      	mov	r4, r0
	if (ctrl == USB_EP_HALT_CLR) {
  400b54:	b131      	cbz	r1, 400b64 <usb_d_ep_halt+0x14>
		return _usb_d_ep_halt_clr(ep);
	} else if (ctrl == USB_EP_HALT_SET) {
  400b56:	2901      	cmp	r1, #1
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
  400b58:	bf0c      	ite	eq
  400b5a:	2101      	moveq	r1, #1
	} else {
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
  400b5c:	2102      	movne	r1, #2
  400b5e:	4b12      	ldr	r3, [pc, #72]	; (400ba8 <usb_d_ep_halt+0x58>)
  400b60:	4798      	blx	r3
  400b62:	bd38      	pop	{r3, r4, r5, pc}
	int8_t           ep_index = _usb_d_find_ep(ep);
  400b64:	4b11      	ldr	r3, [pc, #68]	; (400bac <usb_d_ep_halt+0x5c>)
  400b66:	4798      	blx	r3
	if (ep_index < 0) {
  400b68:	1e05      	subs	r5, r0, #0
  400b6a:	db1a      	blt.n	400ba2 <usb_d_ep_halt+0x52>
	if (ept->xfer.hdr.state == USB_EP_S_HALTED) {
  400b6c:	4b10      	ldr	r3, [pc, #64]	; (400bb0 <usb_d_ep_halt+0x60>)
  400b6e:	eb03 1345 	add.w	r3, r3, r5, lsl #5
  400b72:	789b      	ldrb	r3, [r3, #2]
  400b74:	2b05      	cmp	r3, #5
  400b76:	d001      	beq.n	400b7c <usb_d_ep_halt+0x2c>
	return ERR_NONE;
  400b78:	2000      	movs	r0, #0
	}
}
  400b7a:	bd38      	pop	{r3, r4, r5, pc}
		rc = _usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
  400b7c:	2100      	movs	r1, #0
  400b7e:	4620      	mov	r0, r4
  400b80:	4b09      	ldr	r3, [pc, #36]	; (400ba8 <usb_d_ep_halt+0x58>)
  400b82:	4798      	blx	r3
		if (rc < 0) {
  400b84:	2800      	cmp	r0, #0
  400b86:	dbf8      	blt.n	400b7a <usb_d_ep_halt+0x2a>
		ept->xfer.hdr.state  = USB_EP_S_IDLE;
  400b88:	4b09      	ldr	r3, [pc, #36]	; (400bb0 <usb_d_ep_halt+0x60>)
  400b8a:	eb03 1545 	add.w	r5, r3, r5, lsl #5
  400b8e:	2301      	movs	r3, #1
  400b90:	70ab      	strb	r3, [r5, #2]
		ept->xfer.hdr.status = USB_XFER_UNHALT;
  400b92:	2103      	movs	r1, #3
  400b94:	70e9      	strb	r1, [r5, #3]
		ept->callbacks.xfer(ep, USB_XFER_UNHALT, NULL);
  400b96:	69eb      	ldr	r3, [r5, #28]
  400b98:	2200      	movs	r2, #0
  400b9a:	4620      	mov	r0, r4
  400b9c:	4798      	blx	r3
	return ERR_NONE;
  400b9e:	2000      	movs	r0, #0
  400ba0:	bd38      	pop	{r3, r4, r5, pc}
		return -USB_ERR_PARAM;
  400ba2:	f06f 0011 	mvn.w	r0, #17
  400ba6:	bd38      	pop	{r3, r4, r5, pc}
  400ba8:	00401a65 	.word	0x00401a65
  400bac:	00400665 	.word	0x00400665
  400bb0:	2040008c 	.word	0x2040008c

00400bb4 <usb_d_ep_register_callback>:

void usb_d_ep_register_callback(const uint8_t ep, const enum usb_d_ep_cb_type type, const FUNC_PTR func)
{
  400bb4:	b538      	push	{r3, r4, r5, lr}
  400bb6:	460d      	mov	r5, r1
  400bb8:	4614      	mov	r4, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
  400bba:	4b0e      	ldr	r3, [pc, #56]	; (400bf4 <usb_d_ep_register_callback+0x40>)
  400bbc:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	FUNC_PTR         f        = func ? (FUNC_PTR)func : (FUNC_PTR)usb_d_dummy_cb_false;
  400bbe:	4b0e      	ldr	r3, [pc, #56]	; (400bf8 <usb_d_ep_register_callback+0x44>)
  400bc0:	2c00      	cmp	r4, #0
  400bc2:	bf08      	it	eq
  400bc4:	461c      	moveq	r4, r3
	if (ep_index < 0) {
  400bc6:	2800      	cmp	r0, #0
  400bc8:	db13      	blt.n	400bf2 <usb_d_ep_register_callback+0x3e>
		return;
	}
	switch (type) {
  400bca:	2d01      	cmp	r5, #1
  400bcc:	d008      	beq.n	400be0 <usb_d_ep_register_callback+0x2c>
  400bce:	b115      	cbz	r5, 400bd6 <usb_d_ep_register_callback+0x22>
  400bd0:	2d02      	cmp	r5, #2
  400bd2:	d00a      	beq.n	400bea <usb_d_ep_register_callback+0x36>
  400bd4:	bd38      	pop	{r3, r4, r5, pc}
	case USB_D_EP_CB_SETUP:
		ept->callbacks.req = (usb_d_ep_cb_setup_t)f;
  400bd6:	4b09      	ldr	r3, [pc, #36]	; (400bfc <usb_d_ep_register_callback+0x48>)
  400bd8:	eb03 1040 	add.w	r0, r3, r0, lsl #5
  400bdc:	6144      	str	r4, [r0, #20]
		break;
  400bde:	bd38      	pop	{r3, r4, r5, pc}
	case USB_D_EP_CB_MORE:
		ept->callbacks.more = (usb_d_ep_cb_more_t)f;
  400be0:	4b06      	ldr	r3, [pc, #24]	; (400bfc <usb_d_ep_register_callback+0x48>)
  400be2:	eb03 1040 	add.w	r0, r3, r0, lsl #5
  400be6:	6184      	str	r4, [r0, #24]
		break;
  400be8:	bd38      	pop	{r3, r4, r5, pc}
	case USB_D_EP_CB_XFER:
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
  400bea:	4b04      	ldr	r3, [pc, #16]	; (400bfc <usb_d_ep_register_callback+0x48>)
  400bec:	eb03 1040 	add.w	r0, r3, r0, lsl #5
  400bf0:	61c4      	str	r4, [r0, #28]
  400bf2:	bd38      	pop	{r3, r4, r5, pc}
  400bf4:	00400665 	.word	0x00400665
  400bf8:	004006a9 	.word	0x004006a9
  400bfc:	2040008c 	.word	0x2040008c

00400c00 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
  400c00:	b900      	cbnz	r0, 400c04 <assert+0x4>
		__asm("BKPT #0");
  400c02:	be00      	bkpt	0x0000
  400c04:	4770      	bx	lr

00400c06 <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
  400c06:	6803      	ldr	r3, [r0, #0]
  400c08:	b14b      	cbz	r3, 400c1e <is_list_element+0x18>
		if (it == element) {
  400c0a:	428b      	cmp	r3, r1
  400c0c:	d009      	beq.n	400c22 <is_list_element+0x1c>
	for (it = list->head; it; it = it->next) {
  400c0e:	681b      	ldr	r3, [r3, #0]
  400c10:	b11b      	cbz	r3, 400c1a <is_list_element+0x14>
		if (it == element) {
  400c12:	4299      	cmp	r1, r3
  400c14:	d1fb      	bne.n	400c0e <is_list_element+0x8>
			return true;
  400c16:	2001      	movs	r0, #1
		}
	}

	return false;
}
  400c18:	4770      	bx	lr
	return false;
  400c1a:	2000      	movs	r0, #0
  400c1c:	4770      	bx	lr
  400c1e:	2000      	movs	r0, #0
  400c20:	4770      	bx	lr
			return true;
  400c22:	2001      	movs	r0, #1
  400c24:	4770      	bx	lr
	...

00400c28 <list_insert_at_end>:

/**
 * \brief Insert an element at list end
 */
void list_insert_at_end(struct list_descriptor *const list, void *const element)
{
  400c28:	b570      	push	{r4, r5, r6, lr}
  400c2a:	4605      	mov	r5, r0
  400c2c:	460e      	mov	r6, r1
	struct list_element *it = list->head;
  400c2e:	6804      	ldr	r4, [r0, #0]

	ASSERT(!is_list_element(list, element));
  400c30:	4b0a      	ldr	r3, [pc, #40]	; (400c5c <list_insert_at_end+0x34>)
  400c32:	4798      	blx	r3
  400c34:	f080 0001 	eor.w	r0, r0, #1
  400c38:	2259      	movs	r2, #89	; 0x59
  400c3a:	4909      	ldr	r1, [pc, #36]	; (400c60 <list_insert_at_end+0x38>)
  400c3c:	b2c0      	uxtb	r0, r0
  400c3e:	4b09      	ldr	r3, [pc, #36]	; (400c64 <list_insert_at_end+0x3c>)
  400c40:	4798      	blx	r3

	if (!list->head) {
  400c42:	682b      	ldr	r3, [r5, #0]
  400c44:	b91b      	cbnz	r3, 400c4e <list_insert_at_end+0x26>
		list->head                             = (struct list_element *)element;
  400c46:	602e      	str	r6, [r5, #0]
		((struct list_element *)element)->next = NULL;
  400c48:	6033      	str	r3, [r6, #0]
		return;
  400c4a:	bd70      	pop	{r4, r5, r6, pc}
	}

	while (it->next) {
		it = it->next;
  400c4c:	461c      	mov	r4, r3
	while (it->next) {
  400c4e:	6823      	ldr	r3, [r4, #0]
  400c50:	2b00      	cmp	r3, #0
  400c52:	d1fb      	bne.n	400c4c <list_insert_at_end+0x24>
	}
	it->next                               = (struct list_element *)element;
  400c54:	6026      	str	r6, [r4, #0]
	((struct list_element *)element)->next = NULL;
  400c56:	6033      	str	r3, [r6, #0]
  400c58:	bd70      	pop	{r4, r5, r6, pc}
  400c5a:	bf00      	nop
  400c5c:	00400c07 	.word	0x00400c07
  400c60:	00404520 	.word	0x00404520
  400c64:	00400c01 	.word	0x00400c01

00400c68 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
  400c68:	b500      	push	{lr}
  400c6a:	b083      	sub	sp, #12
/**
 * \brief Enable FPU
 */
static inline void _fpu_enable(void)
{
	CRITICAL_SECTION_ENTER()
  400c6c:	a801      	add	r0, sp, #4
  400c6e:	4b0e      	ldr	r3, [pc, #56]	; (400ca8 <_init_chip+0x40>)
  400c70:	4798      	blx	r3
	/** Set bits 20-23 to enable CP10 and CP11 coprocessors */
	SCB->CPACR |= (0xFu << 20);
  400c72:	4a0e      	ldr	r2, [pc, #56]	; (400cac <_init_chip+0x44>)
  400c74:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
  400c78:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  400c7c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb");
  400c80:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb");
  400c84:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	CRITICAL_SECTION_LEAVE()
  400c88:	a801      	add	r0, sp, #4
  400c8a:	4b09      	ldr	r3, [pc, #36]	; (400cb0 <_init_chip+0x48>)
  400c8c:	4798      	blx	r3

static inline void hri_efc_write_EEFC_FMR_FWS_bf(const void *const hw, hri_efc_eefc_fmr_reg_t data)
{
	uint32_t tmp;
	EFC_CRITICAL_SECTION_ENTER();
	tmp = ((Efc *)hw)->EEFC_FMR;
  400c8e:	4a09      	ldr	r2, [pc, #36]	; (400cb4 <_init_chip+0x4c>)
  400c90:	6813      	ldr	r3, [r2, #0]
	tmp &= ~EEFC_FMR_FWS_Msk;
  400c92:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
	tmp |= EEFC_FMR_FWS(data);
  400c96:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
	((Efc *)hw)->EEFC_FMR = tmp;
  400c9a:	6013      	str	r3, [r2, #0]

#if CONF_DMA_ENABLE
	_pmc_enable_periph_clock(ID_XDMAC);
	_dma_init();
#endif
	_pmc_init();
  400c9c:	4b06      	ldr	r3, [pc, #24]	; (400cb8 <_init_chip+0x50>)
  400c9e:	4798      	blx	r3
}
  400ca0:	b003      	add	sp, #12
  400ca2:	f85d fb04 	ldr.w	pc, [sp], #4
  400ca6:	bf00      	nop
  400ca8:	004003ad 	.word	0x004003ad
  400cac:	e000ed00 	.word	0xe000ed00
  400cb0:	004003bb 	.word	0x004003bb
  400cb4:	400e0c00 	.word	0x400e0c00
  400cb8:	00400cbd 	.word	0x00400cbd

00400cbc <_pmc_init>:
	PMC_CRITICAL_SECTION_LEAVE();
}

static inline hri_pmc_ckgr_mor_reg_t hri_pmc_read_CKGR_MOR_reg(const void *const hw)
{
	return ((Pmc *)hw)->CKGR_MOR;
  400cbc:	4926      	ldr	r1, [pc, #152]	; (400d58 <_pmc_init+0x9c>)
  400cbe:	6a0a      	ldr	r2, [r1, #32]
	/* Enable Main XTAL oscillator */
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTEN;
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY | CKGR_MOR_MOSCSEL;
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
#else
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTBY;
  400cc0:	f022 0202 	bic.w	r2, r2, #2
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(CONF_XOSC20M_STARTUP_TIME);
  400cc4:	4b25      	ldr	r3, [pc, #148]	; (400d5c <_pmc_init+0xa0>)
  400cc6:	4313      	orrs	r3, r2
	((Pmc *)hw)->CKGR_MOR = data;
  400cc8:	620b      	str	r3, [r1, #32]
	return ((Pmc *)hw)->PMC_PMMR;
}

static inline bool hri_pmc_get_SR_MOSCXTS_bit(const void *const hw)
{
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MOSCXTS) > 0;
  400cca:	460a      	mov	r2, r1
  400ccc:	6e93      	ldr	r3, [r2, #104]	; 0x68
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
	while (!hri_pmc_get_SR_MOSCXTS_bit(PMC)) {
  400cce:	f013 0f01 	tst.w	r3, #1
  400cd2:	d0fb      	beq.n	400ccc <_pmc_init+0x10>
	((Pmc *)hw)->CKGR_MOR |= mask;
  400cd4:	4b20      	ldr	r3, [pc, #128]	; (400d58 <_pmc_init+0x9c>)
  400cd6:	6a19      	ldr	r1, [r3, #32]
  400cd8:	4a21      	ldr	r2, [pc, #132]	; (400d60 <_pmc_init+0xa4>)
  400cda:	430a      	orrs	r2, r1
  400cdc:	621a      	str	r2, [r3, #32]
	tmp = ((Pmc *)hw)->CKGR_PLLAR;
  400cde:	6a99      	ldr	r1, [r3, #40]	; 0x28
	tmp &= ~CKGR_PLLAR_MULA_Msk;
  400ce0:	4a20      	ldr	r2, [pc, #128]	; (400d64 <_pmc_init+0xa8>)
  400ce2:	400a      	ands	r2, r1
	((Pmc *)hw)->CKGR_PLLAR = tmp;
  400ce4:	629a      	str	r2, [r3, #40]	; 0x28
	((Pmc *)hw)->CKGR_PLLAR = data;
  400ce6:	4a20      	ldr	r2, [pc, #128]	; (400d68 <_pmc_init+0xac>)
  400ce8:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline bool hri_pmc_get_SR_LOCKA_bit(const void *const hw)
{
	return (((Pmc *)hw)->PMC_SR & PMC_SR_LOCKA) > 0;
  400cea:	461a      	mov	r2, r3
  400cec:	6e93      	ldr	r3, [r2, #104]	; 0x68
#if (CONF_PLLACK_ENABLE == 1)
	data = CKGR_PLLAR_MULA(CONF_PLLACK_MUL - 1) | CKGR_PLLAR_DIVA(CONF_PLLACK_DIV) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
	/* Stop PLL first */
	hri_pmc_write_CKGR_PLLAR_MULA_bf(PMC, 0);
	hri_pmc_write_CKGR_PLLAR_reg(PMC, (CKGR_PLLAR_ONE | data));
	while (!hri_pmc_get_SR_LOCKA_bit(PMC)) {
  400cee:	f013 0f02 	tst.w	r3, #2
  400cf2:	d0fb      	beq.n	400cec <_pmc_init+0x30>
	((Pmc *)hw)->CKGR_UCKR = data;
  400cf4:	f44f 0271 	mov.w	r2, #15794176	; 0xf10000
  400cf8:	4b17      	ldr	r3, [pc, #92]	; (400d58 <_pmc_init+0x9c>)
  400cfa:	61da      	str	r2, [r3, #28]
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
}

static inline bool hri_pmc_get_SR_LOCKU_bit(const void *const hw)
{
	return (((Pmc *)hw)->PMC_SR & PMC_SR_LOCKU) > 0;
  400cfc:	461a      	mov	r2, r3
  400cfe:	6e93      	ldr	r3, [r2, #104]	; 0x68
#endif

#if (CONF_UPLLCK_ENABLE == 1)
	data = CKGR_UCKR_UPLLCOUNT(PLL_COUNT);
	hri_pmc_write_CKGR_UCKR_reg(PMC, (CKGR_UCKR_UPLLEN | data));
	while (!hri_pmc_get_SR_LOCKU_bit(PMC)) {
  400d00:	f013 0f40 	tst.w	r3, #64	; 0x40
  400d04:	d0fb      	beq.n	400cfe <_pmc_init+0x42>
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400d06:	4a14      	ldr	r2, [pc, #80]	; (400d58 <_pmc_init+0x9c>)
  400d08:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp |= value << PMC_MCKR_UPLLDIV2_Pos;
  400d0a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
	((Pmc *)hw)->PMC_MCKR = tmp;
  400d0e:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400d10:	6e93      	ldr	r3, [r2, #104]	; 0x68
static void _pmc_init_master_clock(void)
{
#if (CONF_CLK_MCKR_ENABLE == 1)
#if (CONF_UPLLCK_ENABLE == 1)
	hri_pmc_write_MCKR_UPLLDIV2_bit(PMC, CONF_UPLLCKDIV_DIV);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400d12:	f013 0f08 	tst.w	r3, #8
  400d16:	d0fb      	beq.n	400d10 <_pmc_init+0x54>
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400d18:	4a0f      	ldr	r2, [pc, #60]	; (400d58 <_pmc_init+0x9c>)
  400d1a:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_PRES_Msk;
  400d1c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
	((Pmc *)hw)->PMC_MCKR = tmp;
  400d20:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400d22:	6e93      	ldr	r3, [r2, #104]	; 0x68
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
		/* Wait until master clock is ready */
	}
#elif ((CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_PLLACK) || (CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_UPLLCKDIV))
	hri_pmc_write_MCKR_PRES_bf(PMC, CONF_MCKR_PRESC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400d24:	f013 0f08 	tst.w	r3, #8
  400d28:	d0fb      	beq.n	400d22 <_pmc_init+0x66>
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400d2a:	4a0b      	ldr	r2, [pc, #44]	; (400d58 <_pmc_init+0x9c>)
  400d2c:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_MDIV_Msk;
  400d2e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
	tmp |= PMC_MCKR_MDIV(data);
  400d32:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	((Pmc *)hw)->PMC_MCKR = tmp;
  400d36:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400d38:	6e93      	ldr	r3, [r2, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_MDIV_bf(PMC, CONF_MCK_DIV);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400d3a:	f013 0f08 	tst.w	r3, #8
  400d3e:	d0fb      	beq.n	400d38 <_pmc_init+0x7c>
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400d40:	4a05      	ldr	r2, [pc, #20]	; (400d58 <_pmc_init+0x9c>)
  400d42:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_CSS_Msk;
  400d44:	f023 0303 	bic.w	r3, r3, #3
	tmp |= PMC_MCKR_CSS(data);
  400d48:	f043 0302 	orr.w	r3, r3, #2
	((Pmc *)hw)->PMC_MCKR = tmp;
  400d4c:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400d4e:	6e93      	ldr	r3, [r2, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_CSS_bf(PMC, CONF_CLK_GEN_MCKR_SRC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400d50:	f013 0f08 	tst.w	r3, #8
  400d54:	d0fb      	beq.n	400d4e <_pmc_init+0x92>
{
	_pmc_init_sources();
	_pmc_init_master_clock();
	_pmc_init_program_clock();
	_pmc_init_fs_clock();
}
  400d56:	4770      	bx	lr
  400d58:	400e0600 	.word	0x400e0600
  400d5c:	00373e01 	.word	0x00373e01
  400d60:	01370000 	.word	0x01370000
  400d64:	f800ffff 	.word	0xf800ffff
  400d68:	20183f01 	.word	0x20183f01

00400d6c <SPI0_Handler>:

/**
 * \internal SPI interrupt handler
 */
void SPI0_Handler(void)
{
  400d6c:	b508      	push	{r3, lr}
	_spi_handler(_spi0_dev);
  400d6e:	4b11      	ldr	r3, [pc, #68]	; (400db4 <SPI0_Handler+0x48>)
  400d70:	6818      	ldr	r0, [r3, #0]
	void *            hw = dev->prvt;
  400d72:	6802      	ldr	r2, [r0, #0]
	return tmp;
}

static inline hri_spi_imr_reg_t hri_spi_read_IMR_reg(const void *const hw)
{
	return ((Spi *)hw)->SPI_IMR;
  400d74:	69d3      	ldr	r3, [r2, #28]
	return tmp;
}

static inline hri_spi_sr_reg_t hri_spi_read_SR_reg(const void *const hw)
{
	return ((Spi *)hw)->SPI_SR;
  400d76:	6912      	ldr	r2, [r2, #16]
	st &= hri_spi_read_SR_reg(hw);
  400d78:	4013      	ands	r3, r2
	if (st & SPI_SR_RDRF) {
  400d7a:	f013 0f01 	tst.w	r3, #1
  400d7e:	d10a      	bne.n	400d96 <SPI0_Handler+0x2a>
	} else if (st & SPI_SR_TDRE) {
  400d80:	f013 0f02 	tst.w	r3, #2
  400d84:	d10a      	bne.n	400d9c <SPI0_Handler+0x30>
	} else if (st & SPI_SR_TXEMPTY) {
  400d86:	f413 7f00 	tst.w	r3, #512	; 0x200
  400d8a:	d10a      	bne.n	400da2 <SPI0_Handler+0x36>
	} else if (st & (SPI_SR_OVRES | SPI_SR_NSSR | SPI_SR_MODF | SPI_SR_UNDES)) {
  400d8c:	f240 520c 	movw	r2, #1292	; 0x50c
  400d90:	4213      	tst	r3, r2
  400d92:	d10a      	bne.n	400daa <SPI0_Handler+0x3e>
  400d94:	bd08      	pop	{r3, pc}
		dev->callbacks.rx(dev);
  400d96:	68c3      	ldr	r3, [r0, #12]
  400d98:	4798      	blx	r3
  400d9a:	bd08      	pop	{r3, pc}
		dev->callbacks.tx(dev);
  400d9c:	6883      	ldr	r3, [r0, #8]
  400d9e:	4798      	blx	r3
  400da0:	bd08      	pop	{r3, pc}
		dev->callbacks.complete(dev, 0);
  400da2:	6903      	ldr	r3, [r0, #16]
  400da4:	2100      	movs	r1, #0
  400da6:	4798      	blx	r3
  400da8:	bd08      	pop	{r3, pc}
		dev->callbacks.complete(dev, ERR_OVERFLOW);
  400daa:	6903      	ldr	r3, [r0, #16]
  400dac:	f06f 0112 	mvn.w	r1, #18
  400db0:	4798      	blx	r3
}
  400db2:	e7ef      	b.n	400d94 <SPI0_Handler+0x28>
  400db4:	2040010c 	.word	0x2040010c

00400db8 <_spi_m_sync_init>:

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
  400db8:	b538      	push	{r3, r4, r5, lr}
  400dba:	4605      	mov	r5, r0
  400dbc:	460c      	mov	r4, r1
	uint8_t index = ((uint32_t)hw - (uint32_t)SPI0) >> 16;
  400dbe:	4b1b      	ldr	r3, [pc, #108]	; (400e2c <_spi_m_sync_init+0x74>)
  400dc0:	440b      	add	r3, r1
		if (spi_regs[i].number == n) {
  400dc2:	f3c3 4307 	ubfx	r3, r3, #16, #8
  400dc6:	2b05      	cmp	r3, #5
  400dc8:	d10d      	bne.n	400de6 <_spi_m_sync_init+0x2e>
	const struct spi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
  400dca:	f240 124f 	movw	r2, #335	; 0x14f
  400dce:	4918      	ldr	r1, [pc, #96]	; (400e30 <_spi_m_sync_init+0x78>)
  400dd0:	2800      	cmp	r0, #0
  400dd2:	bf18      	it	ne
  400dd4:	2c00      	cmpne	r4, #0
  400dd6:	bf14      	ite	ne
  400dd8:	2001      	movne	r0, #1
  400dda:	2000      	moveq	r0, #0
  400ddc:	4b15      	ldr	r3, [pc, #84]	; (400e34 <_spi_m_sync_init+0x7c>)
  400dde:	4798      	blx	r3

	if (regs == NULL) {
		return ERR_INVALID_ARG;
  400de0:	f06f 000c 	mvn.w	r0, #12

	dev->dummy_byte = regs->dummy_byte;
	dev->char_size  = regs->csr & SPI_CSR_BITS_Msk;

	return ERR_NONE;
}
  400de4:	bd38      	pop	{r3, r4, r5, pc}
	ASSERT(dev && hw);
  400de6:	f240 124f 	movw	r2, #335	; 0x14f
  400dea:	4911      	ldr	r1, [pc, #68]	; (400e30 <_spi_m_sync_init+0x78>)
  400dec:	2800      	cmp	r0, #0
  400dee:	bf18      	it	ne
  400df0:	2c00      	cmpne	r4, #0
  400df2:	bf14      	ite	ne
  400df4:	2001      	movne	r0, #1
  400df6:	2000      	moveq	r0, #0
  400df8:	4b0e      	ldr	r3, [pc, #56]	; (400e34 <_spi_m_sync_init+0x7c>)
  400dfa:	4798      	blx	r3
	return (((Spi *)hw)->SPI_SR & SPI_SR_SPIENS) > 0;
  400dfc:	6923      	ldr	r3, [r4, #16]
	if (hri_spi_get_SR_SPIENS_bit(hw)) {
  400dfe:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  400e02:	d10f      	bne.n	400e24 <_spi_m_sync_init+0x6c>
	((Spi *)hw)->SPI_CR = data;
  400e04:	2380      	movs	r3, #128	; 0x80
  400e06:	6023      	str	r3, [r4, #0]
	dev->prvt = hw;
  400e08:	602c      	str	r4, [r5, #0]
  400e0a:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  400e0e:	6023      	str	r3, [r4, #0]
	((Spi *)hw)->SPI_MR = data;
  400e10:	4b09      	ldr	r3, [pc, #36]	; (400e38 <_spi_m_sync_init+0x80>)
  400e12:	6063      	str	r3, [r4, #4]
	((Spi *)hw)->SPI_CSR[index] = data;
  400e14:	4b09      	ldr	r3, [pc, #36]	; (400e3c <_spi_m_sync_init+0x84>)
  400e16:	6323      	str	r3, [r4, #48]	; 0x30
	dev->dummy_byte = regs->dummy_byte;
  400e18:	f64f 73ff 	movw	r3, #65535	; 0xffff
  400e1c:	80eb      	strh	r3, [r5, #6]
	dev->char_size  = regs->csr & SPI_CSR_BITS_Msk;
  400e1e:	2000      	movs	r0, #0
  400e20:	7128      	strb	r0, [r5, #4]
	return ERR_NONE;
  400e22:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_DENIED;
  400e24:	f06f 0010 	mvn.w	r0, #16
  400e28:	bd38      	pop	{r3, r4, r5, pc}
  400e2a:	bf00      	nop
  400e2c:	bfff8000 	.word	0xbfff8000
  400e30:	00404540 	.word	0x00404540
  400e34:	00400c01 	.word	0x00400c01
  400e38:	000e0011 	.word	0x000e0011
  400e3c:	04969602 	.word	0x04969602

00400e40 <_spi_m_async_init>:

int32_t _spi_m_async_init(struct _spi_m_async_dev *dev, void *const hw)
{
  400e40:	b538      	push	{r3, r4, r5, lr}
  400e42:	4604      	mov	r4, r0
  400e44:	460d      	mov	r5, r1
	struct _spi_m_async_dev *spid = dev;
	/* Do hardware initialize. */
	int32_t rc = _spi_m_sync_init((struct _spi_m_sync_dev *)dev, hw);
  400e46:	4b0f      	ldr	r3, [pc, #60]	; (400e84 <_spi_m_async_init+0x44>)
  400e48:	4798      	blx	r3

	if (rc < 0) {
  400e4a:	2800      	cmp	r0, #0
  400e4c:	db14      	blt.n	400e78 <_spi_m_async_init+0x38>
		return rc;
	}

	/* Initialize callbacks: must use them */
	spid->callbacks.complete = NULL;
  400e4e:	2300      	movs	r3, #0
  400e50:	6123      	str	r3, [r4, #16]
	spid->callbacks.rx       = NULL;
  400e52:	60e3      	str	r3, [r4, #12]
	spid->callbacks.tx       = NULL;
  400e54:	60a3      	str	r3, [r4, #8]
	if (hw == SPI0) {
  400e56:	4b0c      	ldr	r3, [pc, #48]	; (400e88 <_spi_m_async_init+0x48>)
  400e58:	429d      	cmp	r5, r3
  400e5a:	d00e      	beq.n	400e7a <_spi_m_async_init+0x3a>
		return SPI1_IRQn;
  400e5c:	232a      	movs	r3, #42	; 0x2a

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  400e5e:	f003 011f 	and.w	r1, r3, #31
  400e62:	2201      	movs	r2, #1
  400e64:	408a      	lsls	r2, r1
  400e66:	0959      	lsrs	r1, r3, #5
  400e68:	4b08      	ldr	r3, [pc, #32]	; (400e8c <_spi_m_async_init+0x4c>)
  400e6a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
  400e6e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  400e72:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180

	_spi_init_irq_param(hw, dev);
	NVIC_DisableIRQ(_spi_get_irq_num(hw));
	NVIC_ClearPendingIRQ(_spi_get_irq_num(hw));

	return ERR_NONE;
  400e76:	2000      	movs	r0, #0
}
  400e78:	bd38      	pop	{r3, r4, r5, pc}
		_spi0_dev = dev;
  400e7a:	4b05      	ldr	r3, [pc, #20]	; (400e90 <_spi_m_async_init+0x50>)
  400e7c:	601c      	str	r4, [r3, #0]
		return SPI0_IRQn;
  400e7e:	2315      	movs	r3, #21
  400e80:	e7ed      	b.n	400e5e <_spi_m_async_init+0x1e>
  400e82:	bf00      	nop
  400e84:	00400db9 	.word	0x00400db9
  400e88:	40008000 	.word	0x40008000
  400e8c:	e000e100 	.word	0xe000e100
  400e90:	2040010c 	.word	0x2040010c

00400e94 <_spi_m_async_enable>:

	return _spi_sync_enable(dev->prvt);
}

int32_t _spi_m_async_enable(struct _spi_m_async_dev *dev)
{
  400e94:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
  400e96:	4604      	mov	r4, r0
  400e98:	b1d8      	cbz	r0, 400ed2 <_spi_m_async_enable+0x3e>
  400e9a:	6800      	ldr	r0, [r0, #0]
  400e9c:	3000      	adds	r0, #0
  400e9e:	bf18      	it	ne
  400ea0:	2001      	movne	r0, #1
  400ea2:	f44f 72ca 	mov.w	r2, #404	; 0x194
  400ea6:	490c      	ldr	r1, [pc, #48]	; (400ed8 <_spi_m_async_enable+0x44>)
  400ea8:	4b0c      	ldr	r3, [pc, #48]	; (400edc <_spi_m_async_enable+0x48>)
  400eaa:	4798      	blx	r3

	return _spi_async_enable(dev->prvt);
  400eac:	6823      	ldr	r3, [r4, #0]
	((Spi *)hw)->SPI_CR = data;
  400eae:	2201      	movs	r2, #1
  400eb0:	601a      	str	r2, [r3, #0]
		return SPI1_IRQn;
  400eb2:	4a0b      	ldr	r2, [pc, #44]	; (400ee0 <_spi_m_async_enable+0x4c>)
  400eb4:	4293      	cmp	r3, r2
  400eb6:	bf0c      	ite	eq
  400eb8:	2315      	moveq	r3, #21
  400eba:	232a      	movne	r3, #42	; 0x2a
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  400ebc:	0959      	lsrs	r1, r3, #5
  400ebe:	f003 031f 	and.w	r3, r3, #31
  400ec2:	2201      	movs	r2, #1
  400ec4:	fa02 f303 	lsl.w	r3, r2, r3
  400ec8:	4a06      	ldr	r2, [pc, #24]	; (400ee4 <_spi_m_async_enable+0x50>)
  400eca:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
  400ece:	2000      	movs	r0, #0
  400ed0:	bd10      	pop	{r4, pc}
  400ed2:	2000      	movs	r0, #0
  400ed4:	e7e5      	b.n	400ea2 <_spi_m_async_enable+0xe>
  400ed6:	bf00      	nop
  400ed8:	00404540 	.word	0x00404540
  400edc:	00400c01 	.word	0x00400c01
  400ee0:	40008000 	.word	0x40008000
  400ee4:	e000e100 	.word	0xe000e100

00400ee8 <_spi_m_async_enable_tx>:

	return rc;
}

int32_t _spi_m_async_enable_tx(struct _spi_m_async_dev *dev, bool state)
{
  400ee8:	b538      	push	{r3, r4, r5, lr}
  400eea:	460d      	mov	r5, r1
	void *hw = dev->prvt;
  400eec:	6804      	ldr	r4, [r0, #0]

	ASSERT(dev && hw);
  400eee:	f240 226f 	movw	r2, #623	; 0x26f
  400ef2:	4908      	ldr	r1, [pc, #32]	; (400f14 <_spi_m_async_enable_tx+0x2c>)
  400ef4:	2800      	cmp	r0, #0
  400ef6:	bf18      	it	ne
  400ef8:	2c00      	cmpne	r4, #0
  400efa:	bf14      	ite	ne
  400efc:	2001      	movne	r0, #1
  400efe:	2000      	moveq	r0, #0
  400f00:	4b05      	ldr	r3, [pc, #20]	; (400f18 <_spi_m_async_enable_tx+0x30>)
  400f02:	4798      	blx	r3

	if (state) {
  400f04:	b91d      	cbnz	r5, 400f0e <_spi_m_async_enable_tx+0x26>
	((Spi *)hw)->SPI_IDR = SPI_IMR_TDRE;
  400f06:	2302      	movs	r3, #2
  400f08:	61a3      	str	r3, [r4, #24]
	} else {
		hri_spi_clear_IMR_TDRE_bit(hw);
	}

	return ERR_NONE;
}
  400f0a:	2000      	movs	r0, #0
  400f0c:	bd38      	pop	{r3, r4, r5, pc}
	((Spi *)hw)->SPI_IER = SPI_IMR_TDRE;
  400f0e:	2302      	movs	r3, #2
  400f10:	6163      	str	r3, [r4, #20]
  400f12:	e7fa      	b.n	400f0a <_spi_m_async_enable_tx+0x22>
  400f14:	00404540 	.word	0x00404540
  400f18:	00400c01 	.word	0x00400c01

00400f1c <_spi_m_async_enable_rx>:

int32_t _spi_m_async_enable_rx(struct _spi_m_async_dev *dev, bool state)
{
  400f1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  400f1e:	460f      	mov	r7, r1
	void *hw = dev->prvt;
  400f20:	6804      	ldr	r4, [r0, #0]

	ASSERT(dev);
  400f22:	4e0c      	ldr	r6, [pc, #48]	; (400f54 <_spi_m_async_enable_rx+0x38>)
  400f24:	f240 227e 	movw	r2, #638	; 0x27e
  400f28:	4631      	mov	r1, r6
  400f2a:	3000      	adds	r0, #0
  400f2c:	bf18      	it	ne
  400f2e:	2001      	movne	r0, #1
  400f30:	4d09      	ldr	r5, [pc, #36]	; (400f58 <_spi_m_async_enable_rx+0x3c>)
  400f32:	47a8      	blx	r5
	ASSERT(hw);
  400f34:	f240 227f 	movw	r2, #639	; 0x27f
  400f38:	4631      	mov	r1, r6
  400f3a:	1c20      	adds	r0, r4, #0
  400f3c:	bf18      	it	ne
  400f3e:	2001      	movne	r0, #1
  400f40:	47a8      	blx	r5

	if (state) {
  400f42:	b91f      	cbnz	r7, 400f4c <_spi_m_async_enable_rx+0x30>
	((Spi *)hw)->SPI_IDR = SPI_IMR_RDRF;
  400f44:	2301      	movs	r3, #1
  400f46:	61a3      	str	r3, [r4, #24]
	} else {
		hri_spi_clear_IMR_RDRF_bit(hw);
	}

	return ERR_NONE;
}
  400f48:	2000      	movs	r0, #0
  400f4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	((Spi *)hw)->SPI_IER = SPI_IMR_RDRF;
  400f4c:	2301      	movs	r3, #1
  400f4e:	6163      	str	r3, [r4, #20]
  400f50:	e7fa      	b.n	400f48 <_spi_m_async_enable_rx+0x2c>
  400f52:	bf00      	nop
  400f54:	00404540 	.word	0x00404540
  400f58:	00400c01 	.word	0x00400c01

00400f5c <_spi_m_async_write_one>:

	return ERR_NONE;
}

int32_t _spi_m_async_write_one(struct _spi_m_async_dev *dev, uint16_t data)
{
  400f5c:	b538      	push	{r3, r4, r5, lr}
  400f5e:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
  400f60:	4604      	mov	r4, r0
  400f62:	b160      	cbz	r0, 400f7e <_spi_m_async_write_one+0x22>
  400f64:	6800      	ldr	r0, [r0, #0]
  400f66:	3000      	adds	r0, #0
  400f68:	bf18      	it	ne
  400f6a:	2001      	movne	r0, #1
  400f6c:	f44f 7227 	mov.w	r2, #668	; 0x29c
  400f70:	4904      	ldr	r1, [pc, #16]	; (400f84 <_spi_m_async_write_one+0x28>)
  400f72:	4b05      	ldr	r3, [pc, #20]	; (400f88 <_spi_m_async_write_one+0x2c>)
  400f74:	4798      	blx	r3

	hri_spi_write_TDR_reg(dev->prvt, data);
  400f76:	6823      	ldr	r3, [r4, #0]
	((Spi *)hw)->SPI_TDR = data;
  400f78:	60dd      	str	r5, [r3, #12]

	return ERR_NONE;
}
  400f7a:	2000      	movs	r0, #0
  400f7c:	bd38      	pop	{r3, r4, r5, pc}
  400f7e:	2000      	movs	r0, #0
  400f80:	e7f4      	b.n	400f6c <_spi_m_async_write_one+0x10>
  400f82:	bf00      	nop
  400f84:	00404540 	.word	0x00404540
  400f88:	00400c01 	.word	0x00400c01

00400f8c <_spi_m_async_read_one>:

uint16_t _spi_m_async_read_one(struct _spi_m_async_dev *dev)
{
  400f8c:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
  400f8e:	4604      	mov	r4, r0
  400f90:	b160      	cbz	r0, 400fac <_spi_m_async_read_one+0x20>
  400f92:	6800      	ldr	r0, [r0, #0]
  400f94:	3000      	adds	r0, #0
  400f96:	bf18      	it	ne
  400f98:	2001      	movne	r0, #1
  400f9a:	f240 22a5 	movw	r2, #677	; 0x2a5
  400f9e:	4904      	ldr	r1, [pc, #16]	; (400fb0 <_spi_m_async_read_one+0x24>)
  400fa0:	4b04      	ldr	r3, [pc, #16]	; (400fb4 <_spi_m_async_read_one+0x28>)
  400fa2:	4798      	blx	r3

	return hri_spi_read_RDR_reg(dev->prvt);
  400fa4:	6823      	ldr	r3, [r4, #0]
	return ((Spi *)hw)->SPI_RDR;
  400fa6:	6898      	ldr	r0, [r3, #8]
}
  400fa8:	b280      	uxth	r0, r0
  400faa:	bd10      	pop	{r4, pc}
  400fac:	2000      	movs	r0, #0
  400fae:	e7f4      	b.n	400f9a <_spi_m_async_read_one+0xe>
  400fb0:	00404540 	.word	0x00404540
  400fb4:	00400c01 	.word	0x00400c01

00400fb8 <_spi_m_async_register_callback>:

int32_t _spi_m_async_register_callback(struct _spi_m_async_dev *dev, const enum _spi_m_async_dev_cb_type cb_type,
                                       const FUNC_PTR func)
{
  400fb8:	b570      	push	{r4, r5, r6, lr}
  400fba:	460d      	mov	r5, r1
  400fbc:	4616      	mov	r6, r2
	typedef void (*func_t)(void);
	struct _spi_m_async_dev *spid = dev;

	ASSERT(dev && (cb_type < SPI_DEV_CB_N));
  400fbe:	4604      	mov	r4, r0
  400fc0:	f44f 722c 	mov.w	r2, #688	; 0x2b0
  400fc4:	4906      	ldr	r1, [pc, #24]	; (400fe0 <_spi_m_async_register_callback+0x28>)
  400fc6:	3000      	adds	r0, #0
  400fc8:	bf18      	it	ne
  400fca:	2001      	movne	r0, #1
  400fcc:	2d02      	cmp	r5, #2
  400fce:	bf88      	it	hi
  400fd0:	2000      	movhi	r0, #0
  400fd2:	4b04      	ldr	r3, [pc, #16]	; (400fe4 <_spi_m_async_register_callback+0x2c>)
  400fd4:	4798      	blx	r3

	func_t *p_ls  = (func_t *)&spid->callbacks;
	p_ls[cb_type] = (func_t)func;
  400fd6:	eb04 0485 	add.w	r4, r4, r5, lsl #2
  400fda:	60a6      	str	r6, [r4, #8]

	return ERR_NONE;
}
  400fdc:	2000      	movs	r0, #0
  400fde:	bd70      	pop	{r4, r5, r6, pc}
  400fe0:	00404540 	.word	0x00404540
  400fe4:	00400c01 	.word	0x00400c01

00400fe8 <_delay_init>:
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
  400fe8:	4b03      	ldr	r3, [pc, #12]	; (400ff8 <_delay_init+0x10>)
  400fea:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
  400fee:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
  400ff0:	2205      	movs	r2, #5
  400ff2:	601a      	str	r2, [r3, #0]
  400ff4:	4770      	bx	lr
  400ff6:	bf00      	nop
  400ff8:	e000e010 	.word	0xe000e010

00400ffc <_dummy_func_no_return>:

/**
 * \brief Dummy callback function
 */
static void _dummy_func_no_return(uint32_t unused0, uint32_t unused1)
{
  400ffc:	4770      	bx	lr

00400ffe <_dummy_func_return_false>:
static bool _dummy_func_return_false(uint32_t unused0, uint32_t unused1)
{
	(void)unused0;
	(void)unused1;
	return false;
}
  400ffe:	2000      	movs	r0, #0
  401000:	4770      	bx	lr
	...

00401004 <_usb_d_dev_handle_setup>:
/**
 * \brief Handles setup received interrupt
 * \param[in] ept Pointer to endpoint information.
 */
static void _usb_d_dev_handle_setup(struct _usb_d_dev_ep *ept)
{
  401004:	b508      	push	{r3, lr}
	uint8_t epn     = USB_EP_GET_N(ept->ep);
  401006:	7c83      	ldrb	r3, [r0, #18]
  401008:	f003 030f 	and.w	r3, r3, #15
	bool    is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
  40100c:	7cc2      	ldrb	r2, [r0, #19]

	if (!is_ctrl) {
  40100e:	f002 0107 	and.w	r1, r2, #7
  401012:	2901      	cmp	r1, #1
  401014:	d008      	beq.n	401028 <_usb_d_dev_handle_setup+0x24>
  401016:	4a15      	ldr	r2, [pc, #84]	; (40106c <_usb_d_dev_handle_setup+0x68>)
  401018:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = mask;
}

static inline void hri_usbhs_write_DEVEPTICR_reg(const void *const hw, uint8_t index, hri_usbhs_deveptisr_reg_t data)
{
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  40101c:	2204      	movs	r2, #4
  40101e:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
}

static inline void hri_usbhs_write_DEVEPTIDR_reg(const void *const hw, uint8_t index, hri_usbhs_deveptidr_reg_t data)
{
	USBHS_CRITICAL_SECTION_ENTER();
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  401022:	f8c3 2220 	str.w	r2, [r3, #544]	; 0x220
  401026:	bd08      	pop	{r3, pc}

	/* Control transfer:
	 * SETUP transaction will terminate IN/OUT transaction,
	 * and start new transaction with received SETUP packet.
	 */
	if (_usb_d_dev_ep_is_busy(ept)) {
  401028:	f012 0f40 	tst.w	r2, #64	; 0x40
  40102c:	d00c      	beq.n	401048 <_usb_d_dev_handle_setup+0x44>
		ept->flags.bits.is_busy = 0;
  40102e:	7cc2      	ldrb	r2, [r0, #19]
  401030:	f36f 1286 	bfc	r2, #6, #1
  401034:	74c2      	strb	r2, [r0, #19]
  401036:	4a0d      	ldr	r2, [pc, #52]	; (40106c <_usb_d_dev_handle_setup+0x68>)
  401038:	eb02 0283 	add.w	r2, r2, r3, lsl #2
	((Usbhs *)hw)->USBHS_DEVEPTIFR[index] = data;
  40103c:	2101      	movs	r1, #1
  40103e:	f8c2 1190 	str.w	r1, [r2, #400]	; 0x190
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  401042:	2102      	movs	r1, #2
  401044:	f8c2 1160 	str.w	r1, [r2, #352]	; 0x160
		/* Stop transfer on either direction. */
		_usbd_ep_set_in_rdy(epn, false);
		_usbd_ep_set_out_rdy(epn, false);
	}

	ept->flags.bits.is_stalled = 0;
  401048:	7cc2      	ldrb	r2, [r0, #19]
  40104a:	f36f 02c3 	bfc	r2, #3, #1
  40104e:	74c2      	strb	r2, [r0, #19]
  401050:	4a06      	ldr	r2, [pc, #24]	; (40106c <_usb_d_dev_handle_setup+0x68>)
  401052:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  401056:	2218      	movs	r2, #24
  401058:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  40105c:	f8c3 2220 	str.w	r2, [r3, #544]	; 0x220

	/* Clear status and notify SETUP */
	_usbd_ep_int_ack(epn, USBHS_DEVEPTISR_NAKINI | USBHS_DEVEPTISR_NAKOUTI);
	_usbd_ep_int_dis(epn, USBHS_DEVEPTIMR_NAKINE | USBHS_DEVEPTIMR_NAKOUTE);
	/* Invoke callback. */
	dev_inst.ep_callbacks.setup(ept->ep);
  401060:	4b03      	ldr	r3, [pc, #12]	; (401070 <_usb_d_dev_handle_setup+0x6c>)
  401062:	689b      	ldr	r3, [r3, #8]
  401064:	7c80      	ldrb	r0, [r0, #18]
  401066:	4798      	blx	r3
  401068:	bd08      	pop	{r3, pc}
  40106a:	bf00      	nop
  40106c:	40038000 	.word	0x40038000
  401070:	20400110 	.word	0x20400110

00401074 <_usb_d_dev_trans_done>:
 *  \brief Finish the transaction and invoke callback
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_done(struct _usb_d_dev_ep *ept, const int32_t code)
{
  401074:	b538      	push	{r3, r4, r5, lr}
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
  401076:	7c84      	ldrb	r4, [r0, #18]
  401078:	2cff      	cmp	r4, #255	; 0xff
  40107a:	d003      	beq.n	401084 <_usb_d_dev_trans_done+0x10>
  40107c:	7cc3      	ldrb	r3, [r0, #19]
  40107e:	f013 0f40 	tst.w	r3, #64	; 0x40
  401082:	d100      	bne.n	401086 <_usb_d_dev_trans_done+0x12>
  401084:	bd38      	pop	{r3, r4, r5, pc}
		return;
	}

	ept->flags.bits.is_busy = 0;
  401086:	7cc2      	ldrb	r2, [r0, #19]
  401088:	f36f 1286 	bfc	r2, #6, #1
  40108c:	74c2      	strb	r2, [r0, #19]
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
  40108e:	4a03      	ldr	r2, [pc, #12]	; (40109c <_usb_d_dev_trans_done+0x28>)
  401090:	6915      	ldr	r5, [r2, #16]
  401092:	6882      	ldr	r2, [r0, #8]
  401094:	4620      	mov	r0, r4
  401096:	47a8      	blx	r5
  401098:	e7f4      	b.n	401084 <_usb_d_dev_trans_done+0x10>
  40109a:	bf00      	nop
  40109c:	20400110 	.word	0x20400110

004010a0 <_usb_d_dev_reset_epts>:
{
  4010a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
}

static inline void hri_usbhs_clear_DEVCTRL_ADDEN_bit(const void *const hw)
{
	USBHS_CRITICAL_SECTION_ENTER();
	((Usbhs *)hw)->USBHS_DEVCTRL &= ~USBHS_DEVCTRL_ADDEN;
  4010a4:	4b0f      	ldr	r3, [pc, #60]	; (4010e4 <_usb_d_dev_reset_epts+0x44>)
  4010a6:	681a      	ldr	r2, [r3, #0]
  4010a8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  4010ac:	601a      	str	r2, [r3, #0]

static inline void hri_usbhs_write_DEVCTRL_UADD_bf(const void *const hw, hri_usbhs_devctrl_reg_t data)
{
	uint32_t tmp;
	USBHS_CRITICAL_SECTION_ENTER();
	tmp = ((Usbhs *)hw)->USBHS_DEVCTRL;
  4010ae:	681a      	ldr	r2, [r3, #0]
	tmp &= ~USBHS_DEVCTRL_UADD_Msk;
  4010b0:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
	tmp |= USBHS_DEVCTRL_UADD(data);
	((Usbhs *)hw)->USBHS_DEVCTRL = tmp;
  4010b4:	601a      	str	r2, [r3, #0]
	((Usbhs *)hw)->USBHS_DEVCTRL |= USBHS_DEVCTRL_ADDEN;
  4010b6:	681a      	ldr	r2, [r3, #0]
  4010b8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  4010bc:	601a      	str	r2, [r3, #0]
  4010be:	4d0a      	ldr	r5, [pc, #40]	; (4010e8 <_usb_d_dev_reset_epts+0x48>)
  4010c0:	f105 0414 	add.w	r4, r5, #20
  4010c4:	3564      	adds	r5, #100	; 0x64
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
  4010c6:	f04f 0803 	mov.w	r8, #3
  4010ca:	4f08      	ldr	r7, [pc, #32]	; (4010ec <_usb_d_dev_reset_epts+0x4c>)
		dev_inst.ep[i].ep       = 0xFF;
  4010cc:	26ff      	movs	r6, #255	; 0xff
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
  4010ce:	4641      	mov	r1, r8
  4010d0:	4620      	mov	r0, r4
  4010d2:	47b8      	blx	r7
		dev_inst.ep[i].ep       = 0xFF;
  4010d4:	74a6      	strb	r6, [r4, #18]
		dev_inst.ep[i].flags.u8 = 0;
  4010d6:	2300      	movs	r3, #0
  4010d8:	74e3      	strb	r3, [r4, #19]
  4010da:	3414      	adds	r4, #20
	for (i = 0; i < USB_D_N_EP; i++) {
  4010dc:	42ac      	cmp	r4, r5
  4010de:	d1f6      	bne.n	4010ce <_usb_d_dev_reset_epts+0x2e>
}
  4010e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4010e4:	40038000 	.word	0x40038000
  4010e8:	20400110 	.word	0x20400110
  4010ec:	00401075 	.word	0x00401075

004010f0 <_usb_d_dev_dma_next>:
	if (!ept->flags.bits.is_busy) {
  4010f0:	7cc2      	ldrb	r2, [r0, #19]
  4010f2:	f012 0f40 	tst.w	r2, #64	; 0x40
  4010f6:	d067      	beq.n	4011c8 <_usb_d_dev_dma_next+0xd8>
{
  4010f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t  epn = USB_EP_GET_N(ept->ep);
  4010fa:	7c81      	ldrb	r1, [r0, #18]
  4010fc:	f001 010f 	and.w	r1, r1, #15
	if (ept->trans_count != ept->trans_size) {
  401100:	6887      	ldr	r7, [r0, #8]
  401102:	6843      	ldr	r3, [r0, #4]
  401104:	429f      	cmp	r7, r3
  401106:	d021      	beq.n	40114c <_usb_d_dev_dma_next+0x5c>
		trans_next = ept->trans_size - ept->trans_count;
  401108:	1bdb      	subs	r3, r3, r7
		if (trans_next > USB_D_DEV_TRANS_MAX) {
  40110a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  40110e:	d826      	bhi.n	40115e <_usb_d_dev_dma_next+0x6e>
			dma_ctrl = USBHS_DEVDMACONTROL_BUFF_LENGTH(trans_next);
  401110:	041e      	lsls	r6, r3, #16
		if ((ept->flags.bits.dir) && (!ept->flags.bits.need_zlp)) {
  401112:	f002 0590 	and.w	r5, r2, #144	; 0x90
  401116:	2d80      	cmp	r5, #128	; 0x80
  401118:	d025      	beq.n	401166 <_usb_d_dev_dma_next+0x76>
			if ((ept->flags.bits.eptype != USB_D_EPTYPE_ISOCH) || (trans_next <= ept->size)) {
  40111a:	f002 0207 	and.w	r2, r2, #7
  40111e:	2a02      	cmp	r2, #2
  401120:	d024      	beq.n	40116c <_usb_d_dev_dma_next+0x7c>
				dma_ctrl |= USBHS_DEVDMACONTROL_END_TR_IT | USBHS_DEVDMACONTROL_END_TR_EN;
  401122:	f046 0614 	orr.w	r6, r6, #20
		hri_usbhs_write_DEVDMAADDRESS_reg(hw, (epn - 1), (uint32_t)&ept->trans_buf[ept->trans_count]);
  401126:	6802      	ldr	r2, [r0, #0]
  401128:	4417      	add	r7, r2
  40112a:	1e4a      	subs	r2, r1, #1

static inline void hri_usbhs_write_DEVDMAADDRESS_reg(const void *const hw, uint8_t submodule_index,
                                                     hri_usbhs_devdmaaddress_reg_t data)
{
	USBHS_CRITICAL_SECTION_ENTER();
	((Usbhs *)hw)->USBHS_DEVDMA[submodule_index].USBHS_DEVDMAADDRESS = data;
  40112c:	b2d2      	uxtb	r2, r2
  40112e:	4c27      	ldr	r4, [pc, #156]	; (4011cc <_usb_d_dev_dma_next+0xdc>)
  401130:	f102 0531 	add.w	r5, r2, #49	; 0x31
  401134:	eb04 1505 	add.w	r5, r4, r5, lsl #4
  401138:	606f      	str	r7, [r5, #4]
	USBHS_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_usbhs_get_DEVDMASTATUS_END_TR_ST_bit(const void *const hw, uint8_t submodule_index)
{
	return (((Usbhs *)hw)->USBHS_DEVDMA[submodule_index].USBHS_DEVDMASTATUS & USBHS_DEVDMASTATUS_END_TR_ST)
  40113a:	eb04 1402 	add.w	r4, r4, r2, lsl #4
  40113e:	f8d4 431c 	ldr.w	r4, [r4, #796]	; 0x31c
		if (!hri_usbhs_get_DEVDMASTATUS_END_TR_ST_bit(hw, (epn - 1))) {
  401142:	f014 0f10 	tst.w	r4, #16
  401146:	d015      	beq.n	401174 <_usb_d_dev_dma_next+0x84>
		ept->trans_size = ept->trans_count;
  401148:	6883      	ldr	r3, [r0, #8]
  40114a:	6043      	str	r3, [r0, #4]
	if ((ept->flags.bits.dir) && (ept->flags.bits.need_zlp)) {
  40114c:	7cc3      	ldrb	r3, [r0, #19]
  40114e:	f003 0390 	and.w	r3, r3, #144	; 0x90
  401152:	2b90      	cmp	r3, #144	; 0x90
  401154:	d020      	beq.n	401198 <_usb_d_dev_dma_next+0xa8>
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
  401156:	2100      	movs	r1, #0
  401158:	4b1d      	ldr	r3, [pc, #116]	; (4011d0 <_usb_d_dev_dma_next+0xe0>)
  40115a:	4798      	blx	r3
  40115c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			dma_ctrl = USBHS_DEVDMACONTROL_BUFF_LENGTH(0);
  40115e:	2600      	movs	r6, #0
			trans_next = USB_D_DEV_TRANS_MAX;
  401160:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  401164:	e7d5      	b.n	401112 <_usb_d_dev_dma_next+0x22>
			dma_ctrl |= USBHS_DEVDMACONTROL_END_B_EN;
  401166:	f046 0608 	orr.w	r6, r6, #8
  40116a:	e7dc      	b.n	401126 <_usb_d_dev_dma_next+0x36>
			if ((ept->flags.bits.eptype != USB_D_EPTYPE_ISOCH) || (trans_next <= ept->size)) {
  40116c:	8a02      	ldrh	r2, [r0, #16]
  40116e:	4293      	cmp	r3, r2
  401170:	d8d9      	bhi.n	401126 <_usb_d_dev_dma_next+0x36>
  401172:	e7d6      	b.n	401122 <_usb_d_dev_dma_next+0x32>
		dma_ctrl |= USBHS_DEVDMACONTROL_END_BUFFIT | USBHS_DEVDMACONTROL_CHANN_ENB;
  401174:	f046 0621 	orr.w	r6, r6, #33	; 0x21
	((Usbhs *)hw)->USBHS_DEVDMA[submodule_index].USBHS_DEVDMACONTROL = data;
  401178:	4c14      	ldr	r4, [pc, #80]	; (4011cc <_usb_d_dev_dma_next+0xdc>)
  40117a:	eb04 1202 	add.w	r2, r4, r2, lsl #4
  40117e:	f8c2 6318 	str.w	r6, [r2, #792]	; 0x318
			ept->trans_count += trans_next;
  401182:	6882      	ldr	r2, [r0, #8]
  401184:	441a      	add	r2, r3
  401186:	6082      	str	r2, [r0, #8]
			ept->trans_load = trans_next;
  401188:	60c3      	str	r3, [r0, #12]
			hri_usbhs_set_DEVIMR_reg(hw, (USBHS_DEVIMR_DMA_1 << (epn - 1)));
  40118a:	3901      	subs	r1, #1
  40118c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
  401190:	fa03 f101 	lsl.w	r1, r3, r1
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  401194:	61a1      	str	r1, [r4, #24]
  401196:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401198:	4b0c      	ldr	r3, [pc, #48]	; (4011cc <_usb_d_dev_dma_next+0xdc>)
  40119a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  40119e:	2201      	movs	r2, #1
  4011a0:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
	return (((Usbhs *)hw)->USBHS_DEVEPTISR[index] & USBHS_DEVEPTISR_RWALL) >> USBHS_DEVEPTISR_RWALL_Pos;
  4011a4:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
		if (hri_usbhs_get_DEVEPTISR_RWALL_bit(hw, epn)) {
  4011a8:	f412 3f80 	tst.w	r2, #65536	; 0x10000
  4011ac:	d002      	beq.n	4011b4 <_usb_d_dev_dma_next+0xc4>
	((Usbhs *)hw)->USBHS_DEVEPTIFR[index] = data;
  4011ae:	2201      	movs	r2, #1
  4011b0:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  4011b4:	2201      	movs	r2, #1
  4011b6:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
		hri_usbhs_set_DEVIMR_reg(hw, (USBHS_DEVIER_PEP_0 << epn));
  4011ba:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  4011be:	fa03 f101 	lsl.w	r1, r3, r1
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  4011c2:	4b02      	ldr	r3, [pc, #8]	; (4011cc <_usb_d_dev_dma_next+0xdc>)
  4011c4:	6199      	str	r1, [r3, #24]
  4011c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4011c8:	4770      	bx	lr
  4011ca:	bf00      	nop
  4011cc:	40038000 	.word	0x40038000
  4011d0:	00401075 	.word	0x00401075

004011d4 <_usb_d_dev_trans_stop>:
 * \param[in] dir Endpoint direction.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_stop(struct _usb_d_dev_ep *ept, bool dir, const int32_t code)
{
	uint8_t epn = USB_EP_GET_N(ept->ep);
  4011d4:	7c83      	ldrb	r3, [r0, #18]

	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
  4011d6:	2bff      	cmp	r3, #255	; 0xff
  4011d8:	d016      	beq.n	401208 <_usb_d_dev_trans_stop+0x34>
{
  4011da:	b510      	push	{r4, lr}
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
  4011dc:	7cc4      	ldrb	r4, [r0, #19]
  4011de:	f014 0f40 	tst.w	r4, #64	; 0x40
  4011e2:	d00a      	beq.n	4011fa <_usb_d_dev_trans_stop+0x26>
	uint8_t epn = USB_EP_GET_N(ept->ep);
  4011e4:	f003 030f 	and.w	r3, r3, #15
		return;
	}

	/* Stop transfer */
	if (dir) {
  4011e8:	b141      	cbz	r1, 4011fc <_usb_d_dev_trans_stop+0x28>
	((Usbhs *)hw)->USBHS_DEVEPTIFR[index] = data;
  4011ea:	3364      	adds	r3, #100	; 0x64
  4011ec:	2401      	movs	r4, #1
  4011ee:	4907      	ldr	r1, [pc, #28]	; (40120c <_usb_d_dev_trans_stop+0x38>)
  4011f0:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
  4011f4:	4611      	mov	r1, r2
	} else {
		/* NAK OUT */
		_usbd_ep_set_out_rdy(epn, false);
	}

	_usb_d_dev_trans_done(ept, code);
  4011f6:	4b06      	ldr	r3, [pc, #24]	; (401210 <_usb_d_dev_trans_stop+0x3c>)
  4011f8:	4798      	blx	r3
  4011fa:	bd10      	pop	{r4, pc}
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  4011fc:	3358      	adds	r3, #88	; 0x58
  4011fe:	2402      	movs	r4, #2
  401200:	4902      	ldr	r1, [pc, #8]	; (40120c <_usb_d_dev_trans_stop+0x38>)
  401202:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
  401206:	e7f5      	b.n	4011f4 <_usb_d_dev_trans_stop+0x20>
  401208:	4770      	bx	lr
  40120a:	bf00      	nop
  40120c:	40038000 	.word	0x40038000
  401210:	00401075 	.word	0x00401075

00401214 <USBHS_Handler>:
{
  401214:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401218:	b085      	sub	sp, #20
	return ((Usbhs *)hw)->USBHS_DEVISR;
  40121a:	4aaa      	ldr	r2, [pc, #680]	; (4014c4 <USBHS_Handler+0x2b0>)
  40121c:	6851      	ldr	r1, [r2, #4]
	return ((Usbhs *)hw)->USBHS_DEVIMR;
  40121e:	6913      	ldr	r3, [r2, #16]
	flags = hri_usbhs_read_DEVISR_reg(hw) & hri_usbhs_read_DEVIMR_reg(hw);
  401220:	400b      	ands	r3, r1
	ep_int = (flags & USBHS_DEVISR_PEP__Msk) >> USBHS_DEVISR_PEP__Pos;
  401222:	f3c3 370b 	ubfx	r7, r3, #12, #12
	dma_int = (flags & USBHS_DEVISR_DMA__Msk) >> USBHS_DEVISR_DMA__Pos;
  401226:	ea4f 6853 	mov.w	r8, r3, lsr #25
	if ((ep_int == 0) && (dma_int == 0)) {
  40122a:	b917      	cbnz	r7, 401232 <USBHS_Handler+0x1e>
  40122c:	f1b8 0f00 	cmp.w	r8, #0
  401230:	d002      	beq.n	401238 <USBHS_Handler+0x24>
  401232:	4ca5      	ldr	r4, [pc, #660]	; (4014c8 <USBHS_Handler+0x2b4>)
{
  401234:	2500      	movs	r5, #0
  401236:	e08a      	b.n	40134e <USBHS_Handler+0x13a>
	return ((Usbhs *)hw)->USBHS_DEVISR;
  401238:	6853      	ldr	r3, [r2, #4]
	uint16_t flags = hri_usbhs_read_DEVISR_reg(USBHS);
  40123a:	b29b      	uxth	r3, r3
	return ((Usbhs *)hw)->USBHS_DEVIMR;
  40123c:	6912      	ldr	r2, [r2, #16]
	flags &= hri_usbhs_read_DEVIMR_reg(USBHS);
  40123e:	4013      	ands	r3, r2
	if (flags & USBHS_DEVISR_SOF) {
  401240:	f013 0f04 	tst.w	r3, #4
  401244:	d117      	bne.n	401276 <USBHS_Handler+0x62>
	} else if (flags & USBHS_DEVISR_MSOF) {
  401246:	f013 0f02 	tst.w	r3, #2
  40124a:	d11d      	bne.n	401288 <USBHS_Handler+0x74>
	if (flags & USB_D_WAKEUP_INT_FLAGS) {
  40124c:	f013 0f70 	tst.w	r3, #112	; 0x70
  401250:	d121      	bne.n	401296 <USBHS_Handler+0x82>
	} else if (flags & USBHS_DEVISR_EORST) {
  401252:	f013 0f08 	tst.w	r3, #8
  401256:	d12a      	bne.n	4012ae <USBHS_Handler+0x9a>
	} else if (flags & USBHS_DEVISR_SUSP) {
  401258:	f013 0f01 	tst.w	r3, #1
  40125c:	d0e9      	beq.n	401232 <USBHS_Handler+0x1e>
	((Usbhs *)hw)->USBHS_DEVICR = data;
  40125e:	4b99      	ldr	r3, [pc, #612]	; (4014c4 <USBHS_Handler+0x2b0>)
  401260:	2201      	movs	r2, #1
  401262:	609a      	str	r2, [r3, #8]
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  401264:	615a      	str	r2, [r3, #20]
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  401266:	2270      	movs	r2, #112	; 0x70
  401268:	619a      	str	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
  40126a:	4b97      	ldr	r3, [pc, #604]	; (4014c8 <USBHS_Handler+0x2b4>)
  40126c:	685b      	ldr	r3, [r3, #4]
  40126e:	2100      	movs	r1, #0
  401270:	2004      	movs	r0, #4
  401272:	4798      	blx	r3
  401274:	e005      	b.n	401282 <USBHS_Handler+0x6e>
	((Usbhs *)hw)->USBHS_DEVICR = data;
  401276:	2204      	movs	r2, #4
  401278:	4b92      	ldr	r3, [pc, #584]	; (4014c4 <USBHS_Handler+0x2b0>)
  40127a:	609a      	str	r2, [r3, #8]
	dev_inst.callbacks.sof();
  40127c:	4b92      	ldr	r3, [pc, #584]	; (4014c8 <USBHS_Handler+0x2b4>)
  40127e:	681b      	ldr	r3, [r3, #0]
  401280:	4798      	blx	r3
}
  401282:	b005      	add	sp, #20
  401284:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  401288:	2202      	movs	r2, #2
  40128a:	4b8e      	ldr	r3, [pc, #568]	; (4014c4 <USBHS_Handler+0x2b0>)
  40128c:	609a      	str	r2, [r3, #8]
	dev_inst.callbacks.sof();
  40128e:	4b8e      	ldr	r3, [pc, #568]	; (4014c8 <USBHS_Handler+0x2b4>)
  401290:	681b      	ldr	r3, [r3, #0]
  401292:	4798      	blx	r3
  401294:	e7f5      	b.n	401282 <USBHS_Handler+0x6e>
  401296:	4b8b      	ldr	r3, [pc, #556]	; (4014c4 <USBHS_Handler+0x2b0>)
  401298:	2210      	movs	r2, #16
  40129a:	609a      	str	r2, [r3, #8]
	((Usbhs *)hw)->USBHS_DEVIDR = USBHS_DEVIMR_WAKEUPE;
  40129c:	615a      	str	r2, [r3, #20]
	((Usbhs *)hw)->USBHS_DEVIER = USBHS_DEVIMR_SUSPE;
  40129e:	2201      	movs	r2, #1
  4012a0:	619a      	str	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_WAKEUP, 0);
  4012a2:	4b89      	ldr	r3, [pc, #548]	; (4014c8 <USBHS_Handler+0x2b4>)
  4012a4:	685b      	ldr	r3, [r3, #4]
  4012a6:	2100      	movs	r1, #0
  4012a8:	2002      	movs	r0, #2
  4012aa:	4798      	blx	r3
  4012ac:	e7e9      	b.n	401282 <USBHS_Handler+0x6e>
	((Usbhs *)hw)->USBHS_DEVICR = data;
  4012ae:	4b85      	ldr	r3, [pc, #532]	; (4014c4 <USBHS_Handler+0x2b0>)
  4012b0:	2208      	movs	r2, #8
  4012b2:	609a      	str	r2, [r3, #8]
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  4012b4:	2270      	movs	r2, #112	; 0x70
  4012b6:	615a      	str	r2, [r3, #20]
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  4012b8:	2401      	movs	r4, #1
  4012ba:	619c      	str	r4, [r3, #24]
	_usb_d_dev_reset_epts();
  4012bc:	4b83      	ldr	r3, [pc, #524]	; (4014cc <USBHS_Handler+0x2b8>)
  4012be:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_RESET, 0);
  4012c0:	4b81      	ldr	r3, [pc, #516]	; (4014c8 <USBHS_Handler+0x2b4>)
  4012c2:	685b      	ldr	r3, [r3, #4]
  4012c4:	2100      	movs	r1, #0
  4012c6:	4620      	mov	r0, r4
  4012c8:	4798      	blx	r3
  4012ca:	e7da      	b.n	401282 <USBHS_Handler+0x6e>
	uint8_t epn = USB_EP_GET_N(ept->ep);
  4012cc:	f006 060f 	and.w	r6, r6, #15
	if (!(epint & (1u << epn))) {
  4012d0:	2301      	movs	r3, #1
  4012d2:	40b3      	lsls	r3, r6
  4012d4:	423b      	tst	r3, r7
  4012d6:	d036      	beq.n	401346 <USBHS_Handler+0x132>
  4012d8:	4b7a      	ldr	r3, [pc, #488]	; (4014c4 <USBHS_Handler+0x2b0>)
  4012da:	eb03 0b86 	add.w	fp, r3, r6, lsl #2
	return ((Usbhs *)hw)->USBHS_DEVEPTISR[index];
  4012de:	f8db 3130 	ldr.w	r3, [fp, #304]	; 0x130
	flags = hri_usbhs_read_DEVEPTISR_reg(hw, epn);
  4012e2:	b2db      	uxtb	r3, r3
	return ((Usbhs *)hw)->USBHS_DEVEPTIMR[index];
  4012e4:	f8db 21c0 	ldr.w	r2, [fp, #448]	; 0x1c0
	if (flags) {
  4012e8:	4013      	ands	r3, r2
  4012ea:	d02c      	beq.n	401346 <USBHS_Handler+0x132>
		if (flags & USBHS_DEVEPTISR_STALLEDI) {
  4012ec:	f013 0f40 	tst.w	r3, #64	; 0x40
  4012f0:	d122      	bne.n	401338 <USBHS_Handler+0x124>
		} else if (!_usb_d_dev_ep_is_busy(ept)) {
  4012f2:	eb05 0285 	add.w	r2, r5, r5, lsl #2
  4012f6:	4974      	ldr	r1, [pc, #464]	; (4014c8 <USBHS_Handler+0x2b4>)
  4012f8:	eb01 0282 	add.w	r2, r1, r2, lsl #2
  4012fc:	f892 2027 	ldrb.w	r2, [r2, #39]	; 0x27
  401300:	9201      	str	r2, [sp, #4]
  401302:	f012 0f40 	tst.w	r2, #64	; 0x40
  401306:	d058      	beq.n	4013ba <USBHS_Handler+0x1a6>
		} else if (_usb_d_dev_ep_is_in(ept)) {
  401308:	9a01      	ldr	r2, [sp, #4]
  40130a:	f012 0f80 	tst.w	r2, #128	; 0x80
  40130e:	d15b      	bne.n	4013c8 <USBHS_Handler+0x1b4>
	if (flags & USBHS_DEVEPTISR_OVERFI) {
  401310:	f013 0f20 	tst.w	r3, #32
  401314:	f040 8103 	bne.w	40151e <USBHS_Handler+0x30a>
	} else if (flags & USBHS_DEVEPTISR_RXOUTI) {
  401318:	f013 0f02 	tst.w	r3, #2
  40131c:	f040 810f 	bne.w	40153e <USBHS_Handler+0x32a>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
  401320:	9a01      	ldr	r2, [sp, #4]
  401322:	f002 0207 	and.w	r2, r2, #7
  401326:	2a01      	cmp	r2, #1
  401328:	d10d      	bne.n	401346 <USBHS_Handler+0x132>
		if (flags & USBHS_DEVEPTISR_RXSTPI) {
  40132a:	f013 0f04 	tst.w	r3, #4
  40132e:	d00a      	beq.n	401346 <USBHS_Handler+0x132>
			_usb_d_dev_handle_setup(ept);
  401330:	4650      	mov	r0, sl
  401332:	4b67      	ldr	r3, [pc, #412]	; (4014d0 <USBHS_Handler+0x2bc>)
  401334:	4798      	blx	r3
  401336:	e006      	b.n	401346 <USBHS_Handler+0x132>
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  401338:	2340      	movs	r3, #64	; 0x40
  40133a:	f8cb 3220 	str.w	r3, [fp, #544]	; 0x220
	_usb_d_dev_trans_done(ept, USB_TRANS_STALL);
  40133e:	2101      	movs	r1, #1
  401340:	4650      	mov	r0, sl
  401342:	4b64      	ldr	r3, [pc, #400]	; (4014d4 <USBHS_Handler+0x2c0>)
  401344:	4798      	blx	r3
  401346:	3501      	adds	r5, #1
  401348:	3414      	adds	r4, #20
	for (i = 0; i < USB_D_N_EP; i++) {
  40134a:	2d04      	cmp	r5, #4
  40134c:	d099      	beq.n	401282 <USBHS_Handler+0x6e>
		struct _usb_d_dev_ep *ept = &dev_inst.ep[i];
  40134e:	46a9      	mov	r9, r5
  401350:	9400      	str	r4, [sp, #0]
		if (ept->ep == 0xFF) {
  401352:	f894 6026 	ldrb.w	r6, [r4, #38]	; 0x26
  401356:	2eff      	cmp	r6, #255	; 0xff
  401358:	d0f5      	beq.n	401346 <USBHS_Handler+0x132>
  40135a:	f104 0a14 	add.w	sl, r4, #20
		if (ep_int) {
  40135e:	2f00      	cmp	r7, #0
  401360:	d1b4      	bne.n	4012cc <USBHS_Handler+0xb8>
		else if ((dma_int) && (_usb_d_dev_ep_is_dma(i))) {
  401362:	f1b8 0f00 	cmp.w	r8, #0
  401366:	d0ee      	beq.n	401346 <USBHS_Handler+0x132>
  401368:	1e6b      	subs	r3, r5, #1
  40136a:	b2db      	uxtb	r3, r3
  40136c:	2b06      	cmp	r3, #6
  40136e:	d8ea      	bhi.n	401346 <USBHS_Handler+0x132>
	uint8_t  epn = USB_EP_GET_N(ept->ep);
  401370:	f006 060f 	and.w	r6, r6, #15
	if (!(epint & (1u << (epn - 1)))) {
  401374:	1e71      	subs	r1, r6, #1
  401376:	2301      	movs	r3, #1
  401378:	408b      	lsls	r3, r1
  40137a:	ea13 0f08 	tst.w	r3, r8
  40137e:	d0e2      	beq.n	401346 <USBHS_Handler+0x132>
	return (((Usbhs *)hw)->USBHS_DEVDMA[submodule_index].USBHS_DEVDMASTATUS & USBHS_DEVDMASTATUS_CHANN_ENB)
  401380:	b2cb      	uxtb	r3, r1
  401382:	4a50      	ldr	r2, [pc, #320]	; (4014c4 <USBHS_Handler+0x2b0>)
  401384:	eb02 1203 	add.w	r2, r2, r3, lsl #4
  401388:	f8d2 231c 	ldr.w	r2, [r2, #796]	; 0x31c
	if (hri_usbhs_get_DEVDMASTATUS_CHANN_ENB_bit(hw, (epn - 1))) {
  40138c:	f012 0f01 	tst.w	r2, #1
  401390:	d1d9      	bne.n	401346 <USBHS_Handler+0x132>
	hri_usbhs_clear_DEVIMR_reg(hw, (USBHS_DEVIMR_DMA_1 << (epn - 1)));
  401392:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  401396:	408a      	lsls	r2, r1
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  401398:	494a      	ldr	r1, [pc, #296]	; (4014c4 <USBHS_Handler+0x2b0>)
  40139a:	614a      	str	r2, [r1, #20]
}

static inline hri_usbhs_devdmastatus_reg_t hri_usbhs_read_DEVDMASTATUS_BUFF_COUNT_bf(const void *const hw,
                                                                                     uint8_t           submodule_index)
{
	return (((Usbhs *)hw)->USBHS_DEVDMA[submodule_index].USBHS_DEVDMASTATUS & USBHS_DEVDMASTATUS_BUFF_COUNT_Msk)
  40139c:	eb01 1303 	add.w	r3, r1, r3, lsl #4
  4013a0:	f8d3 231c 	ldr.w	r2, [r3, #796]	; 0x31c
	if (trans_next) {
  4013a4:	0c12      	lsrs	r2, r2, #16
  4013a6:	d004      	beq.n	4013b2 <USBHS_Handler+0x19e>
		ept->trans_count -= trans_next;
  4013a8:	9900      	ldr	r1, [sp, #0]
  4013aa:	69cb      	ldr	r3, [r1, #28]
  4013ac:	1a9b      	subs	r3, r3, r2
  4013ae:	61cb      	str	r3, [r1, #28]
		ept->trans_size = ept->trans_count;
  4013b0:	618b      	str	r3, [r1, #24]
	_usb_d_dev_dma_next(ept);
  4013b2:	4650      	mov	r0, sl
  4013b4:	4b48      	ldr	r3, [pc, #288]	; (4014d8 <USBHS_Handler+0x2c4>)
  4013b6:	4798      	blx	r3
  4013b8:	e7c5      	b.n	401346 <USBHS_Handler+0x132>
	if (flags & USBHS_DEVEPTISR_RXSTPI) {
  4013ba:	f013 0f04 	tst.w	r3, #4
  4013be:	d0c2      	beq.n	401346 <USBHS_Handler+0x132>
		_usb_d_dev_handle_setup(ept);
  4013c0:	4650      	mov	r0, sl
  4013c2:	4b43      	ldr	r3, [pc, #268]	; (4014d0 <USBHS_Handler+0x2bc>)
  4013c4:	4798      	blx	r3
  4013c6:	e7be      	b.n	401346 <USBHS_Handler+0x132>
	if (flags & USBHS_DEVEPTISR_TXINI) {
  4013c8:	f013 0f01 	tst.w	r3, #1
  4013cc:	d10b      	bne.n	4013e6 <USBHS_Handler+0x1d2>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
  4013ce:	9a01      	ldr	r2, [sp, #4]
  4013d0:	f002 0207 	and.w	r2, r2, #7
  4013d4:	2a01      	cmp	r2, #1
  4013d6:	d1b6      	bne.n	401346 <USBHS_Handler+0x132>
		if (flags & USBHS_DEVEPTISR_RXSTPI) {
  4013d8:	f013 0f04 	tst.w	r3, #4
  4013dc:	d0b3      	beq.n	401346 <USBHS_Handler+0x132>
			_usb_d_dev_handle_setup(ept);
  4013de:	4650      	mov	r0, sl
  4013e0:	4b3b      	ldr	r3, [pc, #236]	; (4014d0 <USBHS_Handler+0x2bc>)
  4013e2:	4798      	blx	r3
  4013e4:	e7af      	b.n	401346 <USBHS_Handler+0x132>
	uint16_t last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
  4013e6:	9b00      	ldr	r3, [sp, #0]
  4013e8:	8c98      	ldrh	r0, [r3, #36]	; 0x24
  4013ea:	f240 33ff 	movw	r3, #1023	; 0x3ff
  4013ee:	4298      	cmp	r0, r3
  4013f0:	d02f      	beq.n	401452 <USBHS_Handler+0x23e>
  4013f2:	1e42      	subs	r2, r0, #1
  4013f4:	b292      	uxth	r2, r2
	bool     is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
  4013f6:	9b01      	ldr	r3, [sp, #4]
  4013f8:	f003 0307 	and.w	r3, r3, #7
  4013fc:	9302      	str	r3, [sp, #8]
	if (ept->trans_count >= ept->trans_size) {
  4013fe:	9b00      	ldr	r3, [sp, #0]
  401400:	469e      	mov	lr, r3
  401402:	69d9      	ldr	r1, [r3, #28]
  401404:	f8de 3018 	ldr.w	r3, [lr, #24]
  401408:	4299      	cmp	r1, r3
  40140a:	d367      	bcc.n	4014dc <USBHS_Handler+0x2c8>
		if (ept->flags.bits.need_zlp) {
  40140c:	9901      	ldr	r1, [sp, #4]
  40140e:	f011 0f10 	tst.w	r1, #16
  401412:	d021      	beq.n	401458 <USBHS_Handler+0x244>
			ept->trans_load          = 0;
  401414:	2100      	movs	r1, #0
  401416:	f8ce 1020 	str.w	r1, [lr, #32]
			ept->flags.bits.need_zlp = 0;
  40141a:	eb09 0389 	add.w	r3, r9, r9, lsl #2
  40141e:	4a2a      	ldr	r2, [pc, #168]	; (4014c8 <USBHS_Handler+0x2b4>)
  401420:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  401424:	f893 2027 	ldrb.w	r2, [r3, #39]	; 0x27
  401428:	f361 1204 	bfi	r2, r1, #4, #1
  40142c:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  401430:	2301      	movs	r3, #1
  401432:	f8cb 3160 	str.w	r3, [fp, #352]	; 0x160
  401436:	2308      	movs	r3, #8
  401438:	f8cb 3160 	str.w	r3, [fp, #352]	; 0x160
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  40143c:	f8cb 31f0 	str.w	r3, [fp, #496]	; 0x1f0
			if (!is_ctrl) {
  401440:	9b02      	ldr	r3, [sp, #8]
  401442:	2b01      	cmp	r3, #1
  401444:	f43f af7f 	beq.w	401346 <USBHS_Handler+0x132>
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  401448:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  40144c:	f8cb 3220 	str.w	r3, [fp, #544]	; 0x220
  401450:	e779      	b.n	401346 <USBHS_Handler+0x132>
	uint16_t last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
  401452:	f240 32ff 	movw	r2, #1023	; 0x3ff
  401456:	e7ce      	b.n	4013f6 <USBHS_Handler+0x1e2>
	uint16_t trans_count = ept->trans_load;
  401458:	9b00      	ldr	r3, [sp, #0]
  40145a:	6a1b      	ldr	r3, [r3, #32]
  40145c:	2101      	movs	r1, #1
  40145e:	f8cb 1220 	str.w	r1, [fp, #544]	; 0x220
		if (!is_ctrl) {
  401462:	9902      	ldr	r1, [sp, #8]
  401464:	2901      	cmp	r1, #1
  401466:	d005      	beq.n	401474 <USBHS_Handler+0x260>
			hri_usbhs_clear_DEVIMR_reg(hw, (USBHS_DEVIER_PEP_0 << epn));
  401468:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  40146c:	fa01 f606 	lsl.w	r6, r1, r6
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  401470:	4914      	ldr	r1, [pc, #80]	; (4014c4 <USBHS_Handler+0x2b0>)
  401472:	614e      	str	r6, [r1, #20]
		ept->trans_size = ept->trans_count;
  401474:	9e00      	ldr	r6, [sp, #0]
  401476:	69f1      	ldr	r1, [r6, #28]
  401478:	61b1      	str	r1, [r6, #24]
		if (last_pkt == ept->size) {
  40147a:	8cb0      	ldrh	r0, [r6, #36]	; 0x24
  40147c:	401a      	ands	r2, r3
  40147e:	4290      	cmp	r0, r2
  401480:	d11b      	bne.n	4014ba <USBHS_Handler+0x2a6>
			ept->flags.bits.is_busy = 0;
  401482:	2314      	movs	r3, #20
  401484:	4a10      	ldr	r2, [pc, #64]	; (4014c8 <USBHS_Handler+0x2b4>)
  401486:	fb03 2309 	mla	r3, r3, r9, r2
  40148a:	f893 2027 	ldrb.w	r2, [r3, #39]	; 0x27
  40148e:	f36f 1286 	bfc	r2, #6, #1
  401492:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
			if (dev_inst.ep_callbacks.more(ept->ep, ept->trans_count)) {
  401496:	4b0c      	ldr	r3, [pc, #48]	; (4014c8 <USBHS_Handler+0x2b4>)
  401498:	68db      	ldr	r3, [r3, #12]
  40149a:	f896 0026 	ldrb.w	r0, [r6, #38]	; 0x26
  40149e:	4798      	blx	r3
  4014a0:	2800      	cmp	r0, #0
  4014a2:	f47f af50 	bne.w	401346 <USBHS_Handler+0x132>
			ept->flags.bits.is_busy = 1;
  4014a6:	2314      	movs	r3, #20
  4014a8:	4a07      	ldr	r2, [pc, #28]	; (4014c8 <USBHS_Handler+0x2b4>)
  4014aa:	fb03 2309 	mla	r3, r3, r9, r2
  4014ae:	f893 2027 	ldrb.w	r2, [r3, #39]	; 0x27
  4014b2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
  4014b6:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
		_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
  4014ba:	2100      	movs	r1, #0
  4014bc:	4650      	mov	r0, sl
  4014be:	4b05      	ldr	r3, [pc, #20]	; (4014d4 <USBHS_Handler+0x2c0>)
  4014c0:	4798      	blx	r3
  4014c2:	e740      	b.n	401346 <USBHS_Handler+0x132>
  4014c4:	40038000 	.word	0x40038000
  4014c8:	20400110 	.word	0x20400110
  4014cc:	004010a1 	.word	0x004010a1
  4014d0:	00401005 	.word	0x00401005
  4014d4:	00401075 	.word	0x00401075
  4014d8:	004010f1 	.word	0x004010f1
		trans_next = ept->trans_size - ept->trans_count;
  4014dc:	1a5b      	subs	r3, r3, r1
  4014de:	b29b      	uxth	r3, r3
		memcpy(ptr_dest, ptr_src, trans_next);
  4014e0:	4298      	cmp	r0, r3
  4014e2:	bf28      	it	cs
  4014e4:	4618      	movcs	r0, r3
  4014e6:	4681      	mov	r9, r0
		ptr_src = &ept->trans_buf[ept->trans_count];
  4014e8:	9b00      	ldr	r3, [sp, #0]
  4014ea:	695b      	ldr	r3, [r3, #20]
		memcpy(ptr_dest, ptr_src, trans_next);
  4014ec:	4602      	mov	r2, r0
  4014ee:	4419      	add	r1, r3
  4014f0:	4842      	ldr	r0, [pc, #264]	; (4015fc <USBHS_Handler+0x3e8>)
  4014f2:	eb00 30c6 	add.w	r0, r0, r6, lsl #15
  4014f6:	4b42      	ldr	r3, [pc, #264]	; (401600 <USBHS_Handler+0x3ec>)
  4014f8:	4798      	blx	r3
		ept->trans_load = trans_next;
  4014fa:	9a00      	ldr	r2, [sp, #0]
  4014fc:	f8c2 9020 	str.w	r9, [r2, #32]
		ept->trans_count += trans_next;
  401500:	69d3      	ldr	r3, [r2, #28]
  401502:	444b      	add	r3, r9
  401504:	61d3      	str	r3, [r2, #28]
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  401506:	2301      	movs	r3, #1
  401508:	f8cb 3160 	str.w	r3, [fp, #352]	; 0x160
		if (!is_ctrl) {
  40150c:	9b02      	ldr	r3, [sp, #8]
  40150e:	2b01      	cmp	r3, #1
  401510:	f43f af19 	beq.w	401346 <USBHS_Handler+0x132>
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  401514:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  401518:	f8cb 3220 	str.w	r3, [fp, #544]	; 0x220
  40151c:	e713      	b.n	401346 <USBHS_Handler+0x132>
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  40151e:	2320      	movs	r3, #32
  401520:	f8cb 3160 	str.w	r3, [fp, #352]	; 0x160
	_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_ERROR);
  401524:	eb05 0985 	add.w	r9, r5, r5, lsl #2
  401528:	4b36      	ldr	r3, [pc, #216]	; (401604 <USBHS_Handler+0x3f0>)
  40152a:	eb03 0389 	add.w	r3, r3, r9, lsl #2
  40152e:	f893 1027 	ldrb.w	r1, [r3, #39]	; 0x27
  401532:	2204      	movs	r2, #4
  401534:	09c9      	lsrs	r1, r1, #7
  401536:	4650      	mov	r0, sl
  401538:	4b33      	ldr	r3, [pc, #204]	; (401608 <USBHS_Handler+0x3f4>)
  40153a:	4798      	blx	r3
  40153c:	e703      	b.n	401346 <USBHS_Handler+0x132>
	tmp = ((Usbhs *)hw)->USBHS_DEVEPTISR[index];
  40153e:	f8db 3130 	ldr.w	r3, [fp, #304]	; 0x130
	return (hri_usbhs_get_DEVEPTISR_reg(USBHS, epn, USBHS_DEVEPTISR_BYCT_Msk) >> USBHS_DEVEPTISR_BYCT_Pos);
  401542:	f3c3 530a 	ubfx	r3, r3, #20, #11
  401546:	4619      	mov	r1, r3
  401548:	9302      	str	r3, [sp, #8]
	uint16_t last_remain = ept->trans_size - ept->trans_count;
  40154a:	9a00      	ldr	r2, [sp, #0]
  40154c:	6993      	ldr	r3, [r2, #24]
  40154e:	69d0      	ldr	r0, [r2, #28]
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  401550:	2202      	movs	r2, #2
  401552:	f8cb 2160 	str.w	r2, [fp, #352]	; 0x160
	if (last_trans > 0) {
  401556:	2900      	cmp	r1, #0
  401558:	d043      	beq.n	4015e2 <USBHS_Handler+0x3ce>
	uint16_t last_remain = ept->trans_size - ept->trans_count;
  40155a:	1a1b      	subs	r3, r3, r0
  40155c:	b29b      	uxth	r3, r3
		if (last_trans > last_remain) {
  40155e:	4299      	cmp	r1, r3
  401560:	d93c      	bls.n	4015dc <USBHS_Handler+0x3c8>
			last_trans = last_remain;
  401562:	9302      	str	r3, [sp, #8]
			is_full    = true;
  401564:	2301      	movs	r3, #1
  401566:	9303      	str	r3, [sp, #12]
		memcpy(&ept->trans_buf[ept->trans_count], ptr, last_trans);
  401568:	9b00      	ldr	r3, [sp, #0]
  40156a:	695b      	ldr	r3, [r3, #20]
  40156c:	9a02      	ldr	r2, [sp, #8]
  40156e:	4923      	ldr	r1, [pc, #140]	; (4015fc <USBHS_Handler+0x3e8>)
  401570:	eb01 31c6 	add.w	r1, r1, r6, lsl #15
  401574:	4418      	add	r0, r3
  401576:	4b22      	ldr	r3, [pc, #136]	; (401600 <USBHS_Handler+0x3ec>)
  401578:	4798      	blx	r3
		ept->trans_count += last_trans;
  40157a:	9900      	ldr	r1, [sp, #0]
  40157c:	69cb      	ldr	r3, [r1, #28]
  40157e:	9802      	ldr	r0, [sp, #8]
  401580:	4403      	add	r3, r0
  401582:	61cb      	str	r3, [r1, #28]
		ept->trans_load = last_trans;
  401584:	460b      	mov	r3, r1
  401586:	6218      	str	r0, [r3, #32]
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  401588:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  40158c:	f8cb 3220 	str.w	r3, [fp, #544]	; 0x220
	if (last_trans < ept->size) {
  401590:	9b00      	ldr	r3, [sp, #0]
  401592:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  401594:	9a02      	ldr	r2, [sp, #8]
  401596:	4293      	cmp	r3, r2
  401598:	d926      	bls.n	4015e8 <USBHS_Handler+0x3d4>
		ept->flags.bits.need_zlp = 0;
  40159a:	eb09 0389 	add.w	r3, r9, r9, lsl #2
  40159e:	4a19      	ldr	r2, [pc, #100]	; (401604 <USBHS_Handler+0x3f0>)
  4015a0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  4015a4:	f893 2027 	ldrb.w	r2, [r3, #39]	; 0x27
  4015a8:	f36f 1204 	bfc	r2, #4, #1
  4015ac:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
  4015b0:	2302      	movs	r3, #2
  4015b2:	f8cb 3220 	str.w	r3, [fp, #544]	; 0x220
		if (!is_ctrl) {
  4015b6:	9b01      	ldr	r3, [sp, #4]
  4015b8:	f003 0307 	and.w	r3, r3, #7
  4015bc:	2b01      	cmp	r3, #1
  4015be:	d005      	beq.n	4015cc <USBHS_Handler+0x3b8>
			hri_usbhs_clear_DEVIMR_reg(hw, (USBHS_DEVIER_PEP_0 << epn));
  4015c0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  4015c4:	fa03 f606 	lsl.w	r6, r3, r6
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  4015c8:	4b10      	ldr	r3, [pc, #64]	; (40160c <USBHS_Handler+0x3f8>)
  4015ca:	615e      	str	r6, [r3, #20]
		ept->trans_size = ept->trans_count;
  4015cc:	9a00      	ldr	r2, [sp, #0]
  4015ce:	69d3      	ldr	r3, [r2, #28]
  4015d0:	6193      	str	r3, [r2, #24]
		_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
  4015d2:	2100      	movs	r1, #0
  4015d4:	4650      	mov	r0, sl
  4015d6:	4b0e      	ldr	r3, [pc, #56]	; (401610 <USBHS_Handler+0x3fc>)
  4015d8:	4798      	blx	r3
  4015da:	e6b4      	b.n	401346 <USBHS_Handler+0x132>
	bool     is_full = false, is_short = false;
  4015dc:	2300      	movs	r3, #0
  4015de:	9303      	str	r3, [sp, #12]
  4015e0:	e7c2      	b.n	401568 <USBHS_Handler+0x354>
  4015e2:	2300      	movs	r3, #0
  4015e4:	9303      	str	r3, [sp, #12]
  4015e6:	e7d3      	b.n	401590 <USBHS_Handler+0x37c>
	} else if (ept->trans_count >= ept->trans_size) {
  4015e8:	9900      	ldr	r1, [sp, #0]
  4015ea:	69ca      	ldr	r2, [r1, #28]
  4015ec:	698b      	ldr	r3, [r1, #24]
  4015ee:	429a      	cmp	r2, r3
  4015f0:	d2de      	bcs.n	4015b0 <USBHS_Handler+0x39c>
	if (is_full || is_short) {
  4015f2:	9b03      	ldr	r3, [sp, #12]
  4015f4:	2b00      	cmp	r3, #0
  4015f6:	f43f aea6 	beq.w	401346 <USBHS_Handler+0x132>
  4015fa:	e7d9      	b.n	4015b0 <USBHS_Handler+0x39c>
  4015fc:	a0100000 	.word	0xa0100000
  401600:	004044dd 	.word	0x004044dd
  401604:	20400110 	.word	0x20400110
  401608:	004011d5 	.word	0x004011d5
  40160c:	40038000 	.word	0x40038000
  401610:	00401075 	.word	0x00401075

00401614 <_usb_d_dev_init>:
{
  401614:	b508      	push	{r3, lr}
	tmp = ((Usbhs *)hw)->USBHS_CTRL;
  401616:	4b0e      	ldr	r3, [pc, #56]	; (401650 <_usb_d_dev_init+0x3c>)
  401618:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
	if (hri_usbhs_get_CTRL_USBE_bit(hw)) {
  40161c:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  401620:	d113      	bne.n	40164a <_usb_d_dev_init+0x36>
	dev_inst.callbacks.sof   = (_usb_d_dev_sof_cb_t)_dummy_func_no_return;
  401622:	4b0c      	ldr	r3, [pc, #48]	; (401654 <_usb_d_dev_init+0x40>)
  401624:	4a0c      	ldr	r2, [pc, #48]	; (401658 <_usb_d_dev_init+0x44>)
  401626:	601a      	str	r2, [r3, #0]
	dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)_dummy_func_no_return;
  401628:	605a      	str	r2, [r3, #4]
	dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)_dummy_func_no_return;
  40162a:	609a      	str	r2, [r3, #8]
	dev_inst.ep_callbacks.more  = (_usb_d_dev_ep_cb_more_t)_dummy_func_return_false;
  40162c:	490b      	ldr	r1, [pc, #44]	; (40165c <_usb_d_dev_init+0x48>)
  40162e:	60d9      	str	r1, [r3, #12]
	dev_inst.ep_callbacks.done  = (_usb_d_dev_ep_cb_done_t)_dummy_func_no_return;
  401630:	611a      	str	r2, [r3, #16]
	_usb_d_dev_reset_epts();
  401632:	4b0b      	ldr	r3, [pc, #44]	; (401660 <_usb_d_dev_init+0x4c>)
  401634:	4798      	blx	r3
	((Usbhs *)hw)->USBHS_CTRL = data;
  401636:	4b06      	ldr	r3, [pc, #24]	; (401650 <_usb_d_dev_init+0x3c>)
  401638:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  40163c:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	((Usbhs *)hw)->USBHS_DEVCTRL = data;
  401640:	f44f 6250 	mov.w	r2, #3328	; 0xd00
  401644:	601a      	str	r2, [r3, #0]
	return ERR_NONE;
  401646:	2000      	movs	r0, #0
  401648:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
  40164a:	f06f 0010 	mvn.w	r0, #16
}
  40164e:	bd08      	pop	{r3, pc}
  401650:	40038000 	.word	0x40038000
  401654:	20400110 	.word	0x20400110
  401658:	00400ffd 	.word	0x00400ffd
  40165c:	00400fff 	.word	0x00400fff
  401660:	004010a1 	.word	0x004010a1

00401664 <_usb_d_dev_enable>:
	tmp = ((Usbhs *)hw)->USBHS_CTRL;
  401664:	4b10      	ldr	r3, [pc, #64]	; (4016a8 <_usb_d_dev_enable+0x44>)
  401666:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
	if (!(hri_usbhs_get_CTRL_USBE_bit(hw))) {
  40166a:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  40166e:	d10c      	bne.n	40168a <_usb_d_dev_enable+0x26>
	((Usbhs *)hw)->USBHS_CTRL &= ~USBHS_CTRL_FRZCLK;
  401670:	4b0d      	ldr	r3, [pc, #52]	; (4016a8 <_usb_d_dev_enable+0x44>)
  401672:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
  401676:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
  40167a:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	((Usbhs *)hw)->USBHS_CTRL |= USBHS_CTRL_USBE;
  40167e:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
  401682:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
  401686:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	return (((Usbhs *)hw)->USBHS_SR & USBHS_SR_CLKUSABLE) >> USBHS_SR_CLKUSABLE_Pos;
  40168a:	4a07      	ldr	r2, [pc, #28]	; (4016a8 <_usb_d_dev_enable+0x44>)
  40168c:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
	while (!hri_usbhs_get_SR_CLKUSABLE_bit(hw)) {
  401690:	f413 4f80 	tst.w	r3, #16384	; 0x4000
  401694:	d0fa      	beq.n	40168c <_usb_d_dev_enable+0x28>
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  401696:	221d      	movs	r2, #29
  401698:	4b03      	ldr	r3, [pc, #12]	; (4016a8 <_usb_d_dev_enable+0x44>)
  40169a:	619a      	str	r2, [r3, #24]
  40169c:	2204      	movs	r2, #4
  40169e:	4b03      	ldr	r3, [pc, #12]	; (4016ac <_usb_d_dev_enable+0x48>)
  4016a0:	605a      	str	r2, [r3, #4]
}
  4016a2:	2000      	movs	r0, #0
  4016a4:	4770      	bx	lr
  4016a6:	bf00      	nop
  4016a8:	40038000 	.word	0x40038000
  4016ac:	e000e100 	.word	0xe000e100

004016b0 <_usb_d_dev_attach>:
	((Usbhs *)hw)->USBHS_DEVCTRL &= ~USBHS_DEVCTRL_DETACH;
  4016b0:	4a02      	ldr	r2, [pc, #8]	; (4016bc <_usb_d_dev_attach+0xc>)
  4016b2:	6813      	ldr	r3, [r2, #0]
  4016b4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  4016b8:	6013      	str	r3, [r2, #0]
  4016ba:	4770      	bx	lr
  4016bc:	40038000 	.word	0x40038000

004016c0 <_usb_d_dev_set_address>:
	tmp = ((Usbhs *)hw)->USBHS_DEVCTRL;
  4016c0:	4b06      	ldr	r3, [pc, #24]	; (4016dc <_usb_d_dev_set_address+0x1c>)
  4016c2:	681a      	ldr	r2, [r3, #0]
	tmp &= ~USBHS_DEVCTRL_UADD_Msk;
  4016c4:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
	tmp |= USBHS_DEVCTRL_UADD(data);
  4016c8:	f000 007f 	and.w	r0, r0, #127	; 0x7f
  4016cc:	4310      	orrs	r0, r2
	((Usbhs *)hw)->USBHS_DEVCTRL = tmp;
  4016ce:	6018      	str	r0, [r3, #0]
	((Usbhs *)hw)->USBHS_DEVCTRL |= USBHS_DEVCTRL_ADDEN;
  4016d0:	681a      	ldr	r2, [r3, #0]
  4016d2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  4016d6:	601a      	str	r2, [r3, #0]
  4016d8:	4770      	bx	lr
  4016da:	bf00      	nop
  4016dc:	40038000 	.word	0x40038000

004016e0 <_usb_d_dev_ep_init>:
{
  4016e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  4016e4:	4607      	mov	r7, r0
  4016e6:	468a      	mov	sl, r1
  4016e8:	4615      	mov	r5, r2
	uint8_t               epn = USB_EP_GET_N(ep);
  4016ea:	f000 060f 	and.w	r6, r0, #15
	bool                  dir = USB_EP_GET_DIR(ep);
  4016ee:	ea4f 18d0 	mov.w	r8, r0, lsr #7
	ASSERT(max_pkt_siz < 1024);
  4016f2:	f240 39ff 	movw	r9, #1023	; 0x3ff
  4016f6:	f240 42d9 	movw	r2, #1241	; 0x4d9
  4016fa:	4942      	ldr	r1, [pc, #264]	; (401804 <_usb_d_dev_ep_init+0x124>)
  4016fc:	454d      	cmp	r5, r9
  4016fe:	bf8c      	ite	hi
  401700:	2000      	movhi	r0, #0
  401702:	2001      	movls	r0, #1
  401704:	4b40      	ldr	r3, [pc, #256]	; (401808 <_usb_d_dev_ep_init+0x128>)
  401706:	4798      	blx	r3
	ASSERT((max_pkt_siz == 1023) || !(max_pkt_siz & (max_pkt_siz - 1)));
  401708:	454d      	cmp	r5, r9
  40170a:	d027      	beq.n	40175c <_usb_d_dev_ep_init+0x7c>
  40170c:	1e6b      	subs	r3, r5, #1
  40170e:	422b      	tst	r3, r5
  401710:	bf0c      	ite	eq
  401712:	2001      	moveq	r0, #1
  401714:	2000      	movne	r0, #0
  401716:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 401804 <_usb_d_dev_ep_init+0x124>
  40171a:	f240 42da 	movw	r2, #1242	; 0x4da
  40171e:	4649      	mov	r1, r9
  401720:	4c39      	ldr	r4, [pc, #228]	; (401808 <_usb_d_dev_ep_init+0x128>)
  401722:	47a0      	blx	r4
	ASSERT(max_pkt_siz >= 8);
  401724:	f240 42db 	movw	r2, #1243	; 0x4db
  401728:	4649      	mov	r1, r9
  40172a:	2d07      	cmp	r5, #7
  40172c:	bf94      	ite	ls
  40172e:	2000      	movls	r0, #0
  401730:	2001      	movhi	r0, #1
  401732:	47a0      	blx	r4
	uint8_t ep_type = attr & USB_EP_XTYPE_MASK;
  401734:	f00a 0a03 	and.w	sl, sl, #3
	if (epn > CONF_USB_D_MAX_EP_N) {
  401738:	2e03      	cmp	r6, #3
  40173a:	d85a      	bhi.n	4017f2 <_usb_d_dev_ep_init+0x112>
	if (ept->ep != 0xFF) {
  40173c:	eb06 0386 	add.w	r3, r6, r6, lsl #2
  401740:	4a32      	ldr	r2, [pc, #200]	; (40180c <_usb_d_dev_ep_init+0x12c>)
  401742:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  401746:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
  40174a:	2bff      	cmp	r3, #255	; 0xff
  40174c:	d155      	bne.n	4017fa <_usb_d_dev_ep_init+0x11a>
	switch (ep_type) {
  40174e:	f1ba 0f03 	cmp.w	sl, #3
  401752:	d821      	bhi.n	401798 <_usb_d_dev_ep_init+0xb8>
  401754:	e8df f00a 	tbb	[pc, sl]
  401758:	28040428 	.word	0x28040428
  40175c:	2001      	movs	r0, #1
  40175e:	e7da      	b.n	401716 <_usb_d_dev_ep_init+0x36>
		bank = USB_D_BANK_ISOCH;
  401760:	2101      	movs	r1, #1
  401762:	4a2b      	ldr	r2, [pc, #172]	; (401810 <_usb_d_dev_ep_init+0x130>)
  401764:	eb02 0286 	add.w	r2, r2, r6, lsl #2
	return ((Usbhs *)hw)->USBHS_DEVEPTCFG[index];
  401768:	f8d2 0100 	ldr.w	r0, [r2, #256]	; 0x100
	data &= ~(USBHS_DEVEPTCFG_EPBK_Msk | USBHS_DEVEPTCFG_EPSIZE_Msk | USBHS_DEVEPTCFG_EPDIR
  40176c:	4b29      	ldr	r3, [pc, #164]	; (401814 <_usb_d_dev_ep_init+0x134>)
  40176e:	4003      	ands	r3, r0
	data |= USBHS_DEVEPTCFG_EPBK(bank) | USBHS_DEVEPTCFG_EPSIZE(_usbd_ep_pcksize_size(max_pkt_siz))
  401770:	0089      	lsls	r1, r1, #2
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
  401772:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
  401776:	d819      	bhi.n	4017ac <_usb_d_dev_ep_init+0xcc>
  401778:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
  40177c:	d82f      	bhi.n	4017de <_usb_d_dev_ep_init+0xfe>
  40177e:	2d80      	cmp	r5, #128	; 0x80
  401780:	d82f      	bhi.n	4017e2 <_usb_d_dev_ep_init+0x102>
  401782:	2d40      	cmp	r5, #64	; 0x40
  401784:	d82f      	bhi.n	4017e6 <_usb_d_dev_ep_init+0x106>
  401786:	2d20      	cmp	r5, #32
  401788:	d82f      	bhi.n	4017ea <_usb_d_dev_ep_init+0x10a>
  40178a:	2d10      	cmp	r5, #16
  40178c:	d82f      	bhi.n	4017ee <_usb_d_dev_ep_init+0x10e>
  40178e:	2d08      	cmp	r5, #8
  401790:	bf94      	ite	ls
  401792:	2000      	movls	r0, #0
  401794:	2001      	movhi	r0, #1
  401796:	e00a      	b.n	4017ae <_usb_d_dev_ep_init+0xce>
		ASSERT(false);
  401798:	f44f 629f 	mov.w	r2, #1272	; 0x4f8
  40179c:	4919      	ldr	r1, [pc, #100]	; (401804 <_usb_d_dev_ep_init+0x124>)
  40179e:	2000      	movs	r0, #0
  4017a0:	4b19      	ldr	r3, [pc, #100]	; (401808 <_usb_d_dev_ep_init+0x128>)
  4017a2:	4798      	blx	r3
	uint8_t               bank = 0;
  4017a4:	2100      	movs	r1, #0
  4017a6:	e7dc      	b.n	401762 <_usb_d_dev_ep_init+0x82>
		bank = USB_D_BANK_CTRL;
  4017a8:	2100      	movs	r1, #0
  4017aa:	e7da      	b.n	401762 <_usb_d_dev_ep_init+0x82>
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
  4017ac:	2007      	movs	r0, #7
  4017ae:	ea43 23ca 	orr.w	r3, r3, sl, lsl #11
  4017b2:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
  4017b6:	430b      	orrs	r3, r1
	data |= USBHS_DEVEPTCFG_EPBK(bank) | USBHS_DEVEPTCFG_EPSIZE(_usbd_ep_pcksize_size(max_pkt_siz))
  4017b8:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
	((Usbhs *)hw)->USBHS_DEVEPTCFG[index] = data;
  4017bc:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
	ept->size     = max_pkt_siz;
  4017c0:	4b12      	ldr	r3, [pc, #72]	; (40180c <_usb_d_dev_ep_init+0x12c>)
  4017c2:	00b2      	lsls	r2, r6, #2
  4017c4:	1991      	adds	r1, r2, r6
  4017c6:	eb03 0181 	add.w	r1, r3, r1, lsl #2
  4017ca:	848d      	strh	r5, [r1, #36]	; 0x24
	ept->flags.u8 = (ep_type + 1);
  4017cc:	f10a 0401 	add.w	r4, sl, #1
  4017d0:	f881 4027 	strb.w	r4, [r1, #39]	; 0x27
	ept->ep       = ep;
  4017d4:	f881 7026 	strb.w	r7, [r1, #38]	; 0x26
	return USB_OK;
  4017d8:	2000      	movs	r0, #0
  4017da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
  4017de:	2006      	movs	r0, #6
  4017e0:	e7e5      	b.n	4017ae <_usb_d_dev_ep_init+0xce>
  4017e2:	2005      	movs	r0, #5
  4017e4:	e7e3      	b.n	4017ae <_usb_d_dev_ep_init+0xce>
  4017e6:	2004      	movs	r0, #4
  4017e8:	e7e1      	b.n	4017ae <_usb_d_dev_ep_init+0xce>
  4017ea:	2003      	movs	r0, #3
  4017ec:	e7df      	b.n	4017ae <_usb_d_dev_ep_init+0xce>
  4017ee:	2002      	movs	r0, #2
  4017f0:	e7dd      	b.n	4017ae <_usb_d_dev_ep_init+0xce>
		return -USB_ERR_PARAM;
  4017f2:	f06f 0011 	mvn.w	r0, #17
  4017f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return -USB_ERR_REDO;
  4017fa:	f06f 0013 	mvn.w	r0, #19
}
  4017fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  401802:	bf00      	nop
  401804:	00404558 	.word	0x00404558
  401808:	00400c01 	.word	0x00400c01
  40180c:	20400110 	.word	0x20400110
  401810:	40038000 	.word	0x40038000
  401814:	ffffe683 	.word	0xffffe683

00401818 <_usb_d_dev_ep_deinit>:
{
  401818:	b538      	push	{r3, r4, r5, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
  40181a:	f000 040f 	and.w	r4, r0, #15
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
  40181e:	2c03      	cmp	r4, #3
  401820:	d821      	bhi.n	401866 <_usb_d_dev_ep_deinit+0x4e>
  401822:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  401826:	4a10      	ldr	r2, [pc, #64]	; (401868 <_usb_d_dev_ep_deinit+0x50>)
  401828:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  40182c:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
  401830:	2bff      	cmp	r3, #255	; 0xff
  401832:	d018      	beq.n	401866 <_usb_d_dev_ep_deinit+0x4e>
	struct _usb_d_dev_ep *ept = &dev_inst.ep[epn];
  401834:	4615      	mov	r5, r2
  401836:	1c63      	adds	r3, r4, #1
  401838:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	_usb_d_dev_trans_stop(ept, dir, USB_TRANS_RESET);
  40183c:	2203      	movs	r2, #3
  40183e:	09c1      	lsrs	r1, r0, #7
  401840:	eb05 0083 	add.w	r0, r5, r3, lsl #2
  401844:	4b09      	ldr	r3, [pc, #36]	; (40186c <_usb_d_dev_ep_deinit+0x54>)
  401846:	4798      	blx	r3
	((Usbhs *)hw)->USBHS_DEVEPT &= ~mask;
  401848:	4a09      	ldr	r2, [pc, #36]	; (401870 <_usb_d_dev_ep_deinit+0x58>)
  40184a:	69d3      	ldr	r3, [r2, #28]
  40184c:	ea23 0304 	bic.w	r3, r3, r4
  401850:	61d3      	str	r3, [r2, #28]
	ept->flags.u8 = 0;
  401852:	00a3      	lsls	r3, r4, #2
  401854:	191a      	adds	r2, r3, r4
  401856:	eb05 0282 	add.w	r2, r5, r2, lsl #2
  40185a:	2100      	movs	r1, #0
  40185c:	f882 1027 	strb.w	r1, [r2, #39]	; 0x27
	ept->ep       = 0xFF;
  401860:	23ff      	movs	r3, #255	; 0xff
  401862:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26
  401866:	bd38      	pop	{r3, r4, r5, pc}
  401868:	20400110 	.word	0x20400110
  40186c:	004011d5 	.word	0x004011d5
  401870:	40038000 	.word	0x40038000

00401874 <_usb_d_dev_ep_enable>:
{
  401874:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t               epn          = USB_EP_GET_N(ep);
  401878:	f000 040f 	and.w	r4, r0, #15
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
  40187c:	2c03      	cmp	r4, #3
  40187e:	f200 80dc 	bhi.w	401a3a <_usb_d_dev_ep_enable+0x1c6>
  401882:	b240      	sxtb	r0, r0
  401884:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  401888:	4a74      	ldr	r2, [pc, #464]	; (401a5c <_usb_d_dev_ep_enable+0x1e8>)
  40188a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  40188e:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
  401892:	2bff      	cmp	r3, #255	; 0xff
  401894:	f000 80d5 	beq.w	401a42 <_usb_d_dev_ep_enable+0x1ce>
	if (epn == 0) {
  401898:	2c00      	cmp	r4, #0
  40189a:	d03c      	beq.n	401916 <_usb_d_dev_ep_enable+0xa2>
	uint16_t              ep_allocated = 1 << epn;
  40189c:	2301      	movs	r3, #1
  40189e:	40a3      	lsls	r3, r4
  4018a0:	b29e      	uxth	r6, r3
		for (i = CONF_USB_D_MAX_EP_N; i > epn; i--) {
  4018a2:	2c02      	cmp	r4, #2
  4018a4:	d828      	bhi.n	4018f8 <_usb_d_dev_ep_enable+0x84>
	return ((Usbhs *)hw)->USBHS_DEVEPT;
  4018a6:	4a6e      	ldr	r2, [pc, #440]	; (401a60 <_usb_d_dev_ep_enable+0x1ec>)
  4018a8:	69d2      	ldr	r2, [r2, #28]
			if (_usbd_ep_is_enabled(i)) {
  4018aa:	f012 0f08 	tst.w	r2, #8
  4018ae:	d00e      	beq.n	4018ce <_usb_d_dev_ep_enable+0x5a>
				ep_allocated |= 1 << i;
  4018b0:	f043 0608 	orr.w	r6, r3, #8
  4018b4:	b2b6      	uxth	r6, r6
  4018b6:	4a6a      	ldr	r2, [pc, #424]	; (401a60 <_usb_d_dev_ep_enable+0x1ec>)
  4018b8:	69d3      	ldr	r3, [r2, #28]
		data &= ~((uint32_t)0x1 << epn);
  4018ba:	f023 0308 	bic.w	r3, r3, #8
	((Usbhs *)hw)->USBHS_DEVEPT = data;
  4018be:	61d3      	str	r3, [r2, #28]
	((Usbhs *)hw)->USBHS_DEVEPTCFG[index] &= ~USBHS_DEVEPTCFG_ALLOC;
  4018c0:	320c      	adds	r2, #12
  4018c2:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
  4018c6:	f023 0302 	bic.w	r3, r3, #2
  4018ca:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
		for (i = CONF_USB_D_MAX_EP_N; i > epn; i--) {
  4018ce:	2c01      	cmp	r4, #1
  4018d0:	d812      	bhi.n	4018f8 <_usb_d_dev_ep_enable+0x84>
	return ((Usbhs *)hw)->USBHS_DEVEPT;
  4018d2:	4b63      	ldr	r3, [pc, #396]	; (401a60 <_usb_d_dev_ep_enable+0x1ec>)
  4018d4:	69db      	ldr	r3, [r3, #28]
			if (_usbd_ep_is_enabled(i)) {
  4018d6:	f013 0f04 	tst.w	r3, #4
  4018da:	d00d      	beq.n	4018f8 <_usb_d_dev_ep_enable+0x84>
				ep_allocated |= 1 << i;
  4018dc:	f046 0604 	orr.w	r6, r6, #4
  4018e0:	4a5f      	ldr	r2, [pc, #380]	; (401a60 <_usb_d_dev_ep_enable+0x1ec>)
  4018e2:	69d3      	ldr	r3, [r2, #28]
		data &= ~((uint32_t)0x1 << epn);
  4018e4:	f023 0304 	bic.w	r3, r3, #4
	((Usbhs *)hw)->USBHS_DEVEPT = data;
  4018e8:	61d3      	str	r3, [r2, #28]
	((Usbhs *)hw)->USBHS_DEVEPTCFG[index] &= ~USBHS_DEVEPTCFG_ALLOC;
  4018ea:	3208      	adds	r2, #8
  4018ec:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
  4018f0:	f023 0302 	bic.w	r3, r3, #2
  4018f4:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
  4018f8:	4623      	mov	r3, r4
  4018fa:	eb04 0184 	add.w	r1, r4, r4, lsl #2
  4018fe:	4a57      	ldr	r2, [pc, #348]	; (401a5c <_usb_d_dev_ep_enable+0x1e8>)
  401900:	eb02 0181 	add.w	r1, r2, r1, lsl #2
				bool                  b_restart = ptr_ep->flags.bits.is_busy;
  401904:	4694      	mov	ip, r2
  401906:	4d56      	ldr	r5, [pc, #344]	; (401a60 <_usb_d_dev_ep_enable+0x1ec>)
		data |= 0x1 << epn;
  401908:	f04f 0e01 	mov.w	lr, #1
				if (b_restart && (!_usb_d_dev_ep_is_dma(i) && !dir)) {
  40190c:	ea6f 0800 	mvn.w	r8, r0
  401910:	ea4f 78d8 	mov.w	r8, r8, lsr #31
  401914:	e02a      	b.n	40196c <_usb_d_dev_ep_enable+0xf8>
	((Usbhs *)hw)->USBHS_DEVEPTCFG[index] |= USBHS_DEVEPTCFG_ALLOC;
  401916:	4b52      	ldr	r3, [pc, #328]	; (401a60 <_usb_d_dev_ep_enable+0x1ec>)
  401918:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
  40191c:	f042 0202 	orr.w	r2, r2, #2
  401920:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	return ((Usbhs *)hw)->USBHS_DEVEPT;
  401924:	69da      	ldr	r2, [r3, #28]
		data |= 0x1 << epn;
  401926:	f042 0201 	orr.w	r2, r2, #1
	((Usbhs *)hw)->USBHS_DEVEPT = data;
  40192a:	61da      	str	r2, [r3, #28]
	return (((Usbhs *)hw)->USBHS_DEVEPTISR[index] & USBHS_DEVEPTISR_CFGOK) >> USBHS_DEVEPTISR_CFGOK_Pos;
  40192c:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
		if (!_usbd_ep_is_cfg(0)) {
  401930:	f413 2f80 	tst.w	r3, #262144	; 0x40000
  401934:	f000 8089 	beq.w	401a4a <_usb_d_dev_ep_enable+0x1d6>
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
  401938:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  40193c:	4a47      	ldr	r2, [pc, #284]	; (401a5c <_usb_d_dev_ep_enable+0x1e8>)
  40193e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  401942:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  401946:	f003 0307 	and.w	r3, r3, #7
  40194a:	2b01      	cmp	r3, #1
  40194c:	d048      	beq.n	4019e0 <_usb_d_dev_ep_enable+0x16c>
	} else if (dir) {
  40194e:	2800      	cmp	r0, #0
  401950:	db6b      	blt.n	401a2a <_usb_d_dev_ep_enable+0x1b6>
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  401952:	3458      	adds	r4, #88	; 0x58
  401954:	2202      	movs	r2, #2
  401956:	4b42      	ldr	r3, [pc, #264]	; (401a60 <_usb_d_dev_ep_enable+0x1ec>)
  401958:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
	return USB_OK;
  40195c:	2000      	movs	r0, #0
  40195e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  401962:	3301      	adds	r3, #1
  401964:	3114      	adds	r1, #20
		for (i = epn; i <= CONF_USB_D_MAX_EP_N; i++) {
  401966:	b2da      	uxtb	r2, r3
  401968:	2a03      	cmp	r2, #3
  40196a:	d8e5      	bhi.n	401938 <_usb_d_dev_ep_enable+0xc4>
			if (ep_allocated & (1 << i)) {
  40196c:	fa46 f203 	asr.w	r2, r6, r3
  401970:	f012 0f01 	tst.w	r2, #1
  401974:	d0f5      	beq.n	401962 <_usb_d_dev_ep_enable+0xee>
				bool                  b_restart = ptr_ep->flags.bits.is_busy;
  401976:	eb03 0283 	add.w	r2, r3, r3, lsl #2
  40197a:	eb0c 0282 	add.w	r2, ip, r2, lsl #2
  40197e:	f892 7027 	ldrb.w	r7, [r2, #39]	; 0x27
  401982:	f3c7 1980 	ubfx	r9, r7, #6, #1
				ptr_ep->flags.bits.is_busy      = false;
  401986:	f36f 1786 	bfc	r7, #6, #1
  40198a:	f882 7027 	strb.w	r7, [r2, #39]	; 0x27
  40198e:	eb05 0283 	add.w	r2, r5, r3, lsl #2
	((Usbhs *)hw)->USBHS_DEVEPTCFG[index] |= USBHS_DEVEPTCFG_ALLOC;
  401992:	f8d2 7100 	ldr.w	r7, [r2, #256]	; 0x100
  401996:	f047 0702 	orr.w	r7, r7, #2
  40199a:	f8c2 7100 	str.w	r7, [r2, #256]	; 0x100
	return ((Usbhs *)hw)->USBHS_DEVEPT;
  40199e:	f8d5 a01c 	ldr.w	sl, [r5, #28]
		data |= 0x1 << epn;
  4019a2:	fa0e f703 	lsl.w	r7, lr, r3
  4019a6:	ea47 070a 	orr.w	r7, r7, sl
	((Usbhs *)hw)->USBHS_DEVEPT = data;
  4019aa:	61ef      	str	r7, [r5, #28]
	return (((Usbhs *)hw)->USBHS_DEVEPTISR[index] & USBHS_DEVEPTISR_CFGOK) >> USBHS_DEVEPTISR_CFGOK_Pos;
  4019ac:	f8d2 7130 	ldr.w	r7, [r2, #304]	; 0x130
				if (!_usbd_ep_is_cfg(i)) {
  4019b0:	f417 2f80 	tst.w	r7, #262144	; 0x40000
  4019b4:	d04d      	beq.n	401a52 <_usb_d_dev_ep_enable+0x1de>
	((Usbhs *)hw)->USBHS_DEVEPTCFG[index] &= ~USBHS_DEVEPTCFG_AUTOSW;
  4019b6:	f8d2 7100 	ldr.w	r7, [r2, #256]	; 0x100
  4019ba:	f427 7700 	bic.w	r7, r7, #512	; 0x200
  4019be:	f8c2 7100 	str.w	r7, [r2, #256]	; 0x100
				if (b_restart && (!_usb_d_dev_ep_is_dma(i) && !dir)) {
  4019c2:	f1b9 0f00 	cmp.w	r9, #0
  4019c6:	d0cc      	beq.n	401962 <_usb_d_dev_ep_enable+0xee>
  4019c8:	1e5a      	subs	r2, r3, #1
  4019ca:	b2d2      	uxtb	r2, r2
  4019cc:	2a06      	cmp	r2, #6
  4019ce:	d9c8      	bls.n	401962 <_usb_d_dev_ep_enable+0xee>
  4019d0:	f1b8 0f00 	cmp.w	r8, #0
  4019d4:	d0c5      	beq.n	401962 <_usb_d_dev_ep_enable+0xee>
					ptr_ep->trans_count -= ptr_ep->trans_load;
  4019d6:	69ca      	ldr	r2, [r1, #28]
  4019d8:	6a0f      	ldr	r7, [r1, #32]
  4019da:	1bd2      	subs	r2, r2, r7
  4019dc:	61ca      	str	r2, [r1, #28]
  4019de:	e7c0      	b.n	401962 <_usb_d_dev_ep_enable+0xee>
  4019e0:	491f      	ldr	r1, [pc, #124]	; (401a60 <_usb_d_dev_ep_enable+0x1ec>)
  4019e2:	eb01 0384 	add.w	r3, r1, r4, lsl #2
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  4019e6:	2502      	movs	r5, #2
  4019e8:	f8c3 5160 	str.w	r5, [r3, #352]	; 0x160
	((Usbhs *)hw)->USBHS_DEVEPTIFR[index] = data;
  4019ec:	2001      	movs	r0, #1
  4019ee:	f8c3 0190 	str.w	r0, [r3, #400]	; 0x190
	uint8_t epn = USB_EP_GET_N(ept->ep);
  4019f2:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  4019f6:	eb02 0484 	add.w	r4, r2, r4, lsl #2
  4019fa:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
  4019fe:	f003 030f 	and.w	r3, r3, #15
  401a02:	eb01 0283 	add.w	r2, r1, r3, lsl #2
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  401a06:	2441      	movs	r4, #65	; 0x41
  401a08:	f8c2 4160 	str.w	r4, [r2, #352]	; 0x160
  401a0c:	f8c2 5160 	str.w	r5, [r2, #352]	; 0x160
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  401a10:	2406      	movs	r4, #6
  401a12:	f8c2 41f0 	str.w	r4, [r2, #496]	; 0x1f0
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  401a16:	f8c2 0220 	str.w	r0, [r2, #544]	; 0x220
	hri_usbhs_set_DEVIMR_reg(hw, (USBHS_DEVIER_PEP_0 << epn));
  401a1a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  401a1e:	fa02 f303 	lsl.w	r3, r2, r3
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  401a22:	618b      	str	r3, [r1, #24]
	return USB_OK;
  401a24:	2000      	movs	r0, #0
  401a26:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	((Usbhs *)hw)->USBHS_DEVEPTIFR[index] = data;
  401a2a:	3464      	adds	r4, #100	; 0x64
  401a2c:	2201      	movs	r2, #1
  401a2e:	4b0c      	ldr	r3, [pc, #48]	; (401a60 <_usb_d_dev_ep_enable+0x1ec>)
  401a30:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
  401a34:	2000      	movs	r0, #0
  401a36:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return -USB_ERR_PARAM;
  401a3a:	f06f 0011 	mvn.w	r0, #17
  401a3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  401a42:	f06f 0011 	mvn.w	r0, #17
  401a46:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			return -USB_ERR_ALLOC_FAIL;
  401a4a:	f06f 0014 	mvn.w	r0, #20
  401a4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					return -USB_ERR_ALLOC_FAIL;
  401a52:	f06f 0014 	mvn.w	r0, #20
}
  401a56:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  401a5a:	bf00      	nop
  401a5c:	20400110 	.word	0x20400110
  401a60:	40038000 	.word	0x40038000

00401a64 <_usb_d_dev_ep_stall>:
	uint8_t               epn = USB_EP_GET_N(ep);
  401a64:	f000 000f 	and.w	r0, r0, #15
	if (epn > CONF_USB_D_MAX_EP_N) {
  401a68:	2803      	cmp	r0, #3
  401a6a:	f200 8099 	bhi.w	401ba0 <_usb_d_dev_ep_stall+0x13c>
	if (USB_EP_STALL_SET == ctrl) {
  401a6e:	2901      	cmp	r1, #1
  401a70:	d016      	beq.n	401aa0 <_usb_d_dev_ep_stall+0x3c>
	} else if (USB_EP_STALL_CLR == ctrl) {
  401a72:	2900      	cmp	r1, #0
  401a74:	d03f      	beq.n	401af6 <_usb_d_dev_ep_stall+0x92>
	uint8_t epn = USB_EP_GET_N(ept->ep);
  401a76:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  401a7a:	4b4e      	ldr	r3, [pc, #312]	; (401bb4 <_usb_d_dev_ep_stall+0x150>)
  401a7c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  401a80:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
  401a84:	f003 020f 	and.w	r2, r3, #15
  401a88:	4b4b      	ldr	r3, [pc, #300]	; (401bb8 <_usb_d_dev_ep_stall+0x154>)
  401a8a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
	return (((Usbhs *)hw)->USBHS_DEVEPTISR[index] & USBHS_DEVEPTISR_STALLEDI) >> USBHS_DEVEPTISR_STALLEDI_Pos;
  401a8e:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
	return (((Usbhs *)hw)->USBHS_DEVEPTIMR[index] & USBHS_DEVEPTIMR_STALLEDE) > 0;
  401a92:	f8d3 01c0 	ldr.w	r0, [r3, #448]	; 0x1c0
  401a96:	f3c0 1080 	ubfx	r0, r0, #6, #1
	return _usbd_ep_is_stalled(epn);
  401a9a:	ea00 1092 	and.w	r0, r0, r2, lsr #6
  401a9e:	4770      	bx	lr
	if (!ept->flags.bits.is_stalled) {
  401aa0:	eb00 0380 	add.w	r3, r0, r0, lsl #2
  401aa4:	4a43      	ldr	r2, [pc, #268]	; (401bb4 <_usb_d_dev_ep_stall+0x150>)
  401aa6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  401aaa:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  401aae:	f013 0f08 	tst.w	r3, #8
  401ab2:	d178      	bne.n	401ba6 <_usb_d_dev_ep_stall+0x142>
{
  401ab4:	b410      	push	{r4}
	uint8_t epn = USB_EP_GET_N(ept->ep);
  401ab6:	4613      	mov	r3, r2
  401ab8:	0082      	lsls	r2, r0, #2
  401aba:	1811      	adds	r1, r2, r0
  401abc:	eb03 0181 	add.w	r1, r3, r1, lsl #2
  401ac0:	f891 1026 	ldrb.w	r1, [r1, #38]	; 0x26
  401ac4:	f001 040f 	and.w	r4, r1, #15
  401ac8:	493b      	ldr	r1, [pc, #236]	; (401bb8 <_usb_d_dev_ep_stall+0x154>)
  401aca:	eb01 0184 	add.w	r1, r1, r4, lsl #2
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  401ace:	2440      	movs	r4, #64	; 0x40
  401ad0:	f8c1 41f0 	str.w	r4, [r1, #496]	; 0x1f0
  401ad4:	f44f 2400 	mov.w	r4, #524288	; 0x80000
  401ad8:	f8c1 41f0 	str.w	r4, [r1, #496]	; 0x1f0
		ept->flags.bits.is_stalled = 1;
  401adc:	4410      	add	r0, r2
  401ade:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  401ae2:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
  401ae6:	f043 0308 	orr.w	r3, r3, #8
  401aea:	f880 3027 	strb.w	r3, [r0, #39]	; 0x27
		rc = _usb_d_dev_ep_stall_set(ept);
  401aee:	2000      	movs	r0, #0
}
  401af0:	f85d 4b04 	ldr.w	r4, [sp], #4
  401af4:	4770      	bx	lr
	uint8_t epn        = USB_EP_GET_N(ept->ep);
  401af6:	eb00 0380 	add.w	r3, r0, r0, lsl #2
  401afa:	4a2e      	ldr	r2, [pc, #184]	; (401bb4 <_usb_d_dev_ep_stall+0x150>)
  401afc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  401b00:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
  401b04:	f003 030f 	and.w	r3, r3, #15
  401b08:	4a2b      	ldr	r2, [pc, #172]	; (401bb8 <_usb_d_dev_ep_stall+0x154>)
  401b0a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	return (((Usbhs *)hw)->USBHS_DEVEPTISR[index] & USBHS_DEVEPTISR_STALLEDI) >> USBHS_DEVEPTISR_STALLEDI_Pos;
  401b0e:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
	return (((Usbhs *)hw)->USBHS_DEVEPTIMR[index] & USBHS_DEVEPTIMR_STALLEDE) > 0;
  401b12:	f8d3 11c0 	ldr.w	r1, [r3, #448]	; 0x1c0
	if (!is_stalled) {
  401b16:	f012 0f40 	tst.w	r2, #64	; 0x40
  401b1a:	d046      	beq.n	401baa <_usb_d_dev_ep_stall+0x146>
  401b1c:	f011 0f40 	tst.w	r1, #64	; 0x40
  401b20:	d043      	beq.n	401baa <_usb_d_dev_ep_stall+0x146>
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  401b22:	2240      	movs	r2, #64	; 0x40
  401b24:	f8c3 2220 	str.w	r2, [r3, #544]	; 0x220
  401b28:	f8c3 2220 	str.w	r2, [r3, #544]	; 0x220
	return (((Usbhs *)hw)->USBHS_DEVEPTISR[index] & USBHS_DEVEPTISR_STALLEDI) >> USBHS_DEVEPTISR_STALLEDI_Pos;
  401b2c:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
	if (_usbd_ep_is_stall_sent(epn)) {
  401b30:	f012 0f40 	tst.w	r2, #64	; 0x40
  401b34:	d00b      	beq.n	401b4e <_usb_d_dev_ep_stall+0xea>
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  401b36:	2240      	movs	r2, #64	; 0x40
  401b38:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
	return ((Usbhs *)hw)->USBHS_DEVEPTISR[index];
  401b3c:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
	data &= ~USBHS_DEVEPTISR_DTSEQ_Msk;
  401b40:	f422 7240 	bic.w	r2, r2, #768	; 0x300
	((Usbhs *)hw)->USBHS_DEVEPTIFR[index] = data;
  401b44:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190
	hri_usbhs_write_DEVEPTICR_reg(hw, epn, ~data);
  401b48:	43d2      	mvns	r2, r2
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  401b4a:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
	if (_usb_d_dev_ep_is_ctrl(ept)) {
  401b4e:	eb00 0280 	add.w	r2, r0, r0, lsl #2
  401b52:	4918      	ldr	r1, [pc, #96]	; (401bb4 <_usb_d_dev_ep_stall+0x150>)
  401b54:	eb01 0282 	add.w	r2, r1, r2, lsl #2
  401b58:	f892 2027 	ldrb.w	r2, [r2, #39]	; 0x27
  401b5c:	f002 0207 	and.w	r2, r2, #7
  401b60:	2a01      	cmp	r2, #1
  401b62:	d00c      	beq.n	401b7e <_usb_d_dev_ep_stall+0x11a>
		ept->flags.bits.is_stalled = 0;
  401b64:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  401b68:	4b12      	ldr	r3, [pc, #72]	; (401bb4 <_usb_d_dev_ep_stall+0x150>)
  401b6a:	eb03 0380 	add.w	r3, r3, r0, lsl #2
  401b6e:	f893 2027 	ldrb.w	r2, [r3, #39]	; 0x27
  401b72:	f36f 02c3 	bfc	r2, #3, #1
  401b76:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
		rc = _usb_d_dev_ep_stall_clr(ept);
  401b7a:	2000      	movs	r0, #0
  401b7c:	4770      	bx	lr
	return ((Usbhs *)hw)->USBHS_DEVEPTISR[index];
  401b7e:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
		if ((hri_usbhs_read_DEVEPTISR_reg(USBHS, epn) & USBHS_DEVEPTISR_STALLEDI) == 0) {
  401b82:	f013 0f40 	tst.w	r3, #64	; 0x40
  401b86:	d112      	bne.n	401bae <_usb_d_dev_ep_stall+0x14a>
			ept->flags.bits.is_stalled = 0;
  401b88:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  401b8c:	eb01 0380 	add.w	r3, r1, r0, lsl #2
  401b90:	f893 2027 	ldrb.w	r2, [r3, #39]	; 0x27
  401b94:	f36f 02c3 	bfc	r2, #3, #1
  401b98:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
		rc = _usb_d_dev_ep_stall_clr(ept);
  401b9c:	2000      	movs	r0, #0
  401b9e:	4770      	bx	lr
		return -USB_ERR_PARAM;
  401ba0:	f06f 0011 	mvn.w	r0, #17
  401ba4:	4770      	bx	lr
		rc = _usb_d_dev_ep_stall_set(ept);
  401ba6:	2000      	movs	r0, #0
  401ba8:	4770      	bx	lr
		rc = _usb_d_dev_ep_stall_clr(ept);
  401baa:	2000      	movs	r0, #0
  401bac:	4770      	bx	lr
  401bae:	2000      	movs	r0, #0
  401bb0:	4770      	bx	lr
  401bb2:	bf00      	nop
  401bb4:	20400110 	.word	0x20400110
  401bb8:	40038000 	.word	0x40038000

00401bbc <_usb_d_dev_ep_read_req>:
}

int32_t _usb_d_dev_ep_read_req(const uint8_t ep, uint8_t *req_buf)
{
	uint8_t epn = USB_EP_GET_N(ep);
  401bbc:	f000 000f 	and.w	r0, r0, #15
  401bc0:	4b15      	ldr	r3, [pc, #84]	; (401c18 <_usb_d_dev_ep_read_req+0x5c>)
  401bc2:	eb03 0380 	add.w	r3, r3, r0, lsl #2
	tmp = ((Usbhs *)hw)->USBHS_DEVEPTISR[index];
  401bc6:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130

	uint16_t bytes = _usbd_ep_get_trans_count(epn);

	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
  401bca:	2803      	cmp	r0, #3
  401bcc:	d821      	bhi.n	401c12 <_usb_d_dev_ep_read_req+0x56>
{
  401bce:	b430      	push	{r4, r5}
  401bd0:	460c      	mov	r4, r1
	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
  401bd2:	b1c1      	cbz	r1, 401c06 <_usb_d_dev_ep_read_req+0x4a>
	tmp = ((Usbhs *)hw)->USBHS_DEVEPTCFG[index];
  401bd4:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
		return -USB_ERR_PARAM;
	}

	if (!_usbd_ep_is_ctrl(epn)) {
  401bd8:	f411 5fc0 	tst.w	r1, #6144	; 0x1800
  401bdc:	d116      	bne.n	401c0c <_usb_d_dev_ep_read_req+0x50>
	return (((Usbhs *)hw)->USBHS_DEVEPTISR[index] & USBHS_DEVEPTISR_RXSTPI) >> USBHS_DEVEPTISR_RXSTPI_Pos;
  401bde:	f8d3 1130 	ldr.w	r1, [r3, #304]	; 0x130
		return -USB_ERR_FUNC;
	}

	if (!_usbd_ep_is_setup(epn)) {
  401be2:	f011 0f04 	tst.w	r1, #4
  401be6:	d102      	bne.n	401bee <_usb_d_dev_ep_read_req+0x32>
		return ERR_NONE;
  401be8:	2000      	movs	r0, #0
	memcpy(req_buf, (void *)ptr, 8);

	_usbd_ep_ack_setup(epn);

	return bytes;
}
  401bea:	bc30      	pop	{r4, r5}
  401bec:	4770      	bx	lr
	memcpy(req_buf, (void *)ptr, 8);
  401bee:	4d0b      	ldr	r5, [pc, #44]	; (401c1c <_usb_d_dev_ep_read_req+0x60>)
  401bf0:	eb05 35c0 	add.w	r5, r5, r0, lsl #15
  401bf4:	cd03      	ldmia	r5!, {r0, r1}
  401bf6:	6020      	str	r0, [r4, #0]
  401bf8:	6061      	str	r1, [r4, #4]
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  401bfa:	2104      	movs	r1, #4
  401bfc:	f8c3 1160 	str.w	r1, [r3, #352]	; 0x160
	return (hri_usbhs_get_DEVEPTISR_reg(USBHS, epn, USBHS_DEVEPTISR_BYCT_Msk) >> USBHS_DEVEPTISR_BYCT_Pos);
  401c00:	f3c2 500a 	ubfx	r0, r2, #20, #11
	return bytes;
  401c04:	e7f1      	b.n	401bea <_usb_d_dev_ep_read_req+0x2e>
		return -USB_ERR_PARAM;
  401c06:	f06f 0011 	mvn.w	r0, #17
  401c0a:	e7ee      	b.n	401bea <_usb_d_dev_ep_read_req+0x2e>
		return -USB_ERR_FUNC;
  401c0c:	f06f 0012 	mvn.w	r0, #18
  401c10:	e7eb      	b.n	401bea <_usb_d_dev_ep_read_req+0x2e>
		return -USB_ERR_PARAM;
  401c12:	f06f 0011 	mvn.w	r0, #17
}
  401c16:	4770      	bx	lr
  401c18:	40038000 	.word	0x40038000
  401c1c:	a0100000 	.word	0xa0100000

00401c20 <_usb_d_dev_ep_trans>:

int32_t _usb_d_dev_ep_trans(const struct usb_d_transfer *trans)
{
  401c20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401c24:	b083      	sub	sp, #12
	Usbhs *               hw  = USBHS;
	uint8_t               epn = USB_EP_GET_N(trans->ep);
  401c26:	7a06      	ldrb	r6, [r0, #8]
  401c28:	f006 040f 	and.w	r4, r6, #15
	bool                  dir = USB_EP_GET_DIR(trans->ep);
	struct _usb_d_dev_ep *ept = &dev_inst.ep[epn];

	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
  401c2c:	eb04 0284 	add.w	r2, r4, r4, lsl #2
  401c30:	4b4a      	ldr	r3, [pc, #296]	; (401d5c <_usb_d_dev_ep_trans+0x13c>)
  401c32:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  401c36:	8c9d      	ldrh	r5, [r3, #36]	; 0x24
  401c38:	f240 33ff 	movw	r3, #1023	; 0x3ff
  401c3c:	429d      	cmp	r5, r3
  401c3e:	d001      	beq.n	401c44 <_usb_d_dev_ep_trans+0x24>
  401c40:	3d01      	subs	r5, #1
  401c42:	b2ad      	uxth	r5, r5
	bool     size_n_aligned = (trans->size & size_mask);
	bool     is_ctrl        = _usb_d_dev_ep_is_ctrl(ept);
  401c44:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  401c48:	4a44      	ldr	r2, [pc, #272]	; (401d5c <_usb_d_dev_ep_trans+0x13c>)
  401c4a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  401c4e:	f893 8027 	ldrb.w	r8, [r3, #39]	; 0x27

	volatile hal_atomic_t flags;

	if (epn > CONF_USB_D_MAX_EP_N) {
  401c52:	2c03      	cmp	r4, #3
  401c54:	d87e      	bhi.n	401d54 <_usb_d_dev_ep_trans+0x134>
		return -USB_ERR_PARAM;
	}

	/* Check halt */
	if (ept->flags.bits.is_stalled) {
  401c56:	f018 0f08 	tst.w	r8, #8
  401c5a:	d003      	beq.n	401c64 <_usb_d_dev_ep_trans+0x44>
		return USB_HALTED;
  401c5c:	2002      	movs	r0, #2
#if (CONF_USB_D_DMA_ENABLE == 1)
	}
#endif

	return ERR_NONE;
}
  401c5e:	b003      	add	sp, #12
  401c60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  401c64:	4607      	mov	r7, r0
	bool     size_n_aligned = (trans->size & size_mask);
  401c66:	f8d0 a004 	ldr.w	sl, [r0, #4]
	atomic_enter_critical(&flags);
  401c6a:	a801      	add	r0, sp, #4
  401c6c:	4b3c      	ldr	r3, [pc, #240]	; (401d60 <_usb_d_dev_ep_trans+0x140>)
  401c6e:	4798      	blx	r3
	if (_usb_d_dev_ep_is_busy(ept)) {
  401c70:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  401c74:	4a39      	ldr	r2, [pc, #228]	; (401d5c <_usb_d_dev_ep_trans+0x13c>)
  401c76:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  401c7a:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  401c7e:	f013 0f40 	tst.w	r3, #64	; 0x40
  401c82:	d14f      	bne.n	401d24 <_usb_d_dev_ep_trans+0x104>
  401c84:	b276      	sxtb	r6, r6
	ept->flags.bits.is_busy = 1;
  401c86:	eb04 0984 	add.w	r9, r4, r4, lsl #2
  401c8a:	4b34      	ldr	r3, [pc, #208]	; (401d5c <_usb_d_dev_ep_trans+0x13c>)
  401c8c:	eb03 0989 	add.w	r9, r3, r9, lsl #2
  401c90:	f899 3027 	ldrb.w	r3, [r9, #39]	; 0x27
  401c94:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  401c98:	f889 3027 	strb.w	r3, [r9, #39]	; 0x27
	atomic_leave_critical(&flags);
  401c9c:	a801      	add	r0, sp, #4
  401c9e:	4b31      	ldr	r3, [pc, #196]	; (401d64 <_usb_d_dev_ep_trans+0x144>)
  401ca0:	4798      	blx	r3
	ept->trans_buf   = trans->buf;
  401ca2:	683b      	ldr	r3, [r7, #0]
  401ca4:	f8c9 3014 	str.w	r3, [r9, #20]
	ept->trans_size  = trans->size;
  401ca8:	687b      	ldr	r3, [r7, #4]
  401caa:	f8c9 3018 	str.w	r3, [r9, #24]
	ept->trans_count = 0;
  401cae:	2300      	movs	r3, #0
  401cb0:	f8c9 301c 	str.w	r3, [r9, #28]
	ept->trans_load  = 0;
  401cb4:	f8c9 3020 	str.w	r3, [r9, #32]
	bool                  dir = USB_EP_GET_DIR(trans->ep);
  401cb8:	0ff2      	lsrs	r2, r6, #31
	ept->flags.bits.dir      = dir;
  401cba:	f899 3027 	ldrb.w	r3, [r9, #39]	; 0x27
  401cbe:	f362 13c7 	bfi	r3, r2, #7, #1
  401cc2:	f889 3027 	strb.w	r3, [r9, #39]	; 0x27
	ept->flags.bits.need_zlp = (trans->zlp && (!size_n_aligned));
  401cc6:	ea15 0f0a 	tst.w	r5, sl
  401cca:	bf0c      	ite	eq
  401ccc:	2301      	moveq	r3, #1
  401cce:	2300      	movne	r3, #0
  401cd0:	7a7a      	ldrb	r2, [r7, #9]
  401cd2:	2a00      	cmp	r2, #0
  401cd4:	bf0c      	ite	eq
  401cd6:	2300      	moveq	r3, #0
  401cd8:	f003 0301 	andne.w	r3, r3, #1
  401cdc:	f899 2027 	ldrb.w	r2, [r9, #39]	; 0x27
  401ce0:	f363 1204 	bfi	r2, r3, #4, #1
  401ce4:	f889 2027 	strb.w	r2, [r9, #39]	; 0x27
	if (_usb_d_dev_ep_is_dma(epn)) {
  401ce8:	1e63      	subs	r3, r4, #1
  401cea:	b2db      	uxtb	r3, r3
  401cec:	2b06      	cmp	r3, #6
  401cee:	d91e      	bls.n	401d2e <_usb_d_dev_ep_trans+0x10e>
		if (!is_ctrl) {
  401cf0:	f008 0307 	and.w	r3, r8, #7
  401cf4:	2b01      	cmp	r3, #1
  401cf6:	d004      	beq.n	401d02 <_usb_d_dev_ep_trans+0xe2>
			hri_usbhs_set_DEVIMR_reg(hw, (USBHS_DEVIER_PEP_0 << epn));
  401cf8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  401cfc:	40a3      	lsls	r3, r4
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  401cfe:	4a1a      	ldr	r2, [pc, #104]	; (401d68 <_usb_d_dev_ep_trans+0x148>)
  401d00:	6193      	str	r3, [r2, #24]
  401d02:	4b19      	ldr	r3, [pc, #100]	; (401d68 <_usb_d_dev_ep_trans+0x148>)
  401d04:	eb03 0484 	add.w	r4, r3, r4, lsl #2
	((Usbhs *)hw)->USBHS_DEVEPTCFG[index] &= ~USBHS_DEVEPTCFG_AUTOSW;
  401d08:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
  401d0c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  401d10:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		if (dir) {
  401d14:	2e00      	cmp	r6, #0
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  401d16:	bfb4      	ite	lt
  401d18:	2301      	movlt	r3, #1
  401d1a:	2302      	movge	r3, #2
  401d1c:	f8c4 31f0 	str.w	r3, [r4, #496]	; 0x1f0
	return ERR_NONE;
  401d20:	2000      	movs	r0, #0
  401d22:	e79c      	b.n	401c5e <_usb_d_dev_ep_trans+0x3e>
		atomic_leave_critical(&flags);
  401d24:	a801      	add	r0, sp, #4
  401d26:	4b0f      	ldr	r3, [pc, #60]	; (401d64 <_usb_d_dev_ep_trans+0x144>)
  401d28:	4798      	blx	r3
		return USB_BUSY;
  401d2a:	2001      	movs	r0, #1
  401d2c:	e797      	b.n	401c5e <_usb_d_dev_ep_trans+0x3e>
  401d2e:	4b0e      	ldr	r3, [pc, #56]	; (401d68 <_usb_d_dev_ep_trans+0x148>)
  401d30:	eb03 0384 	add.w	r3, r3, r4, lsl #2
	((Usbhs *)hw)->USBHS_DEVEPTCFG[index] |= USBHS_DEVEPTCFG_AUTOSW;
  401d34:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
  401d38:	f442 7200 	orr.w	r2, r2, #512	; 0x200
  401d3c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	struct _usb_d_dev_ep *ept = &dev_inst.ep[epn];
  401d40:	3401      	adds	r4, #1
  401d42:	eb04 0484 	add.w	r4, r4, r4, lsl #2
		_usb_d_dev_dma_next(ept);
  401d46:	4805      	ldr	r0, [pc, #20]	; (401d5c <_usb_d_dev_ep_trans+0x13c>)
  401d48:	eb00 0084 	add.w	r0, r0, r4, lsl #2
  401d4c:	4b07      	ldr	r3, [pc, #28]	; (401d6c <_usb_d_dev_ep_trans+0x14c>)
  401d4e:	4798      	blx	r3
	return ERR_NONE;
  401d50:	2000      	movs	r0, #0
  401d52:	e784      	b.n	401c5e <_usb_d_dev_ep_trans+0x3e>
		return -USB_ERR_PARAM;
  401d54:	f06f 0011 	mvn.w	r0, #17
  401d58:	e781      	b.n	401c5e <_usb_d_dev_ep_trans+0x3e>
  401d5a:	bf00      	nop
  401d5c:	20400110 	.word	0x20400110
  401d60:	004003ad 	.word	0x004003ad
  401d64:	004003bb 	.word	0x004003bb
  401d68:	40038000 	.word	0x40038000
  401d6c:	004010f1 	.word	0x004010f1

00401d70 <_usb_d_dev_register_callback>:
	return USB_OK;
}

void _usb_d_dev_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
  401d70:	4b06      	ldr	r3, [pc, #24]	; (401d8c <_usb_d_dev_register_callback+0x1c>)
  401d72:	2900      	cmp	r1, #0
  401d74:	bf08      	it	eq
  401d76:	4619      	moveq	r1, r3

	if (type == USB_D_CB_EVENT) {
  401d78:	2801      	cmp	r0, #1
  401d7a:	d003      	beq.n	401d84 <_usb_d_dev_register_callback+0x14>
		dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)f;
	} else if (type == USB_D_CB_SOF) {
  401d7c:	b908      	cbnz	r0, 401d82 <_usb_d_dev_register_callback+0x12>
		dev_inst.callbacks.sof = (_usb_d_dev_sof_cb_t)f;
  401d7e:	4b04      	ldr	r3, [pc, #16]	; (401d90 <_usb_d_dev_register_callback+0x20>)
  401d80:	6019      	str	r1, [r3, #0]
  401d82:	4770      	bx	lr
		dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)f;
  401d84:	4b02      	ldr	r3, [pc, #8]	; (401d90 <_usb_d_dev_register_callback+0x20>)
  401d86:	6059      	str	r1, [r3, #4]
  401d88:	4770      	bx	lr
  401d8a:	bf00      	nop
  401d8c:	00400ffd 	.word	0x00400ffd
  401d90:	20400110 	.word	0x20400110

00401d94 <_usb_d_dev_register_ep_callback>:
	}
}

void _usb_d_dev_register_ep_callback(const enum usb_d_dev_ep_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
  401d94:	4b09      	ldr	r3, [pc, #36]	; (401dbc <_usb_d_dev_register_ep_callback+0x28>)
  401d96:	2900      	cmp	r1, #0
  401d98:	bf08      	it	eq
  401d9a:	4619      	moveq	r1, r3

	if (type == USB_D_DEV_EP_CB_SETUP) {
  401d9c:	b120      	cbz	r0, 401da8 <_usb_d_dev_register_ep_callback+0x14>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
	} else if (type == USB_D_DEV_EP_CB_MORE) {
  401d9e:	2801      	cmp	r0, #1
  401da0:	d005      	beq.n	401dae <_usb_d_dev_register_ep_callback+0x1a>
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
	} else if (type == USB_D_DEV_EP_CB_DONE) {
  401da2:	2802      	cmp	r0, #2
  401da4:	d006      	beq.n	401db4 <_usb_d_dev_register_ep_callback+0x20>
  401da6:	4770      	bx	lr
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
  401da8:	4b05      	ldr	r3, [pc, #20]	; (401dc0 <_usb_d_dev_register_ep_callback+0x2c>)
  401daa:	6099      	str	r1, [r3, #8]
  401dac:	4770      	bx	lr
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
  401dae:	4b04      	ldr	r3, [pc, #16]	; (401dc0 <_usb_d_dev_register_ep_callback+0x2c>)
  401db0:	60d9      	str	r1, [r3, #12]
  401db2:	4770      	bx	lr
		dev_inst.ep_callbacks.done = (_usb_d_dev_ep_cb_done_t)f;
  401db4:	4b02      	ldr	r3, [pc, #8]	; (401dc0 <_usb_d_dev_register_ep_callback+0x2c>)
  401db6:	6119      	str	r1, [r3, #16]
	}
}
  401db8:	e7f5      	b.n	401da6 <_usb_d_dev_register_ep_callback+0x12>
  401dba:	bf00      	nop
  401dbc:	00400ffd 	.word	0x00400ffd
  401dc0:	20400110 	.word	0x20400110

00401dc4 <task_led>:
        while (1);
    }
}

void task_led(void *p)
{
  401dc4:	b508      	push	{r3, lr}

#include <atmel_start.h>

inline void task_delay_ms(uint16_t ms)
{
    vTaskDelay(ms / portTICK_PERIOD_MS);
  401dc6:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  401dca:	4c02      	ldr	r4, [pc, #8]	; (401dd4 <task_led+0x10>)
  401dcc:	4628      	mov	r0, r5
  401dce:	47a0      	blx	r4
  401dd0:	e7fc      	b.n	401dcc <task_led+0x8>
  401dd2:	bf00      	nop
  401dd4:	00403209 	.word	0x00403209

00401dd8 <task_console>:
        task_delay_ms(1000);
    }
}

void task_console(void *p)
{
  401dd8:	b508      	push	{r3, lr}
  401dda:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  401dde:	4c02      	ldr	r4, [pc, #8]	; (401de8 <task_console+0x10>)
  401de0:	4628      	mov	r0, r5
  401de2:	47a0      	blx	r4
  401de4:	e7fc      	b.n	401de0 <task_console+0x8>
  401de6:	bf00      	nop
  401de8:	00403209 	.word	0x00403209

00401dec <task_led_create>:
{
  401dec:	b510      	push	{r4, lr}
  401dee:	b082      	sub	sp, #8
    if (xTaskCreate(task_led, "Led", TASK_LED_STACK_SIZE, NULL, TASK_LED_STACK_PRIORITY, xCreatedLedTask) != pdPASS)
  401df0:	2300      	movs	r3, #0
  401df2:	9301      	str	r3, [sp, #4]
  401df4:	2201      	movs	r2, #1
  401df6:	9200      	str	r2, [sp, #0]
  401df8:	221b      	movs	r2, #27
  401dfa:	4904      	ldr	r1, [pc, #16]	; (401e0c <task_led_create+0x20>)
  401dfc:	4804      	ldr	r0, [pc, #16]	; (401e10 <task_led_create+0x24>)
  401dfe:	4c05      	ldr	r4, [pc, #20]	; (401e14 <task_led_create+0x28>)
  401e00:	47a0      	blx	r4
  401e02:	2801      	cmp	r0, #1
  401e04:	d000      	beq.n	401e08 <task_led_create+0x1c>
  401e06:	e7fe      	b.n	401e06 <task_led_create+0x1a>
}
  401e08:	b002      	add	sp, #8
  401e0a:	bd10      	pop	{r4, pc}
  401e0c:	00404574 	.word	0x00404574
  401e10:	00401dc5 	.word	0x00401dc5
  401e14:	00402d4d 	.word	0x00402d4d

00401e18 <task_console_create>:
{
  401e18:	b510      	push	{r4, lr}
  401e1a:	b082      	sub	sp, #8
    if (xTaskCreate(task_console, "Console", TASK_CONSOLE_STACK_SIZE, NULL, TASK_CONSOL_STACK_PRIORITY, xCreatedConsoleTask) != pdPASS)
  401e1c:	2300      	movs	r3, #0
  401e1e:	9301      	str	r3, [sp, #4]
  401e20:	9300      	str	r3, [sp, #0]
  401e22:	224b      	movs	r2, #75	; 0x4b
  401e24:	4904      	ldr	r1, [pc, #16]	; (401e38 <task_console_create+0x20>)
  401e26:	4805      	ldr	r0, [pc, #20]	; (401e3c <task_console_create+0x24>)
  401e28:	4c05      	ldr	r4, [pc, #20]	; (401e40 <task_console_create+0x28>)
  401e2a:	47a0      	blx	r4
  401e2c:	2801      	cmp	r0, #1
  401e2e:	d000      	beq.n	401e32 <task_console_create+0x1a>
  401e30:	e7fe      	b.n	401e30 <task_console_create+0x18>
}
  401e32:	b002      	add	sp, #8
  401e34:	bd10      	pop	{r4, pc}
  401e36:	bf00      	nop
  401e38:	00404578 	.word	0x00404578
  401e3c:	00401dd9 	.word	0x00401dd9
  401e40:	00402d4d 	.word	0x00402d4d

00401e44 <main>:
{
  401e44:	b508      	push	{r3, lr}
	atmel_start_init();
  401e46:	4b06      	ldr	r3, [pc, #24]	; (401e60 <main+0x1c>)
  401e48:	4798      	blx	r3
    app_init();
  401e4a:	4b06      	ldr	r3, [pc, #24]	; (401e64 <main+0x20>)
  401e4c:	4798      	blx	r3
    task_led_create();
  401e4e:	4b06      	ldr	r3, [pc, #24]	; (401e68 <main+0x24>)
  401e50:	4798      	blx	r3
    task_console_create();
  401e52:	4b06      	ldr	r3, [pc, #24]	; (401e6c <main+0x28>)
  401e54:	4798      	blx	r3
    vTaskStartScheduler();
  401e56:	4b06      	ldr	r3, [pc, #24]	; (401e70 <main+0x2c>)
  401e58:	4798      	blx	r3
}
  401e5a:	2000      	movs	r0, #0
  401e5c:	bd08      	pop	{r3, pc}
  401e5e:	bf00      	nop
  401e60:	004001b1 	.word	0x004001b1
  401e64:	004001ad 	.word	0x004001ad
  401e68:	00401ded 	.word	0x00401ded
  401e6c:	00401e19 	.word	0x00401e19
  401e70:	00402f29 	.word	0x00402f29

00401e74 <sem_init>:

/**
 * \brief Semaphore initialization
 */
int32_t sem_init(sem_t *sem, uint32_t count)
{
  401e74:	b538      	push	{r3, r4, r5, lr}
  401e76:	4605      	mov	r5, r0
  401e78:	460c      	mov	r4, r1
	ASSERT(count <= SEMAPHORE_MAX_COUNT);
  401e7a:	2235      	movs	r2, #53	; 0x35
  401e7c:	4908      	ldr	r1, [pc, #32]	; (401ea0 <sem_init+0x2c>)
  401e7e:	2c01      	cmp	r4, #1
  401e80:	bf8c      	ite	hi
  401e82:	2000      	movhi	r0, #0
  401e84:	2001      	movls	r0, #1
  401e86:	4b07      	ldr	r3, [pc, #28]	; (401ea4 <sem_init+0x30>)
  401e88:	4798      	blx	r3

	*sem = xSemaphoreCreateCounting((uint32_t)SEMAPHORE_MAX_COUNT, count);
  401e8a:	4621      	mov	r1, r4
  401e8c:	2001      	movs	r0, #1
  401e8e:	4b06      	ldr	r3, [pc, #24]	; (401ea8 <sem_init+0x34>)
  401e90:	4798      	blx	r3
  401e92:	6028      	str	r0, [r5, #0]

	return *sem ? ERR_NONE : ERR_NOT_INITIALIZED;
  401e94:	2800      	cmp	r0, #0
}
  401e96:	bf14      	ite	ne
  401e98:	2000      	movne	r0, #0
  401e9a:	f06f 0013 	mvneq.w	r0, #19
  401e9e:	bd38      	pop	{r3, r4, r5, pc}
  401ea0:	00404580 	.word	0x00404580
  401ea4:	00400c01 	.word	0x00400c01
  401ea8:	004025f1 	.word	0x004025f1

00401eac <sem_up>:

/**
 * \brief Semaphore up
 */
int32_t sem_up(sem_t *sem)
{
  401eac:	b510      	push	{r4, lr}
 * \brief Check if it's in ISR handling
 * \return \c true if it's in ISR
 */
static inline bool _is_in_isr(void)
{
	return (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk);
  401eae:	4b0d      	ldr	r3, [pc, #52]	; (401ee4 <sem_up+0x38>)
  401eb0:	685b      	ldr	r3, [r3, #4]
  401eb2:	f3c3 0308 	ubfx	r3, r3, #0, #9
	return is_in_isr() ? (xSemaphoreGiveFromISR(*sem, pdFALSE) ? 0 : ERR_ABORTED)
	                   : (xSemaphoreGive(*sem) ? ERR_NONE : ERR_ABORTED);
  401eb6:	b14b      	cbz	r3, 401ecc <sem_up+0x20>
	return is_in_isr() ? (xSemaphoreGiveFromISR(*sem, pdFALSE) ? 0 : ERR_ABORTED)
  401eb8:	2100      	movs	r1, #0
  401eba:	6800      	ldr	r0, [r0, #0]
  401ebc:	4b0a      	ldr	r3, [pc, #40]	; (401ee8 <sem_up+0x3c>)
  401ebe:	4798      	blx	r3
	                   : (xSemaphoreGive(*sem) ? ERR_NONE : ERR_ABORTED);
  401ec0:	2800      	cmp	r0, #0
  401ec2:	bf14      	ite	ne
  401ec4:	2000      	movne	r0, #0
  401ec6:	f06f 0002 	mvneq.w	r0, #2
  401eca:	bd10      	pop	{r4, pc}
  401ecc:	2300      	movs	r3, #0
  401ece:	461a      	mov	r2, r3
  401ed0:	4619      	mov	r1, r3
  401ed2:	6800      	ldr	r0, [r0, #0]
  401ed4:	4c05      	ldr	r4, [pc, #20]	; (401eec <sem_up+0x40>)
  401ed6:	47a0      	blx	r4
  401ed8:	2800      	cmp	r0, #0
  401eda:	bf14      	ite	ne
  401edc:	2000      	movne	r0, #0
  401ede:	f06f 0002 	mvneq.w	r0, #2
}
  401ee2:	bd10      	pop	{r4, pc}
  401ee4:	e000ed00 	.word	0xe000ed00
  401ee8:	00402941 	.word	0x00402941
  401eec:	0040263d 	.word	0x0040263d

00401ef0 <sem_down>:

/**
 * \brief Semaphore down, may suspend the caller thread
 */
int32_t sem_down(sem_t *sem, uint32_t timeout)
{
  401ef0:	b510      	push	{r4, lr}
	return xSemaphoreTake(*sem, timeout) ? ERR_NONE : ERR_TIMEOUT;
  401ef2:	2300      	movs	r3, #0
  401ef4:	460a      	mov	r2, r1
  401ef6:	4619      	mov	r1, r3
  401ef8:	6800      	ldr	r0, [r0, #0]
  401efa:	4c04      	ldr	r4, [pc, #16]	; (401f0c <sem_down+0x1c>)
  401efc:	47a0      	blx	r4
  401efe:	2800      	cmp	r0, #0
}
  401f00:	bf14      	ite	ne
  401f02:	2000      	movne	r0, #0
  401f04:	f06f 0007 	mvneq.w	r0, #7
  401f08:	bd10      	pop	{r4, pc}
  401f0a:	bf00      	nop
  401f0c:	00402a25 	.word	0x00402a25

00401f10 <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
  401f10:	f100 0308 	add.w	r3, r0, #8
  401f14:	6043      	str	r3, [r0, #4]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  401f16:	f04f 32ff 	mov.w	r2, #4294967295
  401f1a:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
  401f1c:	60c3      	str	r3, [r0, #12]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
  401f1e:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
  401f20:	2300      	movs	r3, #0
  401f22:	6003      	str	r3, [r0, #0]
  401f24:	4770      	bx	lr

00401f26 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  401f26:	2300      	movs	r3, #0
  401f28:	6103      	str	r3, [r0, #16]
  401f2a:	4770      	bx	lr

00401f2c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
  401f2c:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
  401f2e:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  401f30:	689a      	ldr	r2, [r3, #8]
  401f32:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
  401f34:	689a      	ldr	r2, [r3, #8]
  401f36:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
  401f38:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;
  401f3a:	6108      	str	r0, [r1, #16]

	(pxList->uxNumberOfItems)++;
  401f3c:	6803      	ldr	r3, [r0, #0]
  401f3e:	3301      	adds	r3, #1
  401f40:	6003      	str	r3, [r0, #0]
  401f42:	4770      	bx	lr

00401f44 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
  401f44:	b430      	push	{r4, r5}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
  401f46:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if (xValueOfInsertion == portMAX_DELAY) {
  401f48:	f1b5 3fff 	cmp.w	r5, #4294967295
  401f4c:	d002      	beq.n	401f54 <vListInsert+0x10>
		    4) Using a queue or semaphore before it has been initialised or
		       before the scheduler has been started (are interrupts firing
		       before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
  401f4e:	f100 0208 	add.w	r2, r0, #8
  401f52:	e002      	b.n	401f5a <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
  401f54:	6902      	ldr	r2, [r0, #16]
  401f56:	e004      	b.n	401f62 <vListInsert+0x1e>
		     pxIterator
		     = pxIterator
  401f58:	461a      	mov	r2, r3
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
  401f5a:	6853      	ldr	r3, [r2, #4]
  401f5c:	681c      	ldr	r4, [r3, #0]
  401f5e:	42a5      	cmp	r5, r4
  401f60:	d2fa      	bcs.n	401f58 <vListInsert+0x14>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
  401f62:	6853      	ldr	r3, [r2, #4]
  401f64:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  401f66:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious         = pxIterator;
  401f68:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
  401f6a:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;
  401f6c:	6108      	str	r0, [r1, #16]

	(pxList->uxNumberOfItems)++;
  401f6e:	6803      	ldr	r3, [r0, #0]
  401f70:	3301      	adds	r3, #1
  401f72:	6003      	str	r3, [r0, #0]
}
  401f74:	bc30      	pop	{r4, r5}
  401f76:	4770      	bx	lr

00401f78 <uxListRemove>:

UBaseType_t uxListRemove(ListItem_t *const pxItemToRemove)
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
  401f78:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  401f7a:	6842      	ldr	r2, [r0, #4]
  401f7c:	6881      	ldr	r1, [r0, #8]
  401f7e:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  401f80:	6882      	ldr	r2, [r0, #8]
  401f82:	6841      	ldr	r1, [r0, #4]
  401f84:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
  401f86:	685a      	ldr	r2, [r3, #4]
  401f88:	4290      	cmp	r0, r2
  401f8a:	d005      	beq.n	401f98 <uxListRemove+0x20>
		pxList->pxIndex = pxItemToRemove->pxPrevious;
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
  401f8c:	2200      	movs	r2, #0
  401f8e:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
  401f90:	6818      	ldr	r0, [r3, #0]
  401f92:	3801      	subs	r0, #1
  401f94:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
  401f96:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  401f98:	6882      	ldr	r2, [r0, #8]
  401f9a:	605a      	str	r2, [r3, #4]
  401f9c:	e7f6      	b.n	401f8c <uxListRemove+0x14>
	...

00401fa0 <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT(uxCriticalNesting == ~0UL);
  401fa0:	4b0d      	ldr	r3, [pc, #52]	; (401fd8 <prvTaskExitError+0x38>)
  401fa2:	681b      	ldr	r3, [r3, #0]
  401fa4:	f1b3 3fff 	cmp.w	r3, #4294967295
  401fa8:	d00a      	beq.n	401fc0 <prvTaskExitError+0x20>

portFORCE_INLINE static void vPortRaiseBASEPRI(void)
{
	uint32_t ulNewBASEPRI;

	__asm volatile("	mov %0, %1												\n"
  401faa:	f44f 7380 	mov.w	r3, #256	; 0x100
  401fae:	b672      	cpsid	i
  401fb0:	f383 8811 	msr	BASEPRI, r3
  401fb4:	f3bf 8f6f 	isb	sy
  401fb8:	f3bf 8f4f 	dsb	sy
  401fbc:	b662      	cpsie	i
  401fbe:	e7fe      	b.n	401fbe <prvTaskExitError+0x1e>
  401fc0:	f44f 7380 	mov.w	r3, #256	; 0x100
  401fc4:	b672      	cpsid	i
  401fc6:	f383 8811 	msr	BASEPRI, r3
  401fca:	f3bf 8f6f 	isb	sy
  401fce:	f3bf 8f4f 	dsb	sy
  401fd2:	b662      	cpsie	i
  401fd4:	e7fe      	b.n	401fd4 <prvTaskExitError+0x34>
  401fd6:	bf00      	nop
  401fd8:	20400000 	.word	0x20400000

00401fdc <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask(void)
{
	__asm volatile(" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
  401fdc:	4806      	ldr	r0, [pc, #24]	; (401ff8 <prvPortStartFirstTask+0x1c>)
  401fde:	6800      	ldr	r0, [r0, #0]
  401fe0:	6800      	ldr	r0, [r0, #0]
  401fe2:	f380 8808 	msr	MSP, r0
  401fe6:	b662      	cpsie	i
  401fe8:	b661      	cpsie	f
  401fea:	f3bf 8f4f 	dsb	sy
  401fee:	f3bf 8f6f 	isb	sy
  401ff2:	df00      	svc	0
  401ff4:	bf00      	nop
  401ff6:	0000      	.short	0x0000
  401ff8:	e000ed08 	.word	0xe000ed08

00401ffc <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP(void)
{
	__asm volatile("	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
  401ffc:	f8df 000c 	ldr.w	r0, [pc, #12]	; 40200c <vPortEnableVFP+0x10>
  402000:	6801      	ldr	r1, [r0, #0]
  402002:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  402006:	6001      	str	r1, [r0, #0]
  402008:	4770      	bx	lr
  40200a:	0000      	.short	0x0000
  40200c:	e000ed88 	.word	0xe000ed88

00402010 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
  402010:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
  402014:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = (StackType_t)pxCode; /* PC */
  402018:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
  40201c:	4b05      	ldr	r3, [pc, #20]	; (402034 <pxPortInitialiseStack+0x24>)
  40201e:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = (StackType_t)pvParameters; /* R0 */
  402022:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
  402026:	f06f 0302 	mvn.w	r3, #2
  40202a:	f840 3c24 	str.w	r3, [r0, #-36]
}
  40202e:	3844      	subs	r0, #68	; 0x44
  402030:	4770      	bx	lr
  402032:	bf00      	nop
  402034:	00401fa1 	.word	0x00401fa1
	...

00402040 <SVC_Handler>:
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
  402040:	4b07      	ldr	r3, [pc, #28]	; (402060 <pxCurrentTCBConst2>)
  402042:	6819      	ldr	r1, [r3, #0]
  402044:	6808      	ldr	r0, [r1, #0]
  402046:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40204a:	f380 8809 	msr	PSP, r0
  40204e:	f3bf 8f6f 	isb	sy
  402052:	f04f 0000 	mov.w	r0, #0
  402056:	f380 8811 	msr	BASEPRI, r0
  40205a:	4770      	bx	lr
  40205c:	f3af 8000 	nop.w

00402060 <pxCurrentTCBConst2>:
  402060:	20400b7c 	.word	0x20400b7c

00402064 <vPortEnterCritical>:
  402064:	f44f 7380 	mov.w	r3, #256	; 0x100
  402068:	b672      	cpsid	i
  40206a:	f383 8811 	msr	BASEPRI, r3
  40206e:	f3bf 8f6f 	isb	sy
  402072:	f3bf 8f4f 	dsb	sy
  402076:	b662      	cpsie	i
	uxCriticalNesting++;
  402078:	4a0b      	ldr	r2, [pc, #44]	; (4020a8 <vPortEnterCritical+0x44>)
  40207a:	6813      	ldr	r3, [r2, #0]
  40207c:	3301      	adds	r3, #1
  40207e:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 1) {
  402080:	2b01      	cmp	r3, #1
  402082:	d10f      	bne.n	4020a4 <vPortEnterCritical+0x40>
		configASSERT((portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK) == 0);
  402084:	4b09      	ldr	r3, [pc, #36]	; (4020ac <vPortEnterCritical+0x48>)
  402086:	681b      	ldr	r3, [r3, #0]
  402088:	f013 0fff 	tst.w	r3, #255	; 0xff
  40208c:	d00a      	beq.n	4020a4 <vPortEnterCritical+0x40>
  40208e:	f44f 7380 	mov.w	r3, #256	; 0x100
  402092:	b672      	cpsid	i
  402094:	f383 8811 	msr	BASEPRI, r3
  402098:	f3bf 8f6f 	isb	sy
  40209c:	f3bf 8f4f 	dsb	sy
  4020a0:	b662      	cpsie	i
  4020a2:	e7fe      	b.n	4020a2 <vPortEnterCritical+0x3e>
  4020a4:	4770      	bx	lr
  4020a6:	bf00      	nop
  4020a8:	20400000 	.word	0x20400000
  4020ac:	e000ed04 	.word	0xe000ed04

004020b0 <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
  4020b0:	4b0a      	ldr	r3, [pc, #40]	; (4020dc <vPortExitCritical+0x2c>)
  4020b2:	681b      	ldr	r3, [r3, #0]
  4020b4:	b953      	cbnz	r3, 4020cc <vPortExitCritical+0x1c>
  4020b6:	f44f 7380 	mov.w	r3, #256	; 0x100
  4020ba:	b672      	cpsid	i
  4020bc:	f383 8811 	msr	BASEPRI, r3
  4020c0:	f3bf 8f6f 	isb	sy
  4020c4:	f3bf 8f4f 	dsb	sy
  4020c8:	b662      	cpsie	i
  4020ca:	e7fe      	b.n	4020ca <vPortExitCritical+0x1a>
	uxCriticalNesting--;
  4020cc:	3b01      	subs	r3, #1
  4020ce:	4a03      	ldr	r2, [pc, #12]	; (4020dc <vPortExitCritical+0x2c>)
  4020d0:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
  4020d2:	b90b      	cbnz	r3, 4020d8 <vPortExitCritical+0x28>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
  4020d4:	f383 8811 	msr	BASEPRI, r3
  4020d8:	4770      	bx	lr
  4020da:	bf00      	nop
  4020dc:	20400000 	.word	0x20400000

004020e0 <PendSV_Handler>:
	__asm volatile(
  4020e0:	f3ef 8009 	mrs	r0, PSP
  4020e4:	f3bf 8f6f 	isb	sy
  4020e8:	4b15      	ldr	r3, [pc, #84]	; (402140 <pxCurrentTCBConst>)
  4020ea:	681a      	ldr	r2, [r3, #0]
  4020ec:	f01e 0f10 	tst.w	lr, #16
  4020f0:	bf08      	it	eq
  4020f2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
  4020f6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4020fa:	6010      	str	r0, [r2, #0]
  4020fc:	f84d 3d04 	str.w	r3, [sp, #-4]!
  402100:	f44f 7080 	mov.w	r0, #256	; 0x100
  402104:	b672      	cpsid	i
  402106:	f380 8811 	msr	BASEPRI, r0
  40210a:	f3bf 8f4f 	dsb	sy
  40210e:	f3bf 8f6f 	isb	sy
  402112:	b662      	cpsie	i
  402114:	f001 f8a6 	bl	403264 <vTaskSwitchContext>
  402118:	f04f 0000 	mov.w	r0, #0
  40211c:	f380 8811 	msr	BASEPRI, r0
  402120:	bc08      	pop	{r3}
  402122:	6819      	ldr	r1, [r3, #0]
  402124:	6808      	ldr	r0, [r1, #0]
  402126:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40212a:	f01e 0f10 	tst.w	lr, #16
  40212e:	bf08      	it	eq
  402130:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
  402134:	f380 8809 	msr	PSP, r0
  402138:	f3bf 8f6f 	isb	sy
  40213c:	4770      	bx	lr
  40213e:	bf00      	nop

00402140 <pxCurrentTCBConst>:
  402140:	20400b7c 	.word	0x20400b7c

00402144 <SysTick_Handler>:
{
  402144:	b508      	push	{r3, lr}
	__asm volatile("	mov %0, %1												\n"
  402146:	f44f 7380 	mov.w	r3, #256	; 0x100
  40214a:	b672      	cpsid	i
  40214c:	f383 8811 	msr	BASEPRI, r3
  402150:	f3bf 8f6f 	isb	sy
  402154:	f3bf 8f4f 	dsb	sy
  402158:	b662      	cpsie	i
		if (xTaskIncrementTick() != pdFALSE) {
  40215a:	4b05      	ldr	r3, [pc, #20]	; (402170 <SysTick_Handler+0x2c>)
  40215c:	4798      	blx	r3
  40215e:	b118      	cbz	r0, 402168 <SysTick_Handler+0x24>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  402160:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402164:	4b03      	ldr	r3, [pc, #12]	; (402174 <SysTick_Handler+0x30>)
  402166:	601a      	str	r2, [r3, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
  402168:	2300      	movs	r3, #0
  40216a:	f383 8811 	msr	BASEPRI, r3
  40216e:	bd08      	pop	{r3, pc}
  402170:	00402fd1 	.word	0x00402fd1
  402174:	e000ed04 	.word	0xe000ed04

00402178 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_LOAD_REG = (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
  402178:	4a03      	ldr	r2, [pc, #12]	; (402188 <vPortSetupTimerInterrupt+0x10>)
  40217a:	4b04      	ldr	r3, [pc, #16]	; (40218c <vPortSetupTimerInterrupt+0x14>)
  40217c:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = (portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT);
  40217e:	2207      	movs	r2, #7
  402180:	3b04      	subs	r3, #4
  402182:	601a      	str	r2, [r3, #0]
  402184:	4770      	bx	lr
  402186:	bf00      	nop
  402188:	000493df 	.word	0x000493df
  40218c:	e000e014 	.word	0xe000e014

00402190 <xPortStartScheduler>:
{
  402190:	b500      	push	{lr}
  402192:	b083      	sub	sp, #12
		ulOriginalPriority = *pucFirstUserPriorityRegister;
  402194:	4b24      	ldr	r3, [pc, #144]	; (402228 <xPortStartScheduler+0x98>)
  402196:	781a      	ldrb	r2, [r3, #0]
  402198:	b2d2      	uxtb	r2, r2
  40219a:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
  40219c:	22ff      	movs	r2, #255	; 0xff
  40219e:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
  4021a0:	781b      	ldrb	r3, [r3, #0]
  4021a2:	b2db      	uxtb	r3, r3
  4021a4:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
  4021a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
  4021ac:	4b1f      	ldr	r3, [pc, #124]	; (40222c <xPortStartScheduler+0x9c>)
  4021ae:	2200      	movs	r2, #0
  4021b0:	701a      	strb	r2, [r3, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
  4021b2:	2207      	movs	r2, #7
  4021b4:	605a      	str	r2, [r3, #4]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
  4021b6:	f89d 3003 	ldrb.w	r3, [sp, #3]
  4021ba:	f013 0f80 	tst.w	r3, #128	; 0x80
  4021be:	d010      	beq.n	4021e2 <xPortStartScheduler+0x52>
  4021c0:	2206      	movs	r2, #6
  4021c2:	e000      	b.n	4021c6 <xPortStartScheduler+0x36>
  4021c4:	460a      	mov	r2, r1
			ucMaxPriorityValue <<= (uint8_t)0x01;
  4021c6:	f89d 3003 	ldrb.w	r3, [sp, #3]
  4021ca:	005b      	lsls	r3, r3, #1
  4021cc:	b2db      	uxtb	r3, r3
  4021ce:	f88d 3003 	strb.w	r3, [sp, #3]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
  4021d2:	f89d 3003 	ldrb.w	r3, [sp, #3]
  4021d6:	1e51      	subs	r1, r2, #1
  4021d8:	f013 0f80 	tst.w	r3, #128	; 0x80
  4021dc:	d1f2      	bne.n	4021c4 <xPortStartScheduler+0x34>
  4021de:	4b13      	ldr	r3, [pc, #76]	; (40222c <xPortStartScheduler+0x9c>)
  4021e0:	605a      	str	r2, [r3, #4]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
  4021e2:	4a12      	ldr	r2, [pc, #72]	; (40222c <xPortStartScheduler+0x9c>)
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
  4021e4:	6853      	ldr	r3, [r2, #4]
  4021e6:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
  4021e8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  4021ec:	6053      	str	r3, [r2, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
  4021ee:	9b01      	ldr	r3, [sp, #4]
  4021f0:	b2db      	uxtb	r3, r3
  4021f2:	4a0d      	ldr	r2, [pc, #52]	; (402228 <xPortStartScheduler+0x98>)
  4021f4:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
  4021f6:	4b0e      	ldr	r3, [pc, #56]	; (402230 <xPortStartScheduler+0xa0>)
  4021f8:	681a      	ldr	r2, [r3, #0]
  4021fa:	f042 72e0 	orr.w	r2, r2, #29360128	; 0x1c00000
  4021fe:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
  402200:	681a      	ldr	r2, [r3, #0]
  402202:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
  402206:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
  402208:	4b0a      	ldr	r3, [pc, #40]	; (402234 <xPortStartScheduler+0xa4>)
  40220a:	4798      	blx	r3
	uxCriticalNesting = 0;
  40220c:	2200      	movs	r2, #0
  40220e:	4b0a      	ldr	r3, [pc, #40]	; (402238 <xPortStartScheduler+0xa8>)
  402210:	601a      	str	r2, [r3, #0]
	vPortEnableVFP();
  402212:	4b0a      	ldr	r3, [pc, #40]	; (40223c <xPortStartScheduler+0xac>)
  402214:	4798      	blx	r3
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
  402216:	4a0a      	ldr	r2, [pc, #40]	; (402240 <xPortStartScheduler+0xb0>)
  402218:	6813      	ldr	r3, [r2, #0]
  40221a:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
  40221e:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
  402220:	4b08      	ldr	r3, [pc, #32]	; (402244 <xPortStartScheduler+0xb4>)
  402222:	4798      	blx	r3
	prvTaskExitError();
  402224:	4b08      	ldr	r3, [pc, #32]	; (402248 <xPortStartScheduler+0xb8>)
  402226:	4798      	blx	r3
  402228:	e000e400 	.word	0xe000e400
  40222c:	20400174 	.word	0x20400174
  402230:	e000ed20 	.word	0xe000ed20
  402234:	00402179 	.word	0x00402179
  402238:	20400000 	.word	0x20400000
  40223c:	00401ffd 	.word	0x00401ffd
  402240:	e000ef34 	.word	0xe000ef34
  402244:	00401fdd 	.word	0x00401fdd
  402248:	00401fa1 	.word	0x00401fa1

0040224c <vPortValidateInterruptPriority>:
{
	uint32_t ulCurrentInterrupt;
	uint8_t  ucCurrentPriority;

	/* Obtain the number of the currently executing interrupt. */
	__asm volatile("mrs %0, ipsr" : "=r"(ulCurrentInterrupt));
  40224c:	f3ef 8305 	mrs	r3, IPSR

	/* Is the interrupt number a user defined interrupt? */
	if (ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER) {
  402250:	2b0f      	cmp	r3, #15
  402252:	d911      	bls.n	402278 <vPortValidateInterruptPriority+0x2c>
		/* Look up the interrupt's priority. */
		ucCurrentPriority = pcInterruptPriorityRegisters[ulCurrentInterrupt];
  402254:	4a12      	ldr	r2, [pc, #72]	; (4022a0 <vPortValidateInterruptPriority+0x54>)
  402256:	5c9b      	ldrb	r3, [r3, r2]
  402258:	b2db      	uxtb	r3, r3
		interrupt entry is as fast and simple as possible.

		The following links provide detailed information:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html
		http://www.freertos.org/FAQHelp.html */
		configASSERT(ucCurrentPriority >= ucMaxSysCallPriority);
  40225a:	4a12      	ldr	r2, [pc, #72]	; (4022a4 <vPortValidateInterruptPriority+0x58>)
  40225c:	7812      	ldrb	r2, [r2, #0]
  40225e:	429a      	cmp	r2, r3
  402260:	d90a      	bls.n	402278 <vPortValidateInterruptPriority+0x2c>
	__asm volatile("	mov %0, %1												\n"
  402262:	f44f 7380 	mov.w	r3, #256	; 0x100
  402266:	b672      	cpsid	i
  402268:	f383 8811 	msr	BASEPRI, r3
  40226c:	f3bf 8f6f 	isb	sy
  402270:	f3bf 8f4f 	dsb	sy
  402274:	b662      	cpsie	i
  402276:	e7fe      	b.n	402276 <vPortValidateInterruptPriority+0x2a>
	configuration then the correct setting can be achieved on all Cortex-M
	devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
	scheduler.  Note however that some vendor specific peripheral libraries
	assume a non-zero priority group setting, in which cases using a value
	of zero will result in unpredicable behaviour. */
	configASSERT((portAIRCR_REG & portPRIORITY_GROUP_MASK) <= ulMaxPRIGROUPValue);
  402278:	4b0b      	ldr	r3, [pc, #44]	; (4022a8 <vPortValidateInterruptPriority+0x5c>)
  40227a:	681b      	ldr	r3, [r3, #0]
  40227c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  402280:	4a08      	ldr	r2, [pc, #32]	; (4022a4 <vPortValidateInterruptPriority+0x58>)
  402282:	6852      	ldr	r2, [r2, #4]
  402284:	4293      	cmp	r3, r2
  402286:	d90a      	bls.n	40229e <vPortValidateInterruptPriority+0x52>
  402288:	f44f 7380 	mov.w	r3, #256	; 0x100
  40228c:	b672      	cpsid	i
  40228e:	f383 8811 	msr	BASEPRI, r3
  402292:	f3bf 8f6f 	isb	sy
  402296:	f3bf 8f4f 	dsb	sy
  40229a:	b662      	cpsie	i
  40229c:	e7fe      	b.n	40229c <vPortValidateInterruptPriority+0x50>
  40229e:	4770      	bx	lr
  4022a0:	e000e3f0 	.word	0xe000e3f0
  4022a4:	20400174 	.word	0x20400174
  4022a8:	e000ed0c 	.word	0xe000ed0c

004022ac <pvPortMalloc>:
static size_t xNextFreeByte = (size_t)0;

/*-----------------------------------------------------------*/

void *pvPortMalloc(size_t xWantedSize)
{
  4022ac:	b538      	push	{r3, r4, r5, lr}
  4022ae:	4604      	mov	r4, r0
	static uint8_t *pucAlignedHeap = NULL;

/* Ensure that blocks are always aligned to the required number of bytes. */
#if (portBYTE_ALIGNMENT != 1)
	{
		if (xWantedSize & portBYTE_ALIGNMENT_MASK) {
  4022b0:	f010 0f07 	tst.w	r0, #7
  4022b4:	d002      	beq.n	4022bc <pvPortMalloc+0x10>
			/* Byte alignment required. */
			xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
  4022b6:	f020 0407 	bic.w	r4, r0, #7
  4022ba:	3408      	adds	r4, #8
		}
	}
#endif

	vTaskSuspendAll();
  4022bc:	4b10      	ldr	r3, [pc, #64]	; (402300 <pvPortMalloc+0x54>)
  4022be:	4798      	blx	r3
	{
		if (pucAlignedHeap == NULL) {
  4022c0:	4b10      	ldr	r3, [pc, #64]	; (402304 <pvPortMalloc+0x58>)
  4022c2:	681b      	ldr	r3, [r3, #0]
  4022c4:	b193      	cbz	r3, 4022ec <pvPortMalloc+0x40>
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
			                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
		}

		/* Check there is enough room left for the allocation. */
		if (((xNextFreeByte + xWantedSize) < configADJUSTED_HEAP_SIZE)
  4022c6:	4b0f      	ldr	r3, [pc, #60]	; (402304 <pvPortMalloc+0x58>)
  4022c8:	f8d3 3964 	ldr.w	r3, [r3, #2404]	; 0x964
  4022cc:	441c      	add	r4, r3
		    && ((xNextFreeByte + xWantedSize) > xNextFreeByte)) /* Check for overflow. */
  4022ce:	42a3      	cmp	r3, r4
  4022d0:	d213      	bcs.n	4022fa <pvPortMalloc+0x4e>
  4022d2:	f640 1257 	movw	r2, #2391	; 0x957
  4022d6:	4294      	cmp	r4, r2
  4022d8:	d80f      	bhi.n	4022fa <pvPortMalloc+0x4e>
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
  4022da:	4a0a      	ldr	r2, [pc, #40]	; (402304 <pvPortMalloc+0x58>)
  4022dc:	6815      	ldr	r5, [r2, #0]
  4022de:	441d      	add	r5, r3
			xNextFreeByte += xWantedSize;
  4022e0:	f8c2 4964 	str.w	r4, [r2, #2404]	; 0x964
		}

		traceMALLOC(pvReturn, xWantedSize);
	}
	(void)xTaskResumeAll();
  4022e4:	4b08      	ldr	r3, [pc, #32]	; (402308 <pvPortMalloc+0x5c>)
  4022e6:	4798      	blx	r3
		}
	}
#endif

	return pvReturn;
}
  4022e8:	4628      	mov	r0, r5
  4022ea:	bd38      	pop	{r3, r4, r5, pc}
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
  4022ec:	4a05      	ldr	r2, [pc, #20]	; (402304 <pvPortMalloc+0x58>)
  4022ee:	f102 030c 	add.w	r3, r2, #12
			                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
  4022f2:	f023 0307 	bic.w	r3, r3, #7
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
  4022f6:	6013      	str	r3, [r2, #0]
  4022f8:	e7e5      	b.n	4022c6 <pvPortMalloc+0x1a>
	void *          pvReturn       = NULL;
  4022fa:	2500      	movs	r5, #0
  4022fc:	e7f2      	b.n	4022e4 <pvPortMalloc+0x38>
  4022fe:	bf00      	nop
  402300:	00402fb1 	.word	0x00402fb1
  402304:	2040017c 	.word	0x2040017c
  402308:	004030f9 	.word	0x004030f9

0040230c <vPortFree>:
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	(void)pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT(pv == NULL);
  40230c:	b150      	cbz	r0, 402324 <vPortFree+0x18>
  40230e:	f44f 7380 	mov.w	r3, #256	; 0x100
  402312:	b672      	cpsid	i
  402314:	f383 8811 	msr	BASEPRI, r3
  402318:	f3bf 8f6f 	isb	sy
  40231c:	f3bf 8f4f 	dsb	sy
  402320:	b662      	cpsie	i
  402322:	e7fe      	b.n	402322 <vPortFree+0x16>
  402324:	4770      	bx	lr
	...

00402328 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue(Queue_t *const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition)
{
  402328:	b570      	push	{r4, r5, r6, lr}
  40232a:	4604      	mov	r4, r0
  40232c:	4616      	mov	r6, r2
	BaseType_t  xReturn = pdFALSE;
	UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  40232e:	6b85      	ldr	r5, [r0, #56]	; 0x38

	if (pxQueue->uxItemSize == (UBaseType_t)0) {
  402330:	6c02      	ldr	r2, [r0, #64]	; 0x40
  402332:	b952      	cbnz	r2, 40234a <prvCopyDataToQueue+0x22>
#if (configUSE_MUTEXES == 1)
		{
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
  402334:	6803      	ldr	r3, [r0, #0]
  402336:	2b00      	cmp	r3, #0
  402338:	d12a      	bne.n	402390 <prvCopyDataToQueue+0x68>
				/* The mutex is no longer being held. */
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
  40233a:	6840      	ldr	r0, [r0, #4]
  40233c:	4b17      	ldr	r3, [pc, #92]	; (40239c <prvCopyDataToQueue+0x74>)
  40233e:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
  402340:	2300      	movs	r3, #0
  402342:	6063      	str	r3, [r4, #4]
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
  402344:	3501      	adds	r5, #1
  402346:	63a5      	str	r5, [r4, #56]	; 0x38

	return xReturn;
}
  402348:	bd70      	pop	{r4, r5, r6, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
  40234a:	b96e      	cbnz	r6, 402368 <prvCopyDataToQueue+0x40>
		(void)memcpy((void *)pxQueue->pcWriteTo,
  40234c:	6880      	ldr	r0, [r0, #8]
  40234e:	4b14      	ldr	r3, [pc, #80]	; (4023a0 <prvCopyDataToQueue+0x78>)
  402350:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  402352:	68a3      	ldr	r3, [r4, #8]
  402354:	6c22      	ldr	r2, [r4, #64]	; 0x40
  402356:	4413      	add	r3, r2
  402358:	60a3      	str	r3, [r4, #8]
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
  40235a:	6862      	ldr	r2, [r4, #4]
  40235c:	4293      	cmp	r3, r2
  40235e:	d319      	bcc.n	402394 <prvCopyDataToQueue+0x6c>
			pxQueue->pcWriteTo = pxQueue->pcHead;
  402360:	6823      	ldr	r3, [r4, #0]
  402362:	60a3      	str	r3, [r4, #8]
	BaseType_t  xReturn = pdFALSE;
  402364:	2000      	movs	r0, #0
  402366:	e7ed      	b.n	402344 <prvCopyDataToQueue+0x1c>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
  402368:	68c0      	ldr	r0, [r0, #12]
  40236a:	4b0d      	ldr	r3, [pc, #52]	; (4023a0 <prvCopyDataToQueue+0x78>)
  40236c:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
  40236e:	6c23      	ldr	r3, [r4, #64]	; 0x40
  402370:	425b      	negs	r3, r3
  402372:	68e2      	ldr	r2, [r4, #12]
  402374:	441a      	add	r2, r3
  402376:	60e2      	str	r2, [r4, #12]
		if (pxQueue->u.pcReadFrom
  402378:	6821      	ldr	r1, [r4, #0]
  40237a:	428a      	cmp	r2, r1
  40237c:	d202      	bcs.n	402384 <prvCopyDataToQueue+0x5c>
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
  40237e:	6862      	ldr	r2, [r4, #4]
  402380:	4413      	add	r3, r2
  402382:	60e3      	str	r3, [r4, #12]
			if (uxMessagesWaiting > (UBaseType_t)0) {
  402384:	b145      	cbz	r5, 402398 <prvCopyDataToQueue+0x70>
  402386:	2e02      	cmp	r6, #2
  402388:	d106      	bne.n	402398 <prvCopyDataToQueue+0x70>
				--uxMessagesWaiting;
  40238a:	3d01      	subs	r5, #1
	BaseType_t  xReturn = pdFALSE;
  40238c:	2000      	movs	r0, #0
  40238e:	e7d9      	b.n	402344 <prvCopyDataToQueue+0x1c>
  402390:	2000      	movs	r0, #0
  402392:	e7d7      	b.n	402344 <prvCopyDataToQueue+0x1c>
  402394:	2000      	movs	r0, #0
  402396:	e7d5      	b.n	402344 <prvCopyDataToQueue+0x1c>
  402398:	2000      	movs	r0, #0
  40239a:	e7d3      	b.n	402344 <prvCopyDataToQueue+0x1c>
  40239c:	004035a5 	.word	0x004035a5
  4023a0:	004044dd 	.word	0x004044dd

004023a4 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if (configUSE_QUEUE_SETS == 1)

static BaseType_t prvNotifyQueueSetContainer(const Queue_t *const pxQueue, const BaseType_t xCopyPosition)
{
  4023a4:	b570      	push	{r4, r5, r6, lr}
  4023a6:	b082      	sub	sp, #8
  4023a8:	9001      	str	r0, [sp, #4]
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
  4023aa:	6c84      	ldr	r4, [r0, #72]	; 0x48
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
  4023ac:	b174      	cbz	r4, 4023cc <prvNotifyQueueSetContainer+0x28>
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
  4023ae:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  4023b0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  4023b2:	429a      	cmp	r2, r3
  4023b4:	d315      	bcc.n	4023e2 <prvNotifyQueueSetContainer+0x3e>
  4023b6:	f44f 7380 	mov.w	r3, #256	; 0x100
  4023ba:	b672      	cpsid	i
  4023bc:	f383 8811 	msr	BASEPRI, r3
  4023c0:	f3bf 8f6f 	isb	sy
  4023c4:	f3bf 8f4f 	dsb	sy
  4023c8:	b662      	cpsie	i
  4023ca:	e7fe      	b.n	4023ca <prvNotifyQueueSetContainer+0x26>
  4023cc:	f44f 7380 	mov.w	r3, #256	; 0x100
  4023d0:	b672      	cpsid	i
  4023d2:	f383 8811 	msr	BASEPRI, r3
  4023d6:	f3bf 8f6f 	isb	sy
  4023da:	f3bf 8f4f 	dsb	sy
  4023de:	b662      	cpsie	i
  4023e0:	e7fe      	b.n	4023e0 <prvNotifyQueueSetContainer+0x3c>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
  4023e2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  4023e4:	4293      	cmp	r3, r2
  4023e6:	d803      	bhi.n	4023f0 <prvNotifyQueueSetContainer+0x4c>
	BaseType_t xReturn             = pdFALSE;
  4023e8:	2600      	movs	r6, #0
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
  4023ea:	4630      	mov	r0, r6
  4023ec:	b002      	add	sp, #8
  4023ee:	bd70      	pop	{r4, r5, r6, pc}
  4023f0:	460a      	mov	r2, r1
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
  4023f2:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
  4023f6:	b26d      	sxtb	r5, r5
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
  4023f8:	a901      	add	r1, sp, #4
  4023fa:	4620      	mov	r0, r4
  4023fc:	4b0a      	ldr	r3, [pc, #40]	; (402428 <prvNotifyQueueSetContainer+0x84>)
  4023fe:	4798      	blx	r3
  402400:	4606      	mov	r6, r0
		if (cTxLock == queueUNLOCKED) {
  402402:	f1b5 3fff 	cmp.w	r5, #4294967295
  402406:	d10a      	bne.n	40241e <prvNotifyQueueSetContainer+0x7a>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
  402408:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40240a:	2b00      	cmp	r3, #0
  40240c:	d0ed      	beq.n	4023ea <prvNotifyQueueSetContainer+0x46>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
  40240e:	f104 0024 	add.w	r0, r4, #36	; 0x24
  402412:	4b06      	ldr	r3, [pc, #24]	; (40242c <prvNotifyQueueSetContainer+0x88>)
  402414:	4798      	blx	r3
  402416:	2800      	cmp	r0, #0
					xReturn = pdTRUE;
  402418:	bf18      	it	ne
  40241a:	2601      	movne	r6, #1
  40241c:	e7e5      	b.n	4023ea <prvNotifyQueueSetContainer+0x46>
			pxQueueSetContainer->cTxLock = cTxLock + 1;
  40241e:	1c6b      	adds	r3, r5, #1
  402420:	b25b      	sxtb	r3, r3
  402422:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  402426:	e7e0      	b.n	4023ea <prvNotifyQueueSetContainer+0x46>
  402428:	00402329 	.word	0x00402329
  40242c:	00403395 	.word	0x00403395

00402430 <prvCopyDataFromQueue>:
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
  402430:	6c02      	ldr	r2, [r0, #64]	; 0x40
  402432:	b172      	cbz	r2, 402452 <prvCopyDataFromQueue+0x22>
{
  402434:	b510      	push	{r4, lr}
  402436:	4603      	mov	r3, r0
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
  402438:	68c4      	ldr	r4, [r0, #12]
  40243a:	4414      	add	r4, r2
  40243c:	60c4      	str	r4, [r0, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
  40243e:	6840      	ldr	r0, [r0, #4]
  402440:	4284      	cmp	r4, r0
  402442:	d301      	bcc.n	402448 <prvCopyDataFromQueue+0x18>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
  402444:	6818      	ldr	r0, [r3, #0]
  402446:	60d8      	str	r0, [r3, #12]
  402448:	4608      	mov	r0, r1
		(void)memcpy((void *)pvBuffer,
  40244a:	68d9      	ldr	r1, [r3, #12]
  40244c:	4b01      	ldr	r3, [pc, #4]	; (402454 <prvCopyDataFromQueue+0x24>)
  40244e:	4798      	blx	r3
  402450:	bd10      	pop	{r4, pc}
  402452:	4770      	bx	lr
  402454:	004044dd 	.word	0x004044dd

00402458 <prvUnlockQueue>:
{
  402458:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40245c:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
  40245e:	4b23      	ldr	r3, [pc, #140]	; (4024ec <prvUnlockQueue+0x94>)
  402460:	4798      	blx	r3
		int8_t cTxLock = pxQueue->cTxLock;
  402462:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
  402466:	b264      	sxtb	r4, r4
		while (cTxLock > queueLOCKED_UNMODIFIED) {
  402468:	2c00      	cmp	r4, #0
  40246a:	dd19      	ble.n	4024a0 <prvUnlockQueue+0x48>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
  40246c:	4e20      	ldr	r6, [pc, #128]	; (4024f0 <prvUnlockQueue+0x98>)
						vTaskMissedYield();
  40246e:	f8df 808c 	ldr.w	r8, [pc, #140]	; 4024fc <prvUnlockQueue+0xa4>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
  402472:	4f20      	ldr	r7, [pc, #128]	; (4024f4 <prvUnlockQueue+0x9c>)
  402474:	e008      	b.n	402488 <prvUnlockQueue+0x30>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
  402476:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  402478:	b193      	cbz	r3, 4024a0 <prvUnlockQueue+0x48>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
  40247a:	f105 0024 	add.w	r0, r5, #36	; 0x24
  40247e:	47b8      	blx	r7
  402480:	b960      	cbnz	r0, 40249c <prvUnlockQueue+0x44>
  402482:	3c01      	subs	r4, #1
  402484:	b264      	sxtb	r4, r4
		while (cTxLock > queueLOCKED_UNMODIFIED) {
  402486:	b15c      	cbz	r4, 4024a0 <prvUnlockQueue+0x48>
				if (pxQueue->pxQueueSetContainer != NULL) {
  402488:	6cab      	ldr	r3, [r5, #72]	; 0x48
  40248a:	2b00      	cmp	r3, #0
  40248c:	d0f3      	beq.n	402476 <prvUnlockQueue+0x1e>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
  40248e:	2100      	movs	r1, #0
  402490:	4628      	mov	r0, r5
  402492:	47b0      	blx	r6
  402494:	2800      	cmp	r0, #0
  402496:	d0f4      	beq.n	402482 <prvUnlockQueue+0x2a>
						vTaskMissedYield();
  402498:	47c0      	blx	r8
  40249a:	e7f2      	b.n	402482 <prvUnlockQueue+0x2a>
							vTaskMissedYield();
  40249c:	47c0      	blx	r8
  40249e:	e7f0      	b.n	402482 <prvUnlockQueue+0x2a>
		pxQueue->cTxLock = queueUNLOCKED;
  4024a0:	23ff      	movs	r3, #255	; 0xff
  4024a2:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
  4024a6:	4b14      	ldr	r3, [pc, #80]	; (4024f8 <prvUnlockQueue+0xa0>)
  4024a8:	4798      	blx	r3
	taskENTER_CRITICAL();
  4024aa:	4b10      	ldr	r3, [pc, #64]	; (4024ec <prvUnlockQueue+0x94>)
  4024ac:	4798      	blx	r3
		int8_t cRxLock = pxQueue->cRxLock;
  4024ae:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
  4024b2:	b264      	sxtb	r4, r4
		while (cRxLock > queueLOCKED_UNMODIFIED) {
  4024b4:	2c00      	cmp	r4, #0
  4024b6:	dd12      	ble.n	4024de <prvUnlockQueue+0x86>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
  4024b8:	692b      	ldr	r3, [r5, #16]
  4024ba:	b183      	cbz	r3, 4024de <prvUnlockQueue+0x86>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
  4024bc:	f105 0710 	add.w	r7, r5, #16
  4024c0:	4e0c      	ldr	r6, [pc, #48]	; (4024f4 <prvUnlockQueue+0x9c>)
					vTaskMissedYield();
  4024c2:	f8df 8038 	ldr.w	r8, [pc, #56]	; 4024fc <prvUnlockQueue+0xa4>
  4024c6:	e004      	b.n	4024d2 <prvUnlockQueue+0x7a>
  4024c8:	3c01      	subs	r4, #1
  4024ca:	b264      	sxtb	r4, r4
		while (cRxLock > queueLOCKED_UNMODIFIED) {
  4024cc:	b13c      	cbz	r4, 4024de <prvUnlockQueue+0x86>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
  4024ce:	692b      	ldr	r3, [r5, #16]
  4024d0:	b12b      	cbz	r3, 4024de <prvUnlockQueue+0x86>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
  4024d2:	4638      	mov	r0, r7
  4024d4:	47b0      	blx	r6
  4024d6:	2800      	cmp	r0, #0
  4024d8:	d0f6      	beq.n	4024c8 <prvUnlockQueue+0x70>
					vTaskMissedYield();
  4024da:	47c0      	blx	r8
  4024dc:	e7f4      	b.n	4024c8 <prvUnlockQueue+0x70>
		pxQueue->cRxLock = queueUNLOCKED;
  4024de:	23ff      	movs	r3, #255	; 0xff
  4024e0:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	taskEXIT_CRITICAL();
  4024e4:	4b04      	ldr	r3, [pc, #16]	; (4024f8 <prvUnlockQueue+0xa0>)
  4024e6:	4798      	blx	r3
  4024e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4024ec:	00402065 	.word	0x00402065
  4024f0:	004023a5 	.word	0x004023a5
  4024f4:	00403395 	.word	0x00403395
  4024f8:	004020b1 	.word	0x004020b1
  4024fc:	004034e9 	.word	0x004034e9

00402500 <xQueueGenericReset>:
{
  402500:	b538      	push	{r3, r4, r5, lr}
	configASSERT(pxQueue);
  402502:	b330      	cbz	r0, 402552 <xQueueGenericReset+0x52>
  402504:	4604      	mov	r4, r0
  402506:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
  402508:	4b1d      	ldr	r3, [pc, #116]	; (402580 <xQueueGenericReset+0x80>)
  40250a:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
  40250c:	6822      	ldr	r2, [r4, #0]
  40250e:	6c21      	ldr	r1, [r4, #64]	; 0x40
  402510:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  402512:	fb03 f301 	mul.w	r3, r3, r1
  402516:	18d0      	adds	r0, r2, r3
  402518:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
  40251a:	2000      	movs	r0, #0
  40251c:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo         = pxQueue->pcHead;
  40251e:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
  402520:	1a5b      	subs	r3, r3, r1
  402522:	4413      	add	r3, r2
  402524:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock           = queueUNLOCKED;
  402526:	23ff      	movs	r3, #255	; 0xff
  402528:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock           = queueUNLOCKED;
  40252c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if (xNewQueue == pdFALSE) {
  402530:	b9d5      	cbnz	r5, 402568 <xQueueGenericReset+0x68>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
  402532:	6923      	ldr	r3, [r4, #16]
  402534:	b1fb      	cbz	r3, 402576 <xQueueGenericReset+0x76>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
  402536:	f104 0010 	add.w	r0, r4, #16
  40253a:	4b12      	ldr	r3, [pc, #72]	; (402584 <xQueueGenericReset+0x84>)
  40253c:	4798      	blx	r3
  40253e:	b1d0      	cbz	r0, 402576 <xQueueGenericReset+0x76>
					queueYIELD_IF_USING_PREEMPTION();
  402540:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402544:	4b10      	ldr	r3, [pc, #64]	; (402588 <xQueueGenericReset+0x88>)
  402546:	601a      	str	r2, [r3, #0]
  402548:	f3bf 8f4f 	dsb	sy
  40254c:	f3bf 8f6f 	isb	sy
  402550:	e011      	b.n	402576 <xQueueGenericReset+0x76>
  402552:	f44f 7380 	mov.w	r3, #256	; 0x100
  402556:	b672      	cpsid	i
  402558:	f383 8811 	msr	BASEPRI, r3
  40255c:	f3bf 8f6f 	isb	sy
  402560:	f3bf 8f4f 	dsb	sy
  402564:	b662      	cpsie	i
  402566:	e7fe      	b.n	402566 <xQueueGenericReset+0x66>
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
  402568:	f104 0010 	add.w	r0, r4, #16
  40256c:	4d07      	ldr	r5, [pc, #28]	; (40258c <xQueueGenericReset+0x8c>)
  40256e:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
  402570:	f104 0024 	add.w	r0, r4, #36	; 0x24
  402574:	47a8      	blx	r5
	taskEXIT_CRITICAL();
  402576:	4b06      	ldr	r3, [pc, #24]	; (402590 <xQueueGenericReset+0x90>)
  402578:	4798      	blx	r3
}
  40257a:	2001      	movs	r0, #1
  40257c:	bd38      	pop	{r3, r4, r5, pc}
  40257e:	bf00      	nop
  402580:	00402065 	.word	0x00402065
  402584:	00403395 	.word	0x00403395
  402588:	e000ed04 	.word	0xe000ed04
  40258c:	00401f11 	.word	0x00401f11
  402590:	004020b1 	.word	0x004020b1

00402594 <xQueueGenericCreate>:
{
  402594:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT(uxQueueLength > (UBaseType_t)0);
  402596:	b950      	cbnz	r0, 4025ae <xQueueGenericCreate+0x1a>
  402598:	f44f 7380 	mov.w	r3, #256	; 0x100
  40259c:	b672      	cpsid	i
  40259e:	f383 8811 	msr	BASEPRI, r3
  4025a2:	f3bf 8f6f 	isb	sy
  4025a6:	f3bf 8f4f 	dsb	sy
  4025aa:	b662      	cpsie	i
  4025ac:	e7fe      	b.n	4025ac <xQueueGenericCreate+0x18>
  4025ae:	4606      	mov	r6, r0
  4025b0:	4617      	mov	r7, r2
  4025b2:	460d      	mov	r5, r1
		xQueueSizeInBytes = (size_t)(
  4025b4:	fb01 f000 	mul.w	r0, r1, r0
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
  4025b8:	3054      	adds	r0, #84	; 0x54
  4025ba:	4b0b      	ldr	r3, [pc, #44]	; (4025e8 <xQueueGenericCreate+0x54>)
  4025bc:	4798      	blx	r3
	if (pxNewQueue != NULL) {
  4025be:	4604      	mov	r4, r0
  4025c0:	b178      	cbz	r0, 4025e2 <xQueueGenericCreate+0x4e>
	if (uxItemSize == (UBaseType_t)0) {
  4025c2:	b11d      	cbz	r5, 4025cc <xQueueGenericCreate+0x38>
		pucQueueStorage = ((uint8_t *)pxNewQueue) + sizeof(Queue_t);
  4025c4:	f100 0354 	add.w	r3, r0, #84	; 0x54
		pxNewQueue->pcHead = (int8_t *)pucQueueStorage;
  4025c8:	6003      	str	r3, [r0, #0]
  4025ca:	e000      	b.n	4025ce <xQueueGenericCreate+0x3a>
		pxNewQueue->pcHead = (int8_t *)pxNewQueue;
  4025cc:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength   = uxQueueLength;
  4025ce:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
  4025d0:	6425      	str	r5, [r4, #64]	; 0x40
	(void)xQueueGenericReset(pxNewQueue, pdTRUE);
  4025d2:	2101      	movs	r1, #1
  4025d4:	4620      	mov	r0, r4
  4025d6:	4b05      	ldr	r3, [pc, #20]	; (4025ec <xQueueGenericCreate+0x58>)
  4025d8:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
  4025da:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
		pxNewQueue->pxQueueSetContainer = NULL;
  4025de:	2300      	movs	r3, #0
  4025e0:	64a3      	str	r3, [r4, #72]	; 0x48
}
  4025e2:	4620      	mov	r0, r4
  4025e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4025e6:	bf00      	nop
  4025e8:	004022ad 	.word	0x004022ad
  4025ec:	00402501 	.word	0x00402501

004025f0 <xQueueCreateCountingSemaphore>:
	configASSERT(uxMaxCount != 0);
  4025f0:	b950      	cbnz	r0, 402608 <xQueueCreateCountingSemaphore+0x18>
  4025f2:	f44f 7380 	mov.w	r3, #256	; 0x100
  4025f6:	b672      	cpsid	i
  4025f8:	f383 8811 	msr	BASEPRI, r3
  4025fc:	f3bf 8f6f 	isb	sy
  402600:	f3bf 8f4f 	dsb	sy
  402604:	b662      	cpsie	i
  402606:	e7fe      	b.n	402606 <xQueueCreateCountingSemaphore+0x16>
	configASSERT(uxInitialCount <= uxMaxCount);
  402608:	4288      	cmp	r0, r1
  40260a:	d20a      	bcs.n	402622 <xQueueCreateCountingSemaphore+0x32>
  40260c:	f44f 7380 	mov.w	r3, #256	; 0x100
  402610:	b672      	cpsid	i
  402612:	f383 8811 	msr	BASEPRI, r3
  402616:	f3bf 8f6f 	isb	sy
  40261a:	f3bf 8f4f 	dsb	sy
  40261e:	b662      	cpsie	i
  402620:	e7fe      	b.n	402620 <xQueueCreateCountingSemaphore+0x30>
{
  402622:	b510      	push	{r4, lr}
  402624:	460c      	mov	r4, r1
	xHandle = xQueueGenericCreate(uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE);
  402626:	2202      	movs	r2, #2
  402628:	2100      	movs	r1, #0
  40262a:	4b03      	ldr	r3, [pc, #12]	; (402638 <xQueueCreateCountingSemaphore+0x48>)
  40262c:	4798      	blx	r3
	if (xHandle != NULL) {
  40262e:	4603      	mov	r3, r0
  402630:	b100      	cbz	r0, 402634 <xQueueCreateCountingSemaphore+0x44>
		((Queue_t *)xHandle)->uxMessagesWaiting = uxInitialCount;
  402632:	6384      	str	r4, [r0, #56]	; 0x38
}
  402634:	4618      	mov	r0, r3
  402636:	bd10      	pop	{r4, pc}
  402638:	00402595 	.word	0x00402595

0040263c <xQueueGenericSend>:
{
  40263c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402640:	b085      	sub	sp, #20
  402642:	9201      	str	r2, [sp, #4]
	configASSERT(pxQueue);
  402644:	b1b8      	cbz	r0, 402676 <xQueueGenericSend+0x3a>
  402646:	4604      	mov	r4, r0
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
  402648:	b301      	cbz	r1, 40268c <xQueueGenericSend+0x50>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
  40264a:	2b02      	cmp	r3, #2
  40264c:	d02c      	beq.n	4026a8 <xQueueGenericSend+0x6c>
  40264e:	461e      	mov	r6, r3
  402650:	460f      	mov	r7, r1
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
  402652:	4b69      	ldr	r3, [pc, #420]	; (4027f8 <xQueueGenericSend+0x1bc>)
  402654:	4798      	blx	r3
  402656:	2800      	cmp	r0, #0
  402658:	d134      	bne.n	4026c4 <xQueueGenericSend+0x88>
  40265a:	9b01      	ldr	r3, [sp, #4]
  40265c:	2b00      	cmp	r3, #0
  40265e:	d039      	beq.n	4026d4 <xQueueGenericSend+0x98>
  402660:	f44f 7380 	mov.w	r3, #256	; 0x100
  402664:	b672      	cpsid	i
  402666:	f383 8811 	msr	BASEPRI, r3
  40266a:	f3bf 8f6f 	isb	sy
  40266e:	f3bf 8f4f 	dsb	sy
  402672:	b662      	cpsie	i
  402674:	e7fe      	b.n	402674 <xQueueGenericSend+0x38>
  402676:	f44f 7380 	mov.w	r3, #256	; 0x100
  40267a:	b672      	cpsid	i
  40267c:	f383 8811 	msr	BASEPRI, r3
  402680:	f3bf 8f6f 	isb	sy
  402684:	f3bf 8f4f 	dsb	sy
  402688:	b662      	cpsie	i
  40268a:	e7fe      	b.n	40268a <xQueueGenericSend+0x4e>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
  40268c:	6c02      	ldr	r2, [r0, #64]	; 0x40
  40268e:	2a00      	cmp	r2, #0
  402690:	d0db      	beq.n	40264a <xQueueGenericSend+0xe>
  402692:	f44f 7380 	mov.w	r3, #256	; 0x100
  402696:	b672      	cpsid	i
  402698:	f383 8811 	msr	BASEPRI, r3
  40269c:	f3bf 8f6f 	isb	sy
  4026a0:	f3bf 8f4f 	dsb	sy
  4026a4:	b662      	cpsie	i
  4026a6:	e7fe      	b.n	4026a6 <xQueueGenericSend+0x6a>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
  4026a8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
  4026aa:	2a01      	cmp	r2, #1
  4026ac:	d0cf      	beq.n	40264e <xQueueGenericSend+0x12>
  4026ae:	f44f 7380 	mov.w	r3, #256	; 0x100
  4026b2:	b672      	cpsid	i
  4026b4:	f383 8811 	msr	BASEPRI, r3
  4026b8:	f3bf 8f6f 	isb	sy
  4026bc:	f3bf 8f4f 	dsb	sy
  4026c0:	b662      	cpsie	i
  4026c2:	e7fe      	b.n	4026c2 <xQueueGenericSend+0x86>
  4026c4:	2500      	movs	r5, #0
		taskENTER_CRITICAL();
  4026c6:	f8df 815c 	ldr.w	r8, [pc, #348]	; 402824 <xQueueGenericSend+0x1e8>
					vTaskSetTimeOutState(&xTimeOut);
  4026ca:	f8df a15c 	ldr.w	sl, [pc, #348]	; 402828 <xQueueGenericSend+0x1ec>
					portYIELD_WITHIN_API();
  4026ce:	f8df 9134 	ldr.w	r9, [pc, #308]	; 402804 <xQueueGenericSend+0x1c8>
  4026d2:	e041      	b.n	402758 <xQueueGenericSend+0x11c>
  4026d4:	2500      	movs	r5, #0
  4026d6:	e7f6      	b.n	4026c6 <xQueueGenericSend+0x8a>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
  4026d8:	4632      	mov	r2, r6
  4026da:	4639      	mov	r1, r7
  4026dc:	4620      	mov	r0, r4
  4026de:	4b47      	ldr	r3, [pc, #284]	; (4027fc <xQueueGenericSend+0x1c0>)
  4026e0:	4798      	blx	r3
					if (pxQueue->pxQueueSetContainer != NULL) {
  4026e2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4026e4:	b193      	cbz	r3, 40270c <xQueueGenericSend+0xd0>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
  4026e6:	4631      	mov	r1, r6
  4026e8:	4620      	mov	r0, r4
  4026ea:	4b45      	ldr	r3, [pc, #276]	; (402800 <xQueueGenericSend+0x1c4>)
  4026ec:	4798      	blx	r3
  4026ee:	b138      	cbz	r0, 402700 <xQueueGenericSend+0xc4>
							queueYIELD_IF_USING_PREEMPTION();
  4026f0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4026f4:	4b43      	ldr	r3, [pc, #268]	; (402804 <xQueueGenericSend+0x1c8>)
  4026f6:	601a      	str	r2, [r3, #0]
  4026f8:	f3bf 8f4f 	dsb	sy
  4026fc:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
  402700:	4b41      	ldr	r3, [pc, #260]	; (402808 <xQueueGenericSend+0x1cc>)
  402702:	4798      	blx	r3
				return pdPASS;
  402704:	2001      	movs	r0, #1
}
  402706:	b005      	add	sp, #20
  402708:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
  40270c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40270e:	b173      	cbz	r3, 40272e <xQueueGenericSend+0xf2>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
  402710:	f104 0024 	add.w	r0, r4, #36	; 0x24
  402714:	4b3d      	ldr	r3, [pc, #244]	; (40280c <xQueueGenericSend+0x1d0>)
  402716:	4798      	blx	r3
  402718:	2800      	cmp	r0, #0
  40271a:	d0f1      	beq.n	402700 <xQueueGenericSend+0xc4>
								queueYIELD_IF_USING_PREEMPTION();
  40271c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402720:	4b38      	ldr	r3, [pc, #224]	; (402804 <xQueueGenericSend+0x1c8>)
  402722:	601a      	str	r2, [r3, #0]
  402724:	f3bf 8f4f 	dsb	sy
  402728:	f3bf 8f6f 	isb	sy
  40272c:	e7e8      	b.n	402700 <xQueueGenericSend+0xc4>
						} else if (xYieldRequired != pdFALSE) {
  40272e:	2800      	cmp	r0, #0
  402730:	d0e6      	beq.n	402700 <xQueueGenericSend+0xc4>
							queueYIELD_IF_USING_PREEMPTION();
  402732:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402736:	4b33      	ldr	r3, [pc, #204]	; (402804 <xQueueGenericSend+0x1c8>)
  402738:	601a      	str	r2, [r3, #0]
  40273a:	f3bf 8f4f 	dsb	sy
  40273e:	f3bf 8f6f 	isb	sy
  402742:	e7dd      	b.n	402700 <xQueueGenericSend+0xc4>
					taskEXIT_CRITICAL();
  402744:	4b30      	ldr	r3, [pc, #192]	; (402808 <xQueueGenericSend+0x1cc>)
  402746:	4798      	blx	r3
					return errQUEUE_FULL;
  402748:	2000      	movs	r0, #0
  40274a:	e7dc      	b.n	402706 <xQueueGenericSend+0xca>
				prvUnlockQueue(pxQueue);
  40274c:	4620      	mov	r0, r4
  40274e:	4b30      	ldr	r3, [pc, #192]	; (402810 <xQueueGenericSend+0x1d4>)
  402750:	4798      	blx	r3
				(void)xTaskResumeAll();
  402752:	4b30      	ldr	r3, [pc, #192]	; (402814 <xQueueGenericSend+0x1d8>)
  402754:	4798      	blx	r3
  402756:	2501      	movs	r5, #1
		taskENTER_CRITICAL();
  402758:	47c0      	blx	r8
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
  40275a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  40275c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  40275e:	429a      	cmp	r2, r3
  402760:	d3ba      	bcc.n	4026d8 <xQueueGenericSend+0x9c>
  402762:	2e02      	cmp	r6, #2
  402764:	d0b8      	beq.n	4026d8 <xQueueGenericSend+0x9c>
				if (xTicksToWait == (TickType_t)0) {
  402766:	9b01      	ldr	r3, [sp, #4]
  402768:	2b00      	cmp	r3, #0
  40276a:	d0eb      	beq.n	402744 <xQueueGenericSend+0x108>
				} else if (xEntryTimeSet == pdFALSE) {
  40276c:	b90d      	cbnz	r5, 402772 <xQueueGenericSend+0x136>
					vTaskSetTimeOutState(&xTimeOut);
  40276e:	a802      	add	r0, sp, #8
  402770:	47d0      	blx	sl
		taskEXIT_CRITICAL();
  402772:	4b25      	ldr	r3, [pc, #148]	; (402808 <xQueueGenericSend+0x1cc>)
  402774:	4798      	blx	r3
		vTaskSuspendAll();
  402776:	4b28      	ldr	r3, [pc, #160]	; (402818 <xQueueGenericSend+0x1dc>)
  402778:	4798      	blx	r3
		prvLockQueue(pxQueue);
  40277a:	47c0      	blx	r8
  40277c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  402780:	b25b      	sxtb	r3, r3
  402782:	f1b3 3fff 	cmp.w	r3, #4294967295
  402786:	d102      	bne.n	40278e <xQueueGenericSend+0x152>
  402788:	2300      	movs	r3, #0
  40278a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
  40278e:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  402792:	b25b      	sxtb	r3, r3
  402794:	f1b3 3fff 	cmp.w	r3, #4294967295
  402798:	d102      	bne.n	4027a0 <xQueueGenericSend+0x164>
  40279a:	2300      	movs	r3, #0
  40279c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  4027a0:	4b19      	ldr	r3, [pc, #100]	; (402808 <xQueueGenericSend+0x1cc>)
  4027a2:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
  4027a4:	a901      	add	r1, sp, #4
  4027a6:	a802      	add	r0, sp, #8
  4027a8:	4b1c      	ldr	r3, [pc, #112]	; (40281c <xQueueGenericSend+0x1e0>)
  4027aa:	4798      	blx	r3
  4027ac:	b9e0      	cbnz	r0, 4027e8 <xQueueGenericSend+0x1ac>
	taskENTER_CRITICAL();
  4027ae:	47c0      	blx	r8
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
  4027b0:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38
  4027b4:	6be5      	ldr	r5, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
  4027b6:	4b14      	ldr	r3, [pc, #80]	; (402808 <xQueueGenericSend+0x1cc>)
  4027b8:	4798      	blx	r3
			if (prvIsQueueFull(pxQueue) != pdFALSE) {
  4027ba:	45ab      	cmp	fp, r5
  4027bc:	d1c6      	bne.n	40274c <xQueueGenericSend+0x110>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
  4027be:	9901      	ldr	r1, [sp, #4]
  4027c0:	f104 0010 	add.w	r0, r4, #16
  4027c4:	4b16      	ldr	r3, [pc, #88]	; (402820 <xQueueGenericSend+0x1e4>)
  4027c6:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
  4027c8:	4620      	mov	r0, r4
  4027ca:	4b11      	ldr	r3, [pc, #68]	; (402810 <xQueueGenericSend+0x1d4>)
  4027cc:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
  4027ce:	4b11      	ldr	r3, [pc, #68]	; (402814 <xQueueGenericSend+0x1d8>)
  4027d0:	4798      	blx	r3
  4027d2:	2800      	cmp	r0, #0
  4027d4:	d1bf      	bne.n	402756 <xQueueGenericSend+0x11a>
					portYIELD_WITHIN_API();
  4027d6:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  4027da:	f8c9 3000 	str.w	r3, [r9]
  4027de:	f3bf 8f4f 	dsb	sy
  4027e2:	f3bf 8f6f 	isb	sy
  4027e6:	e7b6      	b.n	402756 <xQueueGenericSend+0x11a>
			prvUnlockQueue(pxQueue);
  4027e8:	4620      	mov	r0, r4
  4027ea:	4b09      	ldr	r3, [pc, #36]	; (402810 <xQueueGenericSend+0x1d4>)
  4027ec:	4798      	blx	r3
			(void)xTaskResumeAll();
  4027ee:	4b09      	ldr	r3, [pc, #36]	; (402814 <xQueueGenericSend+0x1d8>)
  4027f0:	4798      	blx	r3
			return errQUEUE_FULL;
  4027f2:	2000      	movs	r0, #0
  4027f4:	e787      	b.n	402706 <xQueueGenericSend+0xca>
  4027f6:	bf00      	nop
  4027f8:	004034f9 	.word	0x004034f9
  4027fc:	00402329 	.word	0x00402329
  402800:	004023a5 	.word	0x004023a5
  402804:	e000ed04 	.word	0xe000ed04
  402808:	004020b1 	.word	0x004020b1
  40280c:	00403395 	.word	0x00403395
  402810:	00402459 	.word	0x00402459
  402814:	004030f9 	.word	0x004030f9
  402818:	00402fb1 	.word	0x00402fb1
  40281c:	00403455 	.word	0x00403455
  402820:	0040330d 	.word	0x0040330d
  402824:	00402065 	.word	0x00402065
  402828:	00403429 	.word	0x00403429

0040282c <xQueueGenericSendFromISR>:
{
  40282c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT(pxQueue);
  402830:	2800      	cmp	r0, #0
  402832:	d039      	beq.n	4028a8 <xQueueGenericSendFromISR+0x7c>
  402834:	4604      	mov	r4, r0
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
  402836:	2900      	cmp	r1, #0
  402838:	d041      	beq.n	4028be <xQueueGenericSendFromISR+0x92>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
  40283a:	2b02      	cmp	r3, #2
  40283c:	d04d      	beq.n	4028da <xQueueGenericSendFromISR+0xae>
  40283e:	461f      	mov	r7, r3
  402840:	4690      	mov	r8, r2
  402842:	4689      	mov	r9, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  402844:	4b3a      	ldr	r3, [pc, #232]	; (402930 <xQueueGenericSendFromISR+0x104>)
  402846:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
  402848:	f3ef 8611 	mrs	r6, BASEPRI
  40284c:	f44f 7380 	mov.w	r3, #256	; 0x100
  402850:	b672      	cpsid	i
  402852:	f383 8811 	msr	BASEPRI, r3
  402856:	f3bf 8f6f 	isb	sy
  40285a:	f3bf 8f4f 	dsb	sy
  40285e:	b662      	cpsie	i
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
  402860:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  402862:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  402864:	429a      	cmp	r2, r3
  402866:	d301      	bcc.n	40286c <xQueueGenericSendFromISR+0x40>
  402868:	2f02      	cmp	r7, #2
  40286a:	d158      	bne.n	40291e <xQueueGenericSendFromISR+0xf2>
			const int8_t cTxLock = pxQueue->cTxLock;
  40286c:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
  402870:	b26d      	sxtb	r5, r5
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
  402872:	463a      	mov	r2, r7
  402874:	4649      	mov	r1, r9
  402876:	4620      	mov	r0, r4
  402878:	4b2e      	ldr	r3, [pc, #184]	; (402934 <xQueueGenericSendFromISR+0x108>)
  40287a:	4798      	blx	r3
			if (cTxLock == queueUNLOCKED) {
  40287c:	f1b5 3fff 	cmp.w	r5, #4294967295
  402880:	d147      	bne.n	402912 <xQueueGenericSendFromISR+0xe6>
					if (pxQueue->pxQueueSetContainer != NULL) {
  402882:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  402884:	2b00      	cmp	r3, #0
  402886:	d036      	beq.n	4028f6 <xQueueGenericSendFromISR+0xca>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
  402888:	4639      	mov	r1, r7
  40288a:	4620      	mov	r0, r4
  40288c:	4b2a      	ldr	r3, [pc, #168]	; (402938 <xQueueGenericSendFromISR+0x10c>)
  40288e:	4798      	blx	r3
							if (pxHigherPriorityTaskWoken != NULL) {
  402890:	f1b8 0f00 	cmp.w	r8, #0
  402894:	d045      	beq.n	402922 <xQueueGenericSendFromISR+0xf6>
  402896:	2800      	cmp	r0, #0
  402898:	d043      	beq.n	402922 <xQueueGenericSendFromISR+0xf6>
								*pxHigherPriorityTaskWoken = pdTRUE;
  40289a:	2001      	movs	r0, #1
  40289c:	f8c8 0000 	str.w	r0, [r8]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
  4028a0:	f386 8811 	msr	BASEPRI, r6
}
  4028a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__asm volatile("	mov %0, %1												\n"
  4028a8:	f44f 7380 	mov.w	r3, #256	; 0x100
  4028ac:	b672      	cpsid	i
  4028ae:	f383 8811 	msr	BASEPRI, r3
  4028b2:	f3bf 8f6f 	isb	sy
  4028b6:	f3bf 8f4f 	dsb	sy
  4028ba:	b662      	cpsie	i
  4028bc:	e7fe      	b.n	4028bc <xQueueGenericSendFromISR+0x90>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
  4028be:	6c00      	ldr	r0, [r0, #64]	; 0x40
  4028c0:	2800      	cmp	r0, #0
  4028c2:	d0ba      	beq.n	40283a <xQueueGenericSendFromISR+0xe>
  4028c4:	f44f 7380 	mov.w	r3, #256	; 0x100
  4028c8:	b672      	cpsid	i
  4028ca:	f383 8811 	msr	BASEPRI, r3
  4028ce:	f3bf 8f6f 	isb	sy
  4028d2:	f3bf 8f4f 	dsb	sy
  4028d6:	b662      	cpsie	i
  4028d8:	e7fe      	b.n	4028d8 <xQueueGenericSendFromISR+0xac>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
  4028da:	6be0      	ldr	r0, [r4, #60]	; 0x3c
  4028dc:	2801      	cmp	r0, #1
  4028de:	d0ae      	beq.n	40283e <xQueueGenericSendFromISR+0x12>
  4028e0:	f44f 7380 	mov.w	r3, #256	; 0x100
  4028e4:	b672      	cpsid	i
  4028e6:	f383 8811 	msr	BASEPRI, r3
  4028ea:	f3bf 8f6f 	isb	sy
  4028ee:	f3bf 8f4f 	dsb	sy
  4028f2:	b662      	cpsie	i
  4028f4:	e7fe      	b.n	4028f4 <xQueueGenericSendFromISR+0xc8>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
  4028f6:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4028f8:	b1ab      	cbz	r3, 402926 <xQueueGenericSendFromISR+0xfa>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
  4028fa:	f104 0024 	add.w	r0, r4, #36	; 0x24
  4028fe:	4b0f      	ldr	r3, [pc, #60]	; (40293c <xQueueGenericSendFromISR+0x110>)
  402900:	4798      	blx	r3
								if (pxHigherPriorityTaskWoken != NULL) {
  402902:	f1b8 0f00 	cmp.w	r8, #0
  402906:	d010      	beq.n	40292a <xQueueGenericSendFromISR+0xfe>
  402908:	b178      	cbz	r0, 40292a <xQueueGenericSendFromISR+0xfe>
									*pxHigherPriorityTaskWoken = pdTRUE;
  40290a:	2001      	movs	r0, #1
  40290c:	f8c8 0000 	str.w	r0, [r8]
  402910:	e7c6      	b.n	4028a0 <xQueueGenericSendFromISR+0x74>
				pxQueue->cTxLock = cTxLock + 1;
  402912:	1c6b      	adds	r3, r5, #1
  402914:	b25b      	sxtb	r3, r3
  402916:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
  40291a:	2001      	movs	r0, #1
  40291c:	e7c0      	b.n	4028a0 <xQueueGenericSendFromISR+0x74>
			xReturn = errQUEUE_FULL;
  40291e:	2000      	movs	r0, #0
  402920:	e7be      	b.n	4028a0 <xQueueGenericSendFromISR+0x74>
			xReturn = pdPASS;
  402922:	2001      	movs	r0, #1
  402924:	e7bc      	b.n	4028a0 <xQueueGenericSendFromISR+0x74>
  402926:	2001      	movs	r0, #1
  402928:	e7ba      	b.n	4028a0 <xQueueGenericSendFromISR+0x74>
  40292a:	2001      	movs	r0, #1
  40292c:	e7b8      	b.n	4028a0 <xQueueGenericSendFromISR+0x74>
  40292e:	bf00      	nop
  402930:	0040224d 	.word	0x0040224d
  402934:	00402329 	.word	0x00402329
  402938:	004023a5 	.word	0x004023a5
  40293c:	00403395 	.word	0x00403395

00402940 <xQueueGiveFromISR>:
	configASSERT(pxQueue);
  402940:	b170      	cbz	r0, 402960 <xQueueGiveFromISR+0x20>
{
  402942:	b570      	push	{r4, r5, r6, lr}
  402944:	4604      	mov	r4, r0
	configASSERT(pxQueue->uxItemSize == 0);
  402946:	6c03      	ldr	r3, [r0, #64]	; 0x40
  402948:	b1ab      	cbz	r3, 402976 <xQueueGiveFromISR+0x36>
  40294a:	f44f 7380 	mov.w	r3, #256	; 0x100
  40294e:	b672      	cpsid	i
  402950:	f383 8811 	msr	BASEPRI, r3
  402954:	f3bf 8f6f 	isb	sy
  402958:	f3bf 8f4f 	dsb	sy
  40295c:	b662      	cpsie	i
  40295e:	e7fe      	b.n	40295e <xQueueGiveFromISR+0x1e>
  402960:	f44f 7380 	mov.w	r3, #256	; 0x100
  402964:	b672      	cpsid	i
  402966:	f383 8811 	msr	BASEPRI, r3
  40296a:	f3bf 8f6f 	isb	sy
  40296e:	f3bf 8f4f 	dsb	sy
  402972:	b662      	cpsie	i
  402974:	e7fe      	b.n	402974 <xQueueGiveFromISR+0x34>
	configASSERT(!((pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) && (pxQueue->pxMutexHolder != NULL)));
  402976:	6803      	ldr	r3, [r0, #0]
  402978:	b33b      	cbz	r3, 4029ca <xQueueGiveFromISR+0x8a>
  40297a:	460e      	mov	r6, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  40297c:	4b26      	ldr	r3, [pc, #152]	; (402a18 <xQueueGiveFromISR+0xd8>)
  40297e:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
  402980:	f3ef 8511 	mrs	r5, BASEPRI
  402984:	f44f 7380 	mov.w	r3, #256	; 0x100
  402988:	b672      	cpsid	i
  40298a:	f383 8811 	msr	BASEPRI, r3
  40298e:	f3bf 8f6f 	isb	sy
  402992:	f3bf 8f4f 	dsb	sy
  402996:	b662      	cpsie	i
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  402998:	6ba2      	ldr	r2, [r4, #56]	; 0x38
		if (uxMessagesWaiting < pxQueue->uxLength) {
  40299a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  40299c:	429a      	cmp	r2, r3
  40299e:	d233      	bcs.n	402a08 <xQueueGiveFromISR+0xc8>
			const int8_t cTxLock = pxQueue->cTxLock;
  4029a0:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  4029a4:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
  4029a6:	3201      	adds	r2, #1
  4029a8:	63a2      	str	r2, [r4, #56]	; 0x38
			if (cTxLock == queueUNLOCKED) {
  4029aa:	f1b3 3fff 	cmp.w	r3, #4294967295
  4029ae:	d125      	bne.n	4029fc <xQueueGiveFromISR+0xbc>
					if (pxQueue->pxQueueSetContainer != NULL) {
  4029b0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4029b2:	b1c3      	cbz	r3, 4029e6 <xQueueGiveFromISR+0xa6>
						if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
  4029b4:	2100      	movs	r1, #0
  4029b6:	4620      	mov	r0, r4
  4029b8:	4b18      	ldr	r3, [pc, #96]	; (402a1c <xQueueGiveFromISR+0xdc>)
  4029ba:	4798      	blx	r3
							if (pxHigherPriorityTaskWoken != NULL) {
  4029bc:	b336      	cbz	r6, 402a0c <xQueueGiveFromISR+0xcc>
  4029be:	b328      	cbz	r0, 402a0c <xQueueGiveFromISR+0xcc>
								*pxHigherPriorityTaskWoken = pdTRUE;
  4029c0:	2001      	movs	r0, #1
  4029c2:	6030      	str	r0, [r6, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
  4029c4:	f385 8811 	msr	BASEPRI, r5
}
  4029c8:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(!((pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) && (pxQueue->pxMutexHolder != NULL)));
  4029ca:	6843      	ldr	r3, [r0, #4]
  4029cc:	2b00      	cmp	r3, #0
  4029ce:	d0d4      	beq.n	40297a <xQueueGiveFromISR+0x3a>
	__asm volatile("	mov %0, %1												\n"
  4029d0:	f44f 7380 	mov.w	r3, #256	; 0x100
  4029d4:	b672      	cpsid	i
  4029d6:	f383 8811 	msr	BASEPRI, r3
  4029da:	f3bf 8f6f 	isb	sy
  4029de:	f3bf 8f4f 	dsb	sy
  4029e2:	b662      	cpsie	i
  4029e4:	e7fe      	b.n	4029e4 <xQueueGiveFromISR+0xa4>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
  4029e6:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4029e8:	b193      	cbz	r3, 402a10 <xQueueGiveFromISR+0xd0>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
  4029ea:	f104 0024 	add.w	r0, r4, #36	; 0x24
  4029ee:	4b0c      	ldr	r3, [pc, #48]	; (402a20 <xQueueGiveFromISR+0xe0>)
  4029f0:	4798      	blx	r3
								if (pxHigherPriorityTaskWoken != NULL) {
  4029f2:	b17e      	cbz	r6, 402a14 <xQueueGiveFromISR+0xd4>
  4029f4:	b170      	cbz	r0, 402a14 <xQueueGiveFromISR+0xd4>
									*pxHigherPriorityTaskWoken = pdTRUE;
  4029f6:	2001      	movs	r0, #1
  4029f8:	6030      	str	r0, [r6, #0]
  4029fa:	e7e3      	b.n	4029c4 <xQueueGiveFromISR+0x84>
				pxQueue->cTxLock = cTxLock + 1;
  4029fc:	3301      	adds	r3, #1
  4029fe:	b25b      	sxtb	r3, r3
  402a00:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
  402a04:	2001      	movs	r0, #1
  402a06:	e7dd      	b.n	4029c4 <xQueueGiveFromISR+0x84>
			xReturn = errQUEUE_FULL;
  402a08:	2000      	movs	r0, #0
  402a0a:	e7db      	b.n	4029c4 <xQueueGiveFromISR+0x84>
			xReturn = pdPASS;
  402a0c:	2001      	movs	r0, #1
  402a0e:	e7d9      	b.n	4029c4 <xQueueGiveFromISR+0x84>
  402a10:	2001      	movs	r0, #1
  402a12:	e7d7      	b.n	4029c4 <xQueueGiveFromISR+0x84>
  402a14:	2001      	movs	r0, #1
  402a16:	e7d5      	b.n	4029c4 <xQueueGiveFromISR+0x84>
  402a18:	0040224d 	.word	0x0040224d
  402a1c:	004023a5 	.word	0x004023a5
  402a20:	00403395 	.word	0x00403395

00402a24 <xQueueGenericReceive>:
{
  402a24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402a28:	b085      	sub	sp, #20
  402a2a:	9201      	str	r2, [sp, #4]
	configASSERT(pxQueue);
  402a2c:	b198      	cbz	r0, 402a56 <xQueueGenericReceive+0x32>
  402a2e:	4604      	mov	r4, r0
	configASSERT(!((pvBuffer == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
  402a30:	b1e1      	cbz	r1, 402a6c <xQueueGenericReceive+0x48>
  402a32:	4698      	mov	r8, r3
  402a34:	460f      	mov	r7, r1
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
  402a36:	4b6b      	ldr	r3, [pc, #428]	; (402be4 <xQueueGenericReceive+0x1c0>)
  402a38:	4798      	blx	r3
  402a3a:	bb28      	cbnz	r0, 402a88 <xQueueGenericReceive+0x64>
  402a3c:	9b01      	ldr	r3, [sp, #4]
  402a3e:	b35b      	cbz	r3, 402a98 <xQueueGenericReceive+0x74>
  402a40:	f44f 7380 	mov.w	r3, #256	; 0x100
  402a44:	b672      	cpsid	i
  402a46:	f383 8811 	msr	BASEPRI, r3
  402a4a:	f3bf 8f6f 	isb	sy
  402a4e:	f3bf 8f4f 	dsb	sy
  402a52:	b662      	cpsie	i
  402a54:	e7fe      	b.n	402a54 <xQueueGenericReceive+0x30>
  402a56:	f44f 7380 	mov.w	r3, #256	; 0x100
  402a5a:	b672      	cpsid	i
  402a5c:	f383 8811 	msr	BASEPRI, r3
  402a60:	f3bf 8f6f 	isb	sy
  402a64:	f3bf 8f4f 	dsb	sy
  402a68:	b662      	cpsie	i
  402a6a:	e7fe      	b.n	402a6a <xQueueGenericReceive+0x46>
	configASSERT(!((pvBuffer == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
  402a6c:	6c02      	ldr	r2, [r0, #64]	; 0x40
  402a6e:	2a00      	cmp	r2, #0
  402a70:	d0df      	beq.n	402a32 <xQueueGenericReceive+0xe>
  402a72:	f44f 7380 	mov.w	r3, #256	; 0x100
  402a76:	b672      	cpsid	i
  402a78:	f383 8811 	msr	BASEPRI, r3
  402a7c:	f3bf 8f6f 	isb	sy
  402a80:	f3bf 8f4f 	dsb	sy
  402a84:	b662      	cpsie	i
  402a86:	e7fe      	b.n	402a86 <xQueueGenericReceive+0x62>
  402a88:	f04f 0900 	mov.w	r9, #0
		taskENTER_CRITICAL();
  402a8c:	4d56      	ldr	r5, [pc, #344]	; (402be8 <xQueueGenericReceive+0x1c4>)
					vTaskSetTimeOutState(&xTimeOut);
  402a8e:	f8df b188 	ldr.w	fp, [pc, #392]	; 402c18 <xQueueGenericReceive+0x1f4>
					portYIELD_WITHIN_API();
  402a92:	f8df a164 	ldr.w	sl, [pc, #356]	; 402bf8 <xQueueGenericReceive+0x1d4>
  402a96:	e062      	b.n	402b5e <xQueueGenericReceive+0x13a>
  402a98:	f04f 0900 	mov.w	r9, #0
  402a9c:	e7f6      	b.n	402a8c <xQueueGenericReceive+0x68>
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
  402a9e:	68e5      	ldr	r5, [r4, #12]
				prvCopyDataFromQueue(pxQueue, pvBuffer);
  402aa0:	4639      	mov	r1, r7
  402aa2:	4620      	mov	r0, r4
  402aa4:	4b51      	ldr	r3, [pc, #324]	; (402bec <xQueueGenericReceive+0x1c8>)
  402aa6:	4798      	blx	r3
				if (xJustPeeking == pdFALSE) {
  402aa8:	f1b8 0f00 	cmp.w	r8, #0
  402aac:	d11b      	bne.n	402ae6 <xQueueGenericReceive+0xc2>
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
  402aae:	3e01      	subs	r6, #1
  402ab0:	63a6      	str	r6, [r4, #56]	; 0x38
						if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
  402ab2:	6823      	ldr	r3, [r4, #0]
  402ab4:	b913      	cbnz	r3, 402abc <xQueueGenericReceive+0x98>
							    = (int8_t *)pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as
  402ab6:	4b4e      	ldr	r3, [pc, #312]	; (402bf0 <xQueueGenericReceive+0x1cc>)
  402ab8:	4798      	blx	r3
  402aba:	6060      	str	r0, [r4, #4]
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
  402abc:	6923      	ldr	r3, [r4, #16]
  402abe:	b163      	cbz	r3, 402ada <xQueueGenericReceive+0xb6>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
  402ac0:	f104 0010 	add.w	r0, r4, #16
  402ac4:	4b4b      	ldr	r3, [pc, #300]	; (402bf4 <xQueueGenericReceive+0x1d0>)
  402ac6:	4798      	blx	r3
  402ac8:	b138      	cbz	r0, 402ada <xQueueGenericReceive+0xb6>
							queueYIELD_IF_USING_PREEMPTION();
  402aca:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402ace:	4b4a      	ldr	r3, [pc, #296]	; (402bf8 <xQueueGenericReceive+0x1d4>)
  402ad0:	601a      	str	r2, [r3, #0]
  402ad2:	f3bf 8f4f 	dsb	sy
  402ad6:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
  402ada:	4b48      	ldr	r3, [pc, #288]	; (402bfc <xQueueGenericReceive+0x1d8>)
  402adc:	4798      	blx	r3
				return pdPASS;
  402ade:	2001      	movs	r0, #1
}
  402ae0:	b005      	add	sp, #20
  402ae2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
  402ae6:	60e5      	str	r5, [r4, #12]
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
  402ae8:	6a63      	ldr	r3, [r4, #36]	; 0x24
  402aea:	2b00      	cmp	r3, #0
  402aec:	d0f5      	beq.n	402ada <xQueueGenericReceive+0xb6>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
  402aee:	f104 0024 	add.w	r0, r4, #36	; 0x24
  402af2:	4b40      	ldr	r3, [pc, #256]	; (402bf4 <xQueueGenericReceive+0x1d0>)
  402af4:	4798      	blx	r3
  402af6:	2800      	cmp	r0, #0
  402af8:	d0ef      	beq.n	402ada <xQueueGenericReceive+0xb6>
							queueYIELD_IF_USING_PREEMPTION();
  402afa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402afe:	4b3e      	ldr	r3, [pc, #248]	; (402bf8 <xQueueGenericReceive+0x1d4>)
  402b00:	601a      	str	r2, [r3, #0]
  402b02:	f3bf 8f4f 	dsb	sy
  402b06:	f3bf 8f6f 	isb	sy
  402b0a:	e7e6      	b.n	402ada <xQueueGenericReceive+0xb6>
					taskEXIT_CRITICAL();
  402b0c:	4b3b      	ldr	r3, [pc, #236]	; (402bfc <xQueueGenericReceive+0x1d8>)
  402b0e:	4798      	blx	r3
					return errQUEUE_EMPTY;
  402b10:	2000      	movs	r0, #0
  402b12:	e7e5      	b.n	402ae0 <xQueueGenericReceive+0xbc>
					vTaskSetTimeOutState(&xTimeOut);
  402b14:	a802      	add	r0, sp, #8
  402b16:	47d8      	blx	fp
  402b18:	e02b      	b.n	402b72 <xQueueGenericReceive+0x14e>
		prvLockQueue(pxQueue);
  402b1a:	2300      	movs	r3, #0
  402b1c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
  402b20:	e032      	b.n	402b88 <xQueueGenericReceive+0x164>
  402b22:	2300      	movs	r3, #0
  402b24:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  402b28:	e034      	b.n	402b94 <xQueueGenericReceive+0x170>
						taskENTER_CRITICAL();
  402b2a:	47a8      	blx	r5
							vTaskPriorityInherit((void *)pxQueue->pxMutexHolder);
  402b2c:	6860      	ldr	r0, [r4, #4]
  402b2e:	4b34      	ldr	r3, [pc, #208]	; (402c00 <xQueueGenericReceive+0x1dc>)
  402b30:	4798      	blx	r3
						taskEXIT_CRITICAL();
  402b32:	4b32      	ldr	r3, [pc, #200]	; (402bfc <xQueueGenericReceive+0x1d8>)
  402b34:	4798      	blx	r3
  402b36:	e03e      	b.n	402bb6 <xQueueGenericReceive+0x192>
				prvUnlockQueue(pxQueue);
  402b38:	4620      	mov	r0, r4
  402b3a:	4b32      	ldr	r3, [pc, #200]	; (402c04 <xQueueGenericReceive+0x1e0>)
  402b3c:	4798      	blx	r3
				(void)xTaskResumeAll();
  402b3e:	4b32      	ldr	r3, [pc, #200]	; (402c08 <xQueueGenericReceive+0x1e4>)
  402b40:	4798      	blx	r3
  402b42:	e00a      	b.n	402b5a <xQueueGenericReceive+0x136>
			prvUnlockQueue(pxQueue);
  402b44:	4620      	mov	r0, r4
  402b46:	4b2f      	ldr	r3, [pc, #188]	; (402c04 <xQueueGenericReceive+0x1e0>)
  402b48:	4798      	blx	r3
			(void)xTaskResumeAll();
  402b4a:	4b2f      	ldr	r3, [pc, #188]	; (402c08 <xQueueGenericReceive+0x1e4>)
  402b4c:	4798      	blx	r3
	taskENTER_CRITICAL();
  402b4e:	47a8      	blx	r5
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
  402b50:	6ba6      	ldr	r6, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
  402b52:	4b2a      	ldr	r3, [pc, #168]	; (402bfc <xQueueGenericReceive+0x1d8>)
  402b54:	4798      	blx	r3
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
  402b56:	2e00      	cmp	r6, #0
  402b58:	d042      	beq.n	402be0 <xQueueGenericReceive+0x1bc>
  402b5a:	f04f 0901 	mov.w	r9, #1
		taskENTER_CRITICAL();
  402b5e:	47a8      	blx	r5
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  402b60:	6ba6      	ldr	r6, [r4, #56]	; 0x38
			if (uxMessagesWaiting > (UBaseType_t)0) {
  402b62:	2e00      	cmp	r6, #0
  402b64:	d19b      	bne.n	402a9e <xQueueGenericReceive+0x7a>
				if (xTicksToWait == (TickType_t)0) {
  402b66:	9b01      	ldr	r3, [sp, #4]
  402b68:	2b00      	cmp	r3, #0
  402b6a:	d0cf      	beq.n	402b0c <xQueueGenericReceive+0xe8>
				} else if (xEntryTimeSet == pdFALSE) {
  402b6c:	f1b9 0f00 	cmp.w	r9, #0
  402b70:	d0d0      	beq.n	402b14 <xQueueGenericReceive+0xf0>
		taskEXIT_CRITICAL();
  402b72:	4b22      	ldr	r3, [pc, #136]	; (402bfc <xQueueGenericReceive+0x1d8>)
  402b74:	4798      	blx	r3
		vTaskSuspendAll();
  402b76:	4b25      	ldr	r3, [pc, #148]	; (402c0c <xQueueGenericReceive+0x1e8>)
  402b78:	4798      	blx	r3
		prvLockQueue(pxQueue);
  402b7a:	47a8      	blx	r5
  402b7c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  402b80:	b25b      	sxtb	r3, r3
  402b82:	f1b3 3fff 	cmp.w	r3, #4294967295
  402b86:	d0c8      	beq.n	402b1a <xQueueGenericReceive+0xf6>
  402b88:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  402b8c:	b25b      	sxtb	r3, r3
  402b8e:	f1b3 3fff 	cmp.w	r3, #4294967295
  402b92:	d0c6      	beq.n	402b22 <xQueueGenericReceive+0xfe>
  402b94:	4b19      	ldr	r3, [pc, #100]	; (402bfc <xQueueGenericReceive+0x1d8>)
  402b96:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
  402b98:	a901      	add	r1, sp, #4
  402b9a:	a802      	add	r0, sp, #8
  402b9c:	4b1c      	ldr	r3, [pc, #112]	; (402c10 <xQueueGenericReceive+0x1ec>)
  402b9e:	4798      	blx	r3
  402ba0:	2800      	cmp	r0, #0
  402ba2:	d1cf      	bne.n	402b44 <xQueueGenericReceive+0x120>
	taskENTER_CRITICAL();
  402ba4:	47a8      	blx	r5
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
  402ba6:	6ba6      	ldr	r6, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
  402ba8:	4b14      	ldr	r3, [pc, #80]	; (402bfc <xQueueGenericReceive+0x1d8>)
  402baa:	4798      	blx	r3
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
  402bac:	2e00      	cmp	r6, #0
  402bae:	d1c3      	bne.n	402b38 <xQueueGenericReceive+0x114>
					if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
  402bb0:	6823      	ldr	r3, [r4, #0]
  402bb2:	2b00      	cmp	r3, #0
  402bb4:	d0b9      	beq.n	402b2a <xQueueGenericReceive+0x106>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
  402bb6:	9901      	ldr	r1, [sp, #4]
  402bb8:	f104 0024 	add.w	r0, r4, #36	; 0x24
  402bbc:	4b15      	ldr	r3, [pc, #84]	; (402c14 <xQueueGenericReceive+0x1f0>)
  402bbe:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
  402bc0:	4620      	mov	r0, r4
  402bc2:	4b10      	ldr	r3, [pc, #64]	; (402c04 <xQueueGenericReceive+0x1e0>)
  402bc4:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
  402bc6:	4b10      	ldr	r3, [pc, #64]	; (402c08 <xQueueGenericReceive+0x1e4>)
  402bc8:	4798      	blx	r3
  402bca:	2800      	cmp	r0, #0
  402bcc:	d1c5      	bne.n	402b5a <xQueueGenericReceive+0x136>
					portYIELD_WITHIN_API();
  402bce:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  402bd2:	f8ca 3000 	str.w	r3, [sl]
  402bd6:	f3bf 8f4f 	dsb	sy
  402bda:	f3bf 8f6f 	isb	sy
  402bde:	e7bc      	b.n	402b5a <xQueueGenericReceive+0x136>
				return errQUEUE_EMPTY;
  402be0:	2000      	movs	r0, #0
  402be2:	e77d      	b.n	402ae0 <xQueueGenericReceive+0xbc>
  402be4:	004034f9 	.word	0x004034f9
  402be8:	00402065 	.word	0x00402065
  402bec:	00402431 	.word	0x00402431
  402bf0:	00403645 	.word	0x00403645
  402bf4:	00403395 	.word	0x00403395
  402bf8:	e000ed04 	.word	0xe000ed04
  402bfc:	004020b1 	.word	0x004020b1
  402c00:	00403519 	.word	0x00403519
  402c04:	00402459 	.word	0x00402459
  402c08:	004030f9 	.word	0x004030f9
  402c0c:	00402fb1 	.word	0x00402fb1
  402c10:	00403455 	.word	0x00403455
  402c14:	0040330d 	.word	0x0040330d
  402c18:	00403429 	.word	0x00403429

00402c1c <vQueueWaitForMessageRestricted>:
{
  402c1c:	b570      	push	{r4, r5, r6, lr}
  402c1e:	4604      	mov	r4, r0
  402c20:	460d      	mov	r5, r1
  402c22:	4616      	mov	r6, r2
	prvLockQueue(pxQueue);
  402c24:	4b12      	ldr	r3, [pc, #72]	; (402c70 <vQueueWaitForMessageRestricted+0x54>)
  402c26:	4798      	blx	r3
  402c28:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  402c2c:	b25b      	sxtb	r3, r3
  402c2e:	f1b3 3fff 	cmp.w	r3, #4294967295
  402c32:	d00d      	beq.n	402c50 <vQueueWaitForMessageRestricted+0x34>
  402c34:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  402c38:	b25b      	sxtb	r3, r3
  402c3a:	f1b3 3fff 	cmp.w	r3, #4294967295
  402c3e:	d00b      	beq.n	402c58 <vQueueWaitForMessageRestricted+0x3c>
  402c40:	4b0c      	ldr	r3, [pc, #48]	; (402c74 <vQueueWaitForMessageRestricted+0x58>)
  402c42:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
  402c44:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  402c46:	b15b      	cbz	r3, 402c60 <vQueueWaitForMessageRestricted+0x44>
	prvUnlockQueue(pxQueue);
  402c48:	4620      	mov	r0, r4
  402c4a:	4b0b      	ldr	r3, [pc, #44]	; (402c78 <vQueueWaitForMessageRestricted+0x5c>)
  402c4c:	4798      	blx	r3
  402c4e:	bd70      	pop	{r4, r5, r6, pc}
	prvLockQueue(pxQueue);
  402c50:	2300      	movs	r3, #0
  402c52:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
  402c56:	e7ed      	b.n	402c34 <vQueueWaitForMessageRestricted+0x18>
  402c58:	2300      	movs	r3, #0
  402c5a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  402c5e:	e7ef      	b.n	402c40 <vQueueWaitForMessageRestricted+0x24>
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
  402c60:	4632      	mov	r2, r6
  402c62:	4629      	mov	r1, r5
  402c64:	f104 0024 	add.w	r0, r4, #36	; 0x24
  402c68:	4b04      	ldr	r3, [pc, #16]	; (402c7c <vQueueWaitForMessageRestricted+0x60>)
  402c6a:	4798      	blx	r3
  402c6c:	e7ec      	b.n	402c48 <vQueueWaitForMessageRestricted+0x2c>
  402c6e:	bf00      	nop
  402c70:	00402065 	.word	0x00402065
  402c74:	004020b1 	.word	0x004020b1
  402c78:	00402459 	.word	0x00402459
  402c7c:	0040334d 	.word	0x0040334d

00402c80 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
  402c80:	4806      	ldr	r0, [pc, #24]	; (402c9c <prvIdleTask+0x1c>)
				taskYIELD();
  402c82:	4907      	ldr	r1, [pc, #28]	; (402ca0 <prvIdleTask+0x20>)
  402c84:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
  402c88:	6a83      	ldr	r3, [r0, #40]	; 0x28
  402c8a:	2b01      	cmp	r3, #1
  402c8c:	d9fd      	bls.n	402c8a <prvIdleTask+0xa>
				taskYIELD();
  402c8e:	600a      	str	r2, [r1, #0]
  402c90:	f3bf 8f4f 	dsb	sy
  402c94:	f3bf 8f6f 	isb	sy
  402c98:	e7f6      	b.n	402c88 <prvIdleTask+0x8>
  402c9a:	bf00      	nop
  402c9c:	20400ae4 	.word	0x20400ae4
  402ca0:	e000ed04 	.word	0xe000ed04

00402ca4 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
  402ca4:	4b09      	ldr	r3, [pc, #36]	; (402ccc <prvResetNextTaskUnblockTime+0x28>)
  402ca6:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  402caa:	681b      	ldr	r3, [r3, #0]
  402cac:	b143      	cbz	r3, 402cc0 <prvResetNextTaskUnblockTime+0x1c>
	} else {
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
  402cae:	4b07      	ldr	r3, [pc, #28]	; (402ccc <prvResetNextTaskUnblockTime+0x28>)
  402cb0:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
  402cb4:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
  402cb6:	68d2      	ldr	r2, [r2, #12]
  402cb8:	6852      	ldr	r2, [r2, #4]
  402cba:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  402cbe:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
  402cc0:	f04f 32ff 	mov.w	r2, #4294967295
  402cc4:	4b01      	ldr	r3, [pc, #4]	; (402ccc <prvResetNextTaskUnblockTime+0x28>)
  402cc6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  402cca:	4770      	bx	lr
  402ccc:	20400ae4 	.word	0x20400ae4

00402cd0 <prvAddCurrentTaskToDelayedList>:

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
  402cd0:	b570      	push	{r4, r5, r6, lr}
  402cd2:	4604      	mov	r4, r0
  402cd4:	460e      	mov	r6, r1
	TickType_t       xTimeToWake;
	const TickType_t xConstTickCount = xTickCount;
  402cd6:	4b19      	ldr	r3, [pc, #100]	; (402d3c <prvAddCurrentTaskToDelayedList+0x6c>)
  402cd8:	f8d3 5094 	ldr.w	r5, [r3, #148]	; 0x94
	}
#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
  402cdc:	f8d3 0098 	ldr.w	r0, [r3, #152]	; 0x98
  402ce0:	3004      	adds	r0, #4
  402ce2:	4b17      	ldr	r3, [pc, #92]	; (402d40 <prvAddCurrentTaskToDelayedList+0x70>)
  402ce4:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

#if (INCLUDE_vTaskSuspend == 1)
	{
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
  402ce6:	f1b4 3fff 	cmp.w	r4, #4294967295
  402cea:	d100      	bne.n	402cee <prvAddCurrentTaskToDelayedList+0x1e>
  402cec:	b9ae      	cbnz	r6, 402d1a <prvAddCurrentTaskToDelayedList+0x4a>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
		} else {
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
  402cee:	442c      	add	r4, r5

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
  402cf0:	4b12      	ldr	r3, [pc, #72]	; (402d3c <prvAddCurrentTaskToDelayedList+0x6c>)
  402cf2:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  402cf6:	605c      	str	r4, [r3, #4]

			if (xTimeToWake < xConstTickCount) {
  402cf8:	42a5      	cmp	r5, r4
  402cfa:	d815      	bhi.n	402d28 <prvAddCurrentTaskToDelayedList+0x58>
				list. */
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
			} else {
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
  402cfc:	4d0f      	ldr	r5, [pc, #60]	; (402d3c <prvAddCurrentTaskToDelayedList+0x6c>)
  402cfe:	f8d5 008c 	ldr.w	r0, [r5, #140]	; 0x8c
  402d02:	f8d5 1098 	ldr.w	r1, [r5, #152]	; 0x98
  402d06:	3104      	adds	r1, #4
  402d08:	4b0e      	ldr	r3, [pc, #56]	; (402d44 <prvAddCurrentTaskToDelayedList+0x74>)
  402d0a:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if (xTimeToWake < xNextTaskUnblockTime) {
  402d0c:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
  402d10:	429c      	cmp	r4, r3
  402d12:	d201      	bcs.n	402d18 <prvAddCurrentTaskToDelayedList+0x48>
					xNextTaskUnblockTime = xTimeToWake;
  402d14:	f8c5 4090 	str.w	r4, [r5, #144]	; 0x90
  402d18:	bd70      	pop	{r4, r5, r6, pc}
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
  402d1a:	4808      	ldr	r0, [pc, #32]	; (402d3c <prvAddCurrentTaskToDelayedList+0x6c>)
  402d1c:	f8d0 1098 	ldr.w	r1, [r0, #152]	; 0x98
  402d20:	3104      	adds	r1, #4
  402d22:	4b09      	ldr	r3, [pc, #36]	; (402d48 <prvAddCurrentTaskToDelayedList+0x78>)
  402d24:	4798      	blx	r3
  402d26:	bd70      	pop	{r4, r5, r6, pc}
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
  402d28:	4b04      	ldr	r3, [pc, #16]	; (402d3c <prvAddCurrentTaskToDelayedList+0x6c>)
  402d2a:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
  402d2e:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
  402d32:	3104      	adds	r1, #4
  402d34:	4b03      	ldr	r3, [pc, #12]	; (402d44 <prvAddCurrentTaskToDelayedList+0x74>)
  402d36:	4798      	blx	r3
  402d38:	bd70      	pop	{r4, r5, r6, pc}
  402d3a:	bf00      	nop
  402d3c:	20400ae4 	.word	0x20400ae4
  402d40:	00401f79 	.word	0x00401f79
  402d44:	00401f45 	.word	0x00401f45
  402d48:	00401f2d 	.word	0x00401f2d

00402d4c <xTaskCreate>:
{
  402d4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402d50:	b083      	sub	sp, #12
  402d52:	4683      	mov	fp, r0
  402d54:	460d      	mov	r5, r1
  402d56:	9301      	str	r3, [sp, #4]
  402d58:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
		pxStack = (StackType_t *)pvPortMalloc(
  402d5c:	0096      	lsls	r6, r2, #2
  402d5e:	4630      	mov	r0, r6
  402d60:	4b66      	ldr	r3, [pc, #408]	; (402efc <xTaskCreate+0x1b0>)
  402d62:	4798      	blx	r3
		if (pxStack != NULL) {
  402d64:	2800      	cmp	r0, #0
  402d66:	f000 8096 	beq.w	402e96 <xTaskCreate+0x14a>
  402d6a:	4607      	mov	r7, r0
			pxNewTCB = (TCB_t *)pvPortMalloc(
  402d6c:	2054      	movs	r0, #84	; 0x54
  402d6e:	4b63      	ldr	r3, [pc, #396]	; (402efc <xTaskCreate+0x1b0>)
  402d70:	4798      	blx	r3
			if (pxNewTCB != NULL) {
  402d72:	4604      	mov	r4, r0
  402d74:	2800      	cmp	r0, #0
  402d76:	f000 808b 	beq.w	402e90 <xTaskCreate+0x144>
				pxNewTCB->pxStack = pxStack;
  402d7a:	6307      	str	r7, [r0, #48]	; 0x30
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)usStackDepth * sizeof(StackType_t));
  402d7c:	4632      	mov	r2, r6
  402d7e:	21a5      	movs	r1, #165	; 0xa5
  402d80:	4638      	mov	r0, r7
  402d82:	4b5f      	ldr	r3, [pc, #380]	; (402f00 <xTaskCreate+0x1b4>)
  402d84:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + (usStackDepth - (uint16_t)1);
  402d86:	3e04      	subs	r6, #4
  402d88:	6b23      	ldr	r3, [r4, #48]	; 0x30
  402d8a:	441e      	add	r6, r3
		                      & (~(
  402d8c:	f026 0607 	bic.w	r6, r6, #7
		pxNewTCB->pcTaskName[x] = pcName[x];
  402d90:	782b      	ldrb	r3, [r5, #0]
  402d92:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
		if (pcName[x] == 0x00) {
  402d96:	782b      	ldrb	r3, [r5, #0]
  402d98:	b15b      	cbz	r3, 402db2 <xTaskCreate+0x66>
  402d9a:	462b      	mov	r3, r5
  402d9c:	f104 0235 	add.w	r2, r4, #53	; 0x35
  402da0:	1de9      	adds	r1, r5, #7
		pxNewTCB->pcTaskName[x] = pcName[x];
  402da2:	7858      	ldrb	r0, [r3, #1]
  402da4:	f802 0b01 	strb.w	r0, [r2], #1
		if (pcName[x] == 0x00) {
  402da8:	f813 0f01 	ldrb.w	r0, [r3, #1]!
  402dac:	b108      	cbz	r0, 402db2 <xTaskCreate+0x66>
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
  402dae:	4299      	cmp	r1, r3
  402db0:	d1f7      	bne.n	402da2 <xTaskCreate+0x56>
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
  402db2:	2700      	movs	r7, #0
  402db4:	f884 703b 	strb.w	r7, [r4, #59]	; 0x3b
  402db8:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  402dba:	2d04      	cmp	r5, #4
  402dbc:	bf28      	it	cs
  402dbe:	2504      	movcs	r5, #4
	pxNewTCB->uxPriority = uxPriority;
  402dc0:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
  402dc2:	6465      	str	r5, [r4, #68]	; 0x44
		pxNewTCB->uxMutexesHeld  = 0;
  402dc4:	64a7      	str	r7, [r4, #72]	; 0x48
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
  402dc6:	f104 0804 	add.w	r8, r4, #4
  402dca:	4640      	mov	r0, r8
  402dcc:	f8df 9154 	ldr.w	r9, [pc, #340]	; 402f24 <xTaskCreate+0x1d8>
  402dd0:	47c8      	blx	r9
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
  402dd2:	f104 0018 	add.w	r0, r4, #24
  402dd6:	47c8      	blx	r9
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
  402dd8:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE(
  402dda:	f1c5 0505 	rsb	r5, r5, #5
  402dde:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
  402de0:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
  402de2:	64e7      	str	r7, [r4, #76]	; 0x4c
		pxNewTCB->ucNotifyState   = taskNOT_WAITING_NOTIFICATION;
  402de4:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
  402de8:	9a01      	ldr	r2, [sp, #4]
  402dea:	4659      	mov	r1, fp
  402dec:	4630      	mov	r0, r6
  402dee:	4b45      	ldr	r3, [pc, #276]	; (402f04 <xTaskCreate+0x1b8>)
  402df0:	4798      	blx	r3
  402df2:	6020      	str	r0, [r4, #0]
	if ((void *)pxCreatedTask != NULL) {
  402df4:	f1ba 0f00 	cmp.w	sl, #0
  402df8:	d001      	beq.n	402dfe <xTaskCreate+0xb2>
		*pxCreatedTask = (TaskHandle_t)pxNewTCB;
  402dfa:	f8ca 4000 	str.w	r4, [sl]
	taskENTER_CRITICAL();
  402dfe:	4b42      	ldr	r3, [pc, #264]	; (402f08 <xTaskCreate+0x1bc>)
  402e00:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
  402e02:	4b42      	ldr	r3, [pc, #264]	; (402f0c <xTaskCreate+0x1c0>)
  402e04:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
  402e08:	3201      	adds	r2, #1
  402e0a:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
		if (pxCurrentTCB == NULL) {
  402e0e:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  402e12:	2b00      	cmp	r3, #0
  402e14:	d042      	beq.n	402e9c <xTaskCreate+0x150>
			if (xSchedulerRunning == pdFALSE) {
  402e16:	4b3d      	ldr	r3, [pc, #244]	; (402f0c <xTaskCreate+0x1c0>)
  402e18:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
  402e1c:	b94b      	cbnz	r3, 402e32 <xTaskCreate+0xe6>
				if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
  402e1e:	4b3b      	ldr	r3, [pc, #236]	; (402f0c <xTaskCreate+0x1c0>)
  402e20:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  402e24:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402e26:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  402e28:	429a      	cmp	r2, r3
  402e2a:	d802      	bhi.n	402e32 <xTaskCreate+0xe6>
					pxCurrentTCB = pxNewTCB;
  402e2c:	4b37      	ldr	r3, [pc, #220]	; (402f0c <xTaskCreate+0x1c0>)
  402e2e:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98
		uxTaskNumber++;
  402e32:	4a36      	ldr	r2, [pc, #216]	; (402f0c <xTaskCreate+0x1c0>)
  402e34:	f8d2 30d0 	ldr.w	r3, [r2, #208]	; 0xd0
  402e38:	3301      	adds	r3, #1
  402e3a:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0
			pxNewTCB->uxTCBNumber = uxTaskNumber;
  402e3e:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList(pxNewTCB);
  402e40:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  402e42:	f8d2 20d4 	ldr.w	r2, [r2, #212]	; 0xd4
  402e46:	4293      	cmp	r3, r2
  402e48:	d902      	bls.n	402e50 <xTaskCreate+0x104>
  402e4a:	4a30      	ldr	r2, [pc, #192]	; (402f0c <xTaskCreate+0x1c0>)
  402e4c:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
  402e50:	4d2e      	ldr	r5, [pc, #184]	; (402f0c <xTaskCreate+0x1c0>)
  402e52:	f105 0028 	add.w	r0, r5, #40	; 0x28
  402e56:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  402e5a:	4641      	mov	r1, r8
  402e5c:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  402e60:	4b2b      	ldr	r3, [pc, #172]	; (402f10 <xTaskCreate+0x1c4>)
  402e62:	4798      	blx	r3
	taskEXIT_CRITICAL();
  402e64:	4b2b      	ldr	r3, [pc, #172]	; (402f14 <xTaskCreate+0x1c8>)
  402e66:	4798      	blx	r3
	if (xSchedulerRunning != pdFALSE) {
  402e68:	f8d5 30cc 	ldr.w	r3, [r5, #204]	; 0xcc
  402e6c:	2b00      	cmp	r3, #0
  402e6e:	d03f      	beq.n	402ef0 <xTaskCreate+0x1a4>
		if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
  402e70:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
  402e74:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402e76:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  402e78:	429a      	cmp	r2, r3
  402e7a:	d23d      	bcs.n	402ef8 <xTaskCreate+0x1ac>
			taskYIELD_IF_USING_PREEMPTION();
  402e7c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402e80:	4b25      	ldr	r3, [pc, #148]	; (402f18 <xTaskCreate+0x1cc>)
  402e82:	601a      	str	r2, [r3, #0]
  402e84:	f3bf 8f4f 	dsb	sy
  402e88:	f3bf 8f6f 	isb	sy
		xReturn = pdPASS;
  402e8c:	2001      	movs	r0, #1
  402e8e:	e030      	b.n	402ef2 <xTaskCreate+0x1a6>
				vPortFree(pxStack);
  402e90:	4638      	mov	r0, r7
  402e92:	4b22      	ldr	r3, [pc, #136]	; (402f1c <xTaskCreate+0x1d0>)
  402e94:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  402e96:	f04f 30ff 	mov.w	r0, #4294967295
  402e9a:	e02a      	b.n	402ef2 <xTaskCreate+0x1a6>
			pxCurrentTCB = pxNewTCB;
  402e9c:	4b1b      	ldr	r3, [pc, #108]	; (402f0c <xTaskCreate+0x1c0>)
  402e9e:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98
			if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
  402ea2:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
  402ea6:	2b01      	cmp	r3, #1
  402ea8:	d1c3      	bne.n	402e32 <xTaskCreate+0xe6>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
  402eaa:	4d18      	ldr	r5, [pc, #96]	; (402f0c <xTaskCreate+0x1c0>)
  402eac:	f105 0028 	add.w	r0, r5, #40	; 0x28
  402eb0:	4e1b      	ldr	r6, [pc, #108]	; (402f20 <xTaskCreate+0x1d4>)
  402eb2:	47b0      	blx	r6
  402eb4:	f105 003c 	add.w	r0, r5, #60	; 0x3c
  402eb8:	47b0      	blx	r6
  402eba:	f105 0050 	add.w	r0, r5, #80	; 0x50
  402ebe:	47b0      	blx	r6
  402ec0:	f105 0064 	add.w	r0, r5, #100	; 0x64
  402ec4:	47b0      	blx	r6
  402ec6:	f105 0078 	add.w	r0, r5, #120	; 0x78
  402eca:	47b0      	blx	r6
	vListInitialise(&xDelayedTaskList1);
  402ecc:	f105 09a4 	add.w	r9, r5, #164	; 0xa4
  402ed0:	4648      	mov	r0, r9
  402ed2:	47b0      	blx	r6
	vListInitialise(&xDelayedTaskList2);
  402ed4:	f105 07b8 	add.w	r7, r5, #184	; 0xb8
  402ed8:	4638      	mov	r0, r7
  402eda:	47b0      	blx	r6
	vListInitialise(&xPendingReadyList);
  402edc:	f105 0014 	add.w	r0, r5, #20
  402ee0:	47b0      	blx	r6
		vListInitialise(&xSuspendedTaskList);
  402ee2:	4628      	mov	r0, r5
  402ee4:	47b0      	blx	r6
	pxDelayedTaskList         = &xDelayedTaskList1;
  402ee6:	f8c5 908c 	str.w	r9, [r5, #140]	; 0x8c
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  402eea:	f8c5 709c 	str.w	r7, [r5, #156]	; 0x9c
  402eee:	e7a0      	b.n	402e32 <xTaskCreate+0xe6>
		xReturn = pdPASS;
  402ef0:	2001      	movs	r0, #1
}
  402ef2:	b003      	add	sp, #12
  402ef4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		xReturn = pdPASS;
  402ef8:	2001      	movs	r0, #1
	return xReturn;
  402efa:	e7fa      	b.n	402ef2 <xTaskCreate+0x1a6>
  402efc:	004022ad 	.word	0x004022ad
  402f00:	004044f3 	.word	0x004044f3
  402f04:	00402011 	.word	0x00402011
  402f08:	00402065 	.word	0x00402065
  402f0c:	20400ae4 	.word	0x20400ae4
  402f10:	00401f2d 	.word	0x00401f2d
  402f14:	004020b1 	.word	0x004020b1
  402f18:	e000ed04 	.word	0xe000ed04
  402f1c:	0040230d 	.word	0x0040230d
  402f20:	00401f11 	.word	0x00401f11
  402f24:	00401f27 	.word	0x00401f27

00402f28 <vTaskStartScheduler>:
{
  402f28:	b510      	push	{r4, lr}
  402f2a:	b082      	sub	sp, #8
		xReturn = xTaskCreate(prvIdleTask,
  402f2c:	4b19      	ldr	r3, [pc, #100]	; (402f94 <vTaskStartScheduler+0x6c>)
  402f2e:	9301      	str	r3, [sp, #4]
  402f30:	2300      	movs	r3, #0
  402f32:	9300      	str	r3, [sp, #0]
  402f34:	2240      	movs	r2, #64	; 0x40
  402f36:	4918      	ldr	r1, [pc, #96]	; (402f98 <vTaskStartScheduler+0x70>)
  402f38:	4818      	ldr	r0, [pc, #96]	; (402f9c <vTaskStartScheduler+0x74>)
  402f3a:	4c19      	ldr	r4, [pc, #100]	; (402fa0 <vTaskStartScheduler+0x78>)
  402f3c:	47a0      	blx	r4
		if (xReturn == pdPASS) {
  402f3e:	2801      	cmp	r0, #1
  402f40:	d00b      	beq.n	402f5a <vTaskStartScheduler+0x32>
		configASSERT(xReturn);
  402f42:	bb28      	cbnz	r0, 402f90 <vTaskStartScheduler+0x68>
  402f44:	f44f 7380 	mov.w	r3, #256	; 0x100
  402f48:	b672      	cpsid	i
  402f4a:	f383 8811 	msr	BASEPRI, r3
  402f4e:	f3bf 8f6f 	isb	sy
  402f52:	f3bf 8f4f 	dsb	sy
  402f56:	b662      	cpsie	i
  402f58:	e7fe      	b.n	402f58 <vTaskStartScheduler+0x30>
			xReturn = xTimerCreateTimerTask();
  402f5a:	4b12      	ldr	r3, [pc, #72]	; (402fa4 <vTaskStartScheduler+0x7c>)
  402f5c:	4798      	blx	r3
	if (xReturn == pdPASS) {
  402f5e:	2801      	cmp	r0, #1
  402f60:	d1ef      	bne.n	402f42 <vTaskStartScheduler+0x1a>
  402f62:	f44f 7380 	mov.w	r3, #256	; 0x100
  402f66:	b672      	cpsid	i
  402f68:	f383 8811 	msr	BASEPRI, r3
  402f6c:	f3bf 8f6f 	isb	sy
  402f70:	f3bf 8f4f 	dsb	sy
  402f74:	b662      	cpsie	i
		xNextTaskUnblockTime = portMAX_DELAY;
  402f76:	4b0c      	ldr	r3, [pc, #48]	; (402fa8 <vTaskStartScheduler+0x80>)
  402f78:	f04f 32ff 	mov.w	r2, #4294967295
  402f7c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
		xSchedulerRunning    = pdTRUE;
  402f80:	2201      	movs	r2, #1
  402f82:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
		xTickCount           = (TickType_t)0U;
  402f86:	2200      	movs	r2, #0
  402f88:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
		if (xPortStartScheduler() != pdFALSE) {
  402f8c:	4b07      	ldr	r3, [pc, #28]	; (402fac <vTaskStartScheduler+0x84>)
  402f8e:	4798      	blx	r3
}
  402f90:	b002      	add	sp, #8
  402f92:	bd10      	pop	{r4, pc}
  402f94:	20400bc0 	.word	0x20400bc0
  402f98:	004045b8 	.word	0x004045b8
  402f9c:	00402c81 	.word	0x00402c81
  402fa0:	00402d4d 	.word	0x00402d4d
  402fa4:	004036f9 	.word	0x004036f9
  402fa8:	20400ae4 	.word	0x20400ae4
  402fac:	00402191 	.word	0x00402191

00402fb0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
  402fb0:	4a03      	ldr	r2, [pc, #12]	; (402fc0 <vTaskSuspendAll+0x10>)
  402fb2:	f8d2 30d8 	ldr.w	r3, [r2, #216]	; 0xd8
  402fb6:	3301      	adds	r3, #1
  402fb8:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
  402fbc:	4770      	bx	lr
  402fbe:	bf00      	nop
  402fc0:	20400ae4 	.word	0x20400ae4

00402fc4 <xTaskGetTickCount>:
		xTicks = xTickCount;
  402fc4:	4b01      	ldr	r3, [pc, #4]	; (402fcc <xTaskGetTickCount+0x8>)
  402fc6:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
}
  402fca:	4770      	bx	lr
  402fcc:	20400ae4 	.word	0x20400ae4

00402fd0 <xTaskIncrementTick>:
{
  402fd0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
  402fd4:	4b44      	ldr	r3, [pc, #272]	; (4030e8 <xTaskIncrementTick+0x118>)
  402fd6:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
  402fda:	2b00      	cmp	r3, #0
  402fdc:	d174      	bne.n	4030c8 <xTaskIncrementTick+0xf8>
		const TickType_t xConstTickCount = xTickCount + 1;
  402fde:	4b42      	ldr	r3, [pc, #264]	; (4030e8 <xTaskIncrementTick+0x118>)
  402fe0:	f8d3 6094 	ldr.w	r6, [r3, #148]	; 0x94
  402fe4:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
  402fe6:	f8c3 6094 	str.w	r6, [r3, #148]	; 0x94
		if (xConstTickCount == (TickType_t)0U) {
  402fea:	b9f6      	cbnz	r6, 40302a <xTaskIncrementTick+0x5a>
			taskSWITCH_DELAYED_LISTS();
  402fec:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  402ff0:	681b      	ldr	r3, [r3, #0]
  402ff2:	b153      	cbz	r3, 40300a <xTaskIncrementTick+0x3a>
  402ff4:	f44f 7380 	mov.w	r3, #256	; 0x100
  402ff8:	b672      	cpsid	i
  402ffa:	f383 8811 	msr	BASEPRI, r3
  402ffe:	f3bf 8f6f 	isb	sy
  403002:	f3bf 8f4f 	dsb	sy
  403006:	b662      	cpsie	i
  403008:	e7fe      	b.n	403008 <xTaskIncrementTick+0x38>
  40300a:	4b37      	ldr	r3, [pc, #220]	; (4030e8 <xTaskIncrementTick+0x118>)
  40300c:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
  403010:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
  403014:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
  403018:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  40301c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
  403020:	3201      	adds	r2, #1
  403022:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
  403026:	4b31      	ldr	r3, [pc, #196]	; (4030ec <xTaskIncrementTick+0x11c>)
  403028:	4798      	blx	r3
		if (xConstTickCount >= xNextTaskUnblockTime) {
  40302a:	4b2f      	ldr	r3, [pc, #188]	; (4030e8 <xTaskIncrementTick+0x118>)
  40302c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  403030:	429e      	cmp	r6, r3
  403032:	d20d      	bcs.n	403050 <xTaskIncrementTick+0x80>
	BaseType_t xSwitchRequired = pdFALSE;
  403034:	2400      	movs	r4, #0
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
  403036:	4b2c      	ldr	r3, [pc, #176]	; (4030e8 <xTaskIncrementTick+0x118>)
  403038:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
  40303c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  40303e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  403042:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  403046:	6a9b      	ldr	r3, [r3, #40]	; 0x28
				xSwitchRequired = pdTRUE;
  403048:	2b02      	cmp	r3, #2
  40304a:	bf28      	it	cs
  40304c:	2401      	movcs	r4, #1
  40304e:	e042      	b.n	4030d6 <xTaskIncrementTick+0x106>
  403050:	2400      	movs	r4, #0
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
  403052:	4d25      	ldr	r5, [pc, #148]	; (4030e8 <xTaskIncrementTick+0x118>)
					(void)uxListRemove(&(pxTCB->xStateListItem));
  403054:	f8df 809c 	ldr.w	r8, [pc, #156]	; 4030f4 <xTaskIncrementTick+0x124>
					prvAddTaskToReadyList(pxTCB);
  403058:	f105 0a28 	add.w	sl, r5, #40	; 0x28
  40305c:	e017      	b.n	40308e <xTaskIncrementTick+0xbe>
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  40305e:	f04f 32ff 	mov.w	r2, #4294967295
  403062:	4b21      	ldr	r3, [pc, #132]	; (4030e8 <xTaskIncrementTick+0x118>)
  403064:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
					break;
  403068:	e7e5      	b.n	403036 <xTaskIncrementTick+0x66>
						xNextTaskUnblockTime = xItemValue;
  40306a:	4a1f      	ldr	r2, [pc, #124]	; (4030e8 <xTaskIncrementTick+0x118>)
  40306c:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
						break;
  403070:	e7e1      	b.n	403036 <xTaskIncrementTick+0x66>
					prvAddTaskToReadyList(pxTCB);
  403072:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  403076:	4649      	mov	r1, r9
  403078:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
  40307c:	4b1c      	ldr	r3, [pc, #112]	; (4030f0 <xTaskIncrementTick+0x120>)
  40307e:	4798      	blx	r3
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
  403080:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
  403084:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  403086:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
  403088:	429a      	cmp	r2, r3
  40308a:	bf28      	it	cs
  40308c:	2401      	movcs	r4, #1
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
  40308e:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
  403092:	681b      	ldr	r3, [r3, #0]
  403094:	2b00      	cmp	r3, #0
  403096:	d0e2      	beq.n	40305e <xTaskIncrementTick+0x8e>
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
  403098:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
  40309c:	68db      	ldr	r3, [r3, #12]
  40309e:	68df      	ldr	r7, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
  4030a0:	687b      	ldr	r3, [r7, #4]
					if (xConstTickCount < xItemValue) {
  4030a2:	429e      	cmp	r6, r3
  4030a4:	d3e1      	bcc.n	40306a <xTaskIncrementTick+0x9a>
					(void)uxListRemove(&(pxTCB->xStateListItem));
  4030a6:	f107 0904 	add.w	r9, r7, #4
  4030aa:	4648      	mov	r0, r9
  4030ac:	47c0      	blx	r8
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
  4030ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4030b0:	b113      	cbz	r3, 4030b8 <xTaskIncrementTick+0xe8>
						(void)uxListRemove(&(pxTCB->xEventListItem));
  4030b2:	f107 0018 	add.w	r0, r7, #24
  4030b6:	47c0      	blx	r8
					prvAddTaskToReadyList(pxTCB);
  4030b8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  4030ba:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
  4030be:	4298      	cmp	r0, r3
  4030c0:	d9d7      	bls.n	403072 <xTaskIncrementTick+0xa2>
  4030c2:	f8c5 00d4 	str.w	r0, [r5, #212]	; 0xd4
  4030c6:	e7d4      	b.n	403072 <xTaskIncrementTick+0xa2>
		++uxPendedTicks;
  4030c8:	4a07      	ldr	r2, [pc, #28]	; (4030e8 <xTaskIncrementTick+0x118>)
  4030ca:	f8d2 30e4 	ldr.w	r3, [r2, #228]	; 0xe4
  4030ce:	3301      	adds	r3, #1
  4030d0:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
	BaseType_t xSwitchRequired = pdFALSE;
  4030d4:	2400      	movs	r4, #0
		if (xYieldPending != pdFALSE) {
  4030d6:	4b04      	ldr	r3, [pc, #16]	; (4030e8 <xTaskIncrementTick+0x118>)
  4030d8:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
			xSwitchRequired = pdTRUE;
  4030dc:	2b00      	cmp	r3, #0
}
  4030de:	bf0c      	ite	eq
  4030e0:	4620      	moveq	r0, r4
  4030e2:	2001      	movne	r0, #1
  4030e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4030e8:	20400ae4 	.word	0x20400ae4
  4030ec:	00402ca5 	.word	0x00402ca5
  4030f0:	00401f2d 	.word	0x00401f2d
  4030f4:	00401f79 	.word	0x00401f79

004030f8 <xTaskResumeAll>:
	configASSERT(uxSchedulerSuspended);
  4030f8:	4b3b      	ldr	r3, [pc, #236]	; (4031e8 <xTaskResumeAll+0xf0>)
  4030fa:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
  4030fe:	b953      	cbnz	r3, 403116 <xTaskResumeAll+0x1e>
  403100:	f44f 7380 	mov.w	r3, #256	; 0x100
  403104:	b672      	cpsid	i
  403106:	f383 8811 	msr	BASEPRI, r3
  40310a:	f3bf 8f6f 	isb	sy
  40310e:	f3bf 8f4f 	dsb	sy
  403112:	b662      	cpsie	i
  403114:	e7fe      	b.n	403114 <xTaskResumeAll+0x1c>
{
  403116:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	taskENTER_CRITICAL();
  40311a:	4b34      	ldr	r3, [pc, #208]	; (4031ec <xTaskResumeAll+0xf4>)
  40311c:	4798      	blx	r3
		--uxSchedulerSuspended;
  40311e:	4b32      	ldr	r3, [pc, #200]	; (4031e8 <xTaskResumeAll+0xf0>)
  403120:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
  403124:	3a01      	subs	r2, #1
  403126:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
  40312a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
  40312e:	2b00      	cmp	r3, #0
  403130:	d155      	bne.n	4031de <xTaskResumeAll+0xe6>
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
  403132:	4b2d      	ldr	r3, [pc, #180]	; (4031e8 <xTaskResumeAll+0xf0>)
  403134:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
  403138:	b92b      	cbnz	r3, 403146 <xTaskResumeAll+0x4e>
	BaseType_t xAlreadyYielded = pdFALSE;
  40313a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
  40313c:	4b2c      	ldr	r3, [pc, #176]	; (4031f0 <xTaskResumeAll+0xf8>)
  40313e:	4798      	blx	r3
}
  403140:	4620      	mov	r0, r4
  403142:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  403146:	2500      	movs	r5, #0
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
  403148:	4c27      	ldr	r4, [pc, #156]	; (4031e8 <xTaskResumeAll+0xf0>)
					(void)uxListRemove(&(pxTCB->xEventListItem));
  40314a:	4e2a      	ldr	r6, [pc, #168]	; (4031f4 <xTaskResumeAll+0xfc>)
					prvAddTaskToReadyList(pxTCB);
  40314c:	f104 0828 	add.w	r8, r4, #40	; 0x28
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
  403150:	6963      	ldr	r3, [r4, #20]
  403152:	b1fb      	cbz	r3, 403194 <xTaskResumeAll+0x9c>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
  403154:	6a23      	ldr	r3, [r4, #32]
  403156:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
  403158:	f105 0018 	add.w	r0, r5, #24
  40315c:	47b0      	blx	r6
					(void)uxListRemove(&(pxTCB->xStateListItem));
  40315e:	1d2f      	adds	r7, r5, #4
  403160:	4638      	mov	r0, r7
  403162:	47b0      	blx	r6
					prvAddTaskToReadyList(pxTCB);
  403164:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
  403166:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
  40316a:	4298      	cmp	r0, r3
  40316c:	d901      	bls.n	403172 <xTaskResumeAll+0x7a>
  40316e:	f8c4 00d4 	str.w	r0, [r4, #212]	; 0xd4
  403172:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  403176:	4639      	mov	r1, r7
  403178:	eb08 0080 	add.w	r0, r8, r0, lsl #2
  40317c:	4b1e      	ldr	r3, [pc, #120]	; (4031f8 <xTaskResumeAll+0x100>)
  40317e:	4798      	blx	r3
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
  403180:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
  403184:	6aea      	ldr	r2, [r5, #44]	; 0x2c
  403186:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403188:	429a      	cmp	r2, r3
  40318a:	d3e1      	bcc.n	403150 <xTaskResumeAll+0x58>
						xYieldPending = pdTRUE;
  40318c:	2301      	movs	r3, #1
  40318e:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
  403192:	e7dd      	b.n	403150 <xTaskResumeAll+0x58>
				if (pxTCB != NULL) {
  403194:	b10d      	cbz	r5, 40319a <xTaskResumeAll+0xa2>
					prvResetNextTaskUnblockTime();
  403196:	4b19      	ldr	r3, [pc, #100]	; (4031fc <xTaskResumeAll+0x104>)
  403198:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
  40319a:	4b13      	ldr	r3, [pc, #76]	; (4031e8 <xTaskResumeAll+0xf0>)
  40319c:	f8d3 40e4 	ldr.w	r4, [r3, #228]	; 0xe4
					if (uxPendedCounts > (UBaseType_t)0U) {
  4031a0:	b17c      	cbz	r4, 4031c2 <xTaskResumeAll+0xca>
							if (xTaskIncrementTick() != pdFALSE) {
  4031a2:	4f17      	ldr	r7, [pc, #92]	; (403200 <xTaskResumeAll+0x108>)
								xYieldPending = pdTRUE;
  4031a4:	461e      	mov	r6, r3
  4031a6:	2501      	movs	r5, #1
  4031a8:	e001      	b.n	4031ae <xTaskResumeAll+0xb6>
						} while (uxPendedCounts > (UBaseType_t)0U);
  4031aa:	3c01      	subs	r4, #1
  4031ac:	d005      	beq.n	4031ba <xTaskResumeAll+0xc2>
							if (xTaskIncrementTick() != pdFALSE) {
  4031ae:	47b8      	blx	r7
  4031b0:	2800      	cmp	r0, #0
  4031b2:	d0fa      	beq.n	4031aa <xTaskResumeAll+0xb2>
								xYieldPending = pdTRUE;
  4031b4:	f8c6 50e8 	str.w	r5, [r6, #232]	; 0xe8
  4031b8:	e7f7      	b.n	4031aa <xTaskResumeAll+0xb2>
						uxPendedTicks = 0;
  4031ba:	2200      	movs	r2, #0
  4031bc:	4b0a      	ldr	r3, [pc, #40]	; (4031e8 <xTaskResumeAll+0xf0>)
  4031be:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
				if (xYieldPending != pdFALSE) {
  4031c2:	4b09      	ldr	r3, [pc, #36]	; (4031e8 <xTaskResumeAll+0xf0>)
  4031c4:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
  4031c8:	b15b      	cbz	r3, 4031e2 <xTaskResumeAll+0xea>
					taskYIELD_IF_USING_PREEMPTION();
  4031ca:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4031ce:	4b0d      	ldr	r3, [pc, #52]	; (403204 <xTaskResumeAll+0x10c>)
  4031d0:	601a      	str	r2, [r3, #0]
  4031d2:	f3bf 8f4f 	dsb	sy
  4031d6:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
  4031da:	2401      	movs	r4, #1
  4031dc:	e7ae      	b.n	40313c <xTaskResumeAll+0x44>
	BaseType_t xAlreadyYielded = pdFALSE;
  4031de:	2400      	movs	r4, #0
  4031e0:	e7ac      	b.n	40313c <xTaskResumeAll+0x44>
  4031e2:	2400      	movs	r4, #0
  4031e4:	e7aa      	b.n	40313c <xTaskResumeAll+0x44>
  4031e6:	bf00      	nop
  4031e8:	20400ae4 	.word	0x20400ae4
  4031ec:	00402065 	.word	0x00402065
  4031f0:	004020b1 	.word	0x004020b1
  4031f4:	00401f79 	.word	0x00401f79
  4031f8:	00401f2d 	.word	0x00401f2d
  4031fc:	00402ca5 	.word	0x00402ca5
  403200:	00402fd1 	.word	0x00402fd1
  403204:	e000ed04 	.word	0xe000ed04

00403208 <vTaskDelay>:
{
  403208:	b510      	push	{r4, lr}
	if (xTicksToDelay > (TickType_t)0U) {
  40320a:	b1c0      	cbz	r0, 40323e <vTaskDelay+0x36>
  40320c:	4604      	mov	r4, r0
		configASSERT(uxSchedulerSuspended == 0);
  40320e:	4b10      	ldr	r3, [pc, #64]	; (403250 <vTaskDelay+0x48>)
  403210:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
  403214:	b153      	cbz	r3, 40322c <vTaskDelay+0x24>
  403216:	f44f 7380 	mov.w	r3, #256	; 0x100
  40321a:	b672      	cpsid	i
  40321c:	f383 8811 	msr	BASEPRI, r3
  403220:	f3bf 8f6f 	isb	sy
  403224:	f3bf 8f4f 	dsb	sy
  403228:	b662      	cpsie	i
  40322a:	e7fe      	b.n	40322a <vTaskDelay+0x22>
		vTaskSuspendAll();
  40322c:	4b09      	ldr	r3, [pc, #36]	; (403254 <vTaskDelay+0x4c>)
  40322e:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
  403230:	2100      	movs	r1, #0
  403232:	4620      	mov	r0, r4
  403234:	4b08      	ldr	r3, [pc, #32]	; (403258 <vTaskDelay+0x50>)
  403236:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
  403238:	4b08      	ldr	r3, [pc, #32]	; (40325c <vTaskDelay+0x54>)
  40323a:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
  40323c:	b938      	cbnz	r0, 40324e <vTaskDelay+0x46>
		portYIELD_WITHIN_API();
  40323e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  403242:	4b07      	ldr	r3, [pc, #28]	; (403260 <vTaskDelay+0x58>)
  403244:	601a      	str	r2, [r3, #0]
  403246:	f3bf 8f4f 	dsb	sy
  40324a:	f3bf 8f6f 	isb	sy
  40324e:	bd10      	pop	{r4, pc}
  403250:	20400ae4 	.word	0x20400ae4
  403254:	00402fb1 	.word	0x00402fb1
  403258:	00402cd1 	.word	0x00402cd1
  40325c:	004030f9 	.word	0x004030f9
  403260:	e000ed04 	.word	0xe000ed04

00403264 <vTaskSwitchContext>:
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
  403264:	4b27      	ldr	r3, [pc, #156]	; (403304 <vTaskSwitchContext+0xa0>)
  403266:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
  40326a:	bb1b      	cbnz	r3, 4032b4 <vTaskSwitchContext+0x50>
		xYieldPending = pdFALSE;
  40326c:	4a25      	ldr	r2, [pc, #148]	; (403304 <vTaskSwitchContext+0xa0>)
  40326e:	2300      	movs	r3, #0
  403270:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
		taskSELECT_HIGHEST_PRIORITY_TASK();
  403274:	f8d2 30d4 	ldr.w	r3, [r2, #212]	; 0xd4
  403278:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  40327c:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  403280:	6a92      	ldr	r2, [r2, #40]	; 0x28
  403282:	b9e2      	cbnz	r2, 4032be <vTaskSwitchContext+0x5a>
  403284:	b15b      	cbz	r3, 40329e <vTaskSwitchContext+0x3a>
  403286:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  40328a:	4a1f      	ldr	r2, [pc, #124]	; (403308 <vTaskSwitchContext+0xa4>)
  40328c:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  403290:	3b01      	subs	r3, #1
  403292:	f852 1c14 	ldr.w	r1, [r2, #-20]
  403296:	b991      	cbnz	r1, 4032be <vTaskSwitchContext+0x5a>
  403298:	3a14      	subs	r2, #20
  40329a:	2b00      	cmp	r3, #0
  40329c:	d1f8      	bne.n	403290 <vTaskSwitchContext+0x2c>
  40329e:	f44f 7380 	mov.w	r3, #256	; 0x100
  4032a2:	b672      	cpsid	i
  4032a4:	f383 8811 	msr	BASEPRI, r3
  4032a8:	f3bf 8f6f 	isb	sy
  4032ac:	f3bf 8f4f 	dsb	sy
  4032b0:	b662      	cpsie	i
  4032b2:	e7fe      	b.n	4032b2 <vTaskSwitchContext+0x4e>
		xYieldPending = pdTRUE;
  4032b4:	2201      	movs	r2, #1
  4032b6:	4b13      	ldr	r3, [pc, #76]	; (403304 <vTaskSwitchContext+0xa0>)
  4032b8:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
  4032bc:	4770      	bx	lr
{
  4032be:	b410      	push	{r4}
		taskSELECT_HIGHEST_PRIORITY_TASK();
  4032c0:	4a10      	ldr	r2, [pc, #64]	; (403304 <vTaskSwitchContext+0xa0>)
  4032c2:	0099      	lsls	r1, r3, #2
  4032c4:	18c8      	adds	r0, r1, r3
  4032c6:	eb02 0080 	add.w	r0, r2, r0, lsl #2
  4032ca:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
  4032cc:	6864      	ldr	r4, [r4, #4]
  4032ce:	62c4      	str	r4, [r0, #44]	; 0x2c
  4032d0:	4419      	add	r1, r3
  4032d2:	4602      	mov	r2, r0
  4032d4:	3230      	adds	r2, #48	; 0x30
  4032d6:	4294      	cmp	r4, r2
  4032d8:	d00d      	beq.n	4032f6 <vTaskSwitchContext+0x92>
  4032da:	4a0a      	ldr	r2, [pc, #40]	; (403304 <vTaskSwitchContext+0xa0>)
  4032dc:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  4032e0:	eb02 0181 	add.w	r1, r2, r1, lsl #2
  4032e4:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  4032e6:	68c9      	ldr	r1, [r1, #12]
  4032e8:	f8c2 1098 	str.w	r1, [r2, #152]	; 0x98
  4032ec:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
}
  4032f0:	f85d 4b04 	ldr.w	r4, [sp], #4
  4032f4:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK();
  4032f6:	6860      	ldr	r0, [r4, #4]
  4032f8:	4a02      	ldr	r2, [pc, #8]	; (403304 <vTaskSwitchContext+0xa0>)
  4032fa:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  4032fe:	62d0      	str	r0, [r2, #44]	; 0x2c
  403300:	e7eb      	b.n	4032da <vTaskSwitchContext+0x76>
  403302:	bf00      	nop
  403304:	20400ae4 	.word	0x20400ae4
  403308:	20400b0c 	.word	0x20400b0c

0040330c <vTaskPlaceOnEventList>:
	configASSERT(pxEventList);
  40330c:	b950      	cbnz	r0, 403324 <vTaskPlaceOnEventList+0x18>
  40330e:	f44f 7380 	mov.w	r3, #256	; 0x100
  403312:	b672      	cpsid	i
  403314:	f383 8811 	msr	BASEPRI, r3
  403318:	f3bf 8f6f 	isb	sy
  40331c:	f3bf 8f4f 	dsb	sy
  403320:	b662      	cpsie	i
  403322:	e7fe      	b.n	403322 <vTaskPlaceOnEventList+0x16>
{
  403324:	b510      	push	{r4, lr}
  403326:	460c      	mov	r4, r1
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
  403328:	4b05      	ldr	r3, [pc, #20]	; (403340 <vTaskPlaceOnEventList+0x34>)
  40332a:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
  40332e:	3118      	adds	r1, #24
  403330:	4b04      	ldr	r3, [pc, #16]	; (403344 <vTaskPlaceOnEventList+0x38>)
  403332:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
  403334:	2101      	movs	r1, #1
  403336:	4620      	mov	r0, r4
  403338:	4b03      	ldr	r3, [pc, #12]	; (403348 <vTaskPlaceOnEventList+0x3c>)
  40333a:	4798      	blx	r3
  40333c:	bd10      	pop	{r4, pc}
  40333e:	bf00      	nop
  403340:	20400ae4 	.word	0x20400ae4
  403344:	00401f45 	.word	0x00401f45
  403348:	00402cd1 	.word	0x00402cd1

0040334c <vTaskPlaceOnEventListRestricted>:
{
  40334c:	b538      	push	{r3, r4, r5, lr}
	configASSERT(pxEventList);
  40334e:	b180      	cbz	r0, 403372 <vTaskPlaceOnEventListRestricted+0x26>
  403350:	4614      	mov	r4, r2
  403352:	460d      	mov	r5, r1
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
  403354:	4b0c      	ldr	r3, [pc, #48]	; (403388 <vTaskPlaceOnEventListRestricted+0x3c>)
  403356:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
  40335a:	3118      	adds	r1, #24
  40335c:	4b0b      	ldr	r3, [pc, #44]	; (40338c <vTaskPlaceOnEventListRestricted+0x40>)
  40335e:	4798      	blx	r3
		xTicksToWait = portMAX_DELAY;
  403360:	2c00      	cmp	r4, #0
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
  403362:	4621      	mov	r1, r4
  403364:	bf0c      	ite	eq
  403366:	4628      	moveq	r0, r5
  403368:	f04f 30ff 	movne.w	r0, #4294967295
  40336c:	4b08      	ldr	r3, [pc, #32]	; (403390 <vTaskPlaceOnEventListRestricted+0x44>)
  40336e:	4798      	blx	r3
  403370:	bd38      	pop	{r3, r4, r5, pc}
  403372:	f44f 7380 	mov.w	r3, #256	; 0x100
  403376:	b672      	cpsid	i
  403378:	f383 8811 	msr	BASEPRI, r3
  40337c:	f3bf 8f6f 	isb	sy
  403380:	f3bf 8f4f 	dsb	sy
  403384:	b662      	cpsie	i
  403386:	e7fe      	b.n	403386 <vTaskPlaceOnEventListRestricted+0x3a>
  403388:	20400ae4 	.word	0x20400ae4
  40338c:	00401f2d 	.word	0x00401f2d
  403390:	00402cd1 	.word	0x00402cd1

00403394 <xTaskRemoveFromEventList>:
{
  403394:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
  403396:	68c3      	ldr	r3, [r0, #12]
  403398:	68dc      	ldr	r4, [r3, #12]
	configASSERT(pxUnblockedTCB);
  40339a:	b34c      	cbz	r4, 4033f0 <xTaskRemoveFromEventList+0x5c>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
  40339c:	f104 0518 	add.w	r5, r4, #24
  4033a0:	4628      	mov	r0, r5
  4033a2:	4b1c      	ldr	r3, [pc, #112]	; (403414 <xTaskRemoveFromEventList+0x80>)
  4033a4:	4798      	blx	r3
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
  4033a6:	4b1c      	ldr	r3, [pc, #112]	; (403418 <xTaskRemoveFromEventList+0x84>)
  4033a8:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
  4033ac:	bb5b      	cbnz	r3, 403406 <xTaskRemoveFromEventList+0x72>
		(void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
  4033ae:	1d25      	adds	r5, r4, #4
  4033b0:	4628      	mov	r0, r5
  4033b2:	4b18      	ldr	r3, [pc, #96]	; (403414 <xTaskRemoveFromEventList+0x80>)
  4033b4:	4798      	blx	r3
		prvAddTaskToReadyList(pxUnblockedTCB);
  4033b6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  4033b8:	4b17      	ldr	r3, [pc, #92]	; (403418 <xTaskRemoveFromEventList+0x84>)
  4033ba:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
  4033be:	4298      	cmp	r0, r3
  4033c0:	d902      	bls.n	4033c8 <xTaskRemoveFromEventList+0x34>
  4033c2:	4b15      	ldr	r3, [pc, #84]	; (403418 <xTaskRemoveFromEventList+0x84>)
  4033c4:	f8c3 00d4 	str.w	r0, [r3, #212]	; 0xd4
  4033c8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  4033cc:	4629      	mov	r1, r5
  4033ce:	4b13      	ldr	r3, [pc, #76]	; (40341c <xTaskRemoveFromEventList+0x88>)
  4033d0:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  4033d4:	4b12      	ldr	r3, [pc, #72]	; (403420 <xTaskRemoveFromEventList+0x8c>)
  4033d6:	4798      	blx	r3
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
  4033d8:	4b0f      	ldr	r3, [pc, #60]	; (403418 <xTaskRemoveFromEventList+0x84>)
  4033da:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  4033de:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  4033e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4033e2:	429a      	cmp	r2, r3
  4033e4:	d914      	bls.n	403410 <xTaskRemoveFromEventList+0x7c>
		xYieldPending = pdTRUE;
  4033e6:	2001      	movs	r0, #1
  4033e8:	4b0b      	ldr	r3, [pc, #44]	; (403418 <xTaskRemoveFromEventList+0x84>)
  4033ea:	f8c3 00e8 	str.w	r0, [r3, #232]	; 0xe8
  4033ee:	bd38      	pop	{r3, r4, r5, pc}
  4033f0:	f44f 7380 	mov.w	r3, #256	; 0x100
  4033f4:	b672      	cpsid	i
  4033f6:	f383 8811 	msr	BASEPRI, r3
  4033fa:	f3bf 8f6f 	isb	sy
  4033fe:	f3bf 8f4f 	dsb	sy
  403402:	b662      	cpsie	i
  403404:	e7fe      	b.n	403404 <xTaskRemoveFromEventList+0x70>
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
  403406:	4629      	mov	r1, r5
  403408:	4806      	ldr	r0, [pc, #24]	; (403424 <xTaskRemoveFromEventList+0x90>)
  40340a:	4b05      	ldr	r3, [pc, #20]	; (403420 <xTaskRemoveFromEventList+0x8c>)
  40340c:	4798      	blx	r3
  40340e:	e7e3      	b.n	4033d8 <xTaskRemoveFromEventList+0x44>
		xReturn = pdFALSE;
  403410:	2000      	movs	r0, #0
}
  403412:	bd38      	pop	{r3, r4, r5, pc}
  403414:	00401f79 	.word	0x00401f79
  403418:	20400ae4 	.word	0x20400ae4
  40341c:	20400b0c 	.word	0x20400b0c
  403420:	00401f2d 	.word	0x00401f2d
  403424:	20400af8 	.word	0x20400af8

00403428 <vTaskSetTimeOutState>:
	configASSERT(pxTimeOut);
  403428:	b138      	cbz	r0, 40343a <vTaskSetTimeOutState+0x12>
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
  40342a:	4a09      	ldr	r2, [pc, #36]	; (403450 <vTaskSetTimeOutState+0x28>)
  40342c:	f8d2 10e0 	ldr.w	r1, [r2, #224]	; 0xe0
  403430:	6001      	str	r1, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  403432:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
  403436:	6042      	str	r2, [r0, #4]
  403438:	4770      	bx	lr
  40343a:	f44f 7380 	mov.w	r3, #256	; 0x100
  40343e:	b672      	cpsid	i
  403440:	f383 8811 	msr	BASEPRI, r3
  403444:	f3bf 8f6f 	isb	sy
  403448:	f3bf 8f4f 	dsb	sy
  40344c:	b662      	cpsie	i
  40344e:	e7fe      	b.n	40344e <vTaskSetTimeOutState+0x26>
  403450:	20400ae4 	.word	0x20400ae4

00403454 <xTaskCheckForTimeOut>:
{
  403454:	b538      	push	{r3, r4, r5, lr}
	configASSERT(pxTimeOut);
  403456:	b1d0      	cbz	r0, 40348e <xTaskCheckForTimeOut+0x3a>
  403458:	4604      	mov	r4, r0
	configASSERT(pxTicksToWait);
  40345a:	b319      	cbz	r1, 4034a4 <xTaskCheckForTimeOut+0x50>
  40345c:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
  40345e:	4b1e      	ldr	r3, [pc, #120]	; (4034d8 <xTaskCheckForTimeOut+0x84>)
  403460:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
  403462:	4b1e      	ldr	r3, [pc, #120]	; (4034dc <xTaskCheckForTimeOut+0x88>)
  403464:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
		    if (*pxTicksToWait == portMAX_DELAY) {
  403468:	682b      	ldr	r3, [r5, #0]
  40346a:	f1b3 3fff 	cmp.w	r3, #4294967295
  40346e:	d02f      	beq.n	4034d0 <xTaskCheckForTimeOut+0x7c>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
  403470:	491a      	ldr	r1, [pc, #104]	; (4034dc <xTaskCheckForTimeOut+0x88>)
  403472:	f8d1 10e0 	ldr.w	r1, [r1, #224]	; 0xe0
  403476:	6820      	ldr	r0, [r4, #0]
  403478:	4288      	cmp	r0, r1
  40347a:	d002      	beq.n	403482 <xTaskCheckForTimeOut+0x2e>
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
  40347c:	6861      	ldr	r1, [r4, #4]
  40347e:	428a      	cmp	r2, r1
  403480:	d228      	bcs.n	4034d4 <xTaskCheckForTimeOut+0x80>
		    ((TickType_t)(xConstTickCount - pxTimeOut->xTimeOnEntering))
  403482:	6861      	ldr	r1, [r4, #4]
  403484:	1a50      	subs	r0, r2, r1
		} else if (
  403486:	4283      	cmp	r3, r0
  403488:	d817      	bhi.n	4034ba <xTaskCheckForTimeOut+0x66>
			xReturn = pdTRUE;
  40348a:	2401      	movs	r4, #1
  40348c:	e01c      	b.n	4034c8 <xTaskCheckForTimeOut+0x74>
  40348e:	f44f 7380 	mov.w	r3, #256	; 0x100
  403492:	b672      	cpsid	i
  403494:	f383 8811 	msr	BASEPRI, r3
  403498:	f3bf 8f6f 	isb	sy
  40349c:	f3bf 8f4f 	dsb	sy
  4034a0:	b662      	cpsie	i
  4034a2:	e7fe      	b.n	4034a2 <xTaskCheckForTimeOut+0x4e>
  4034a4:	f44f 7380 	mov.w	r3, #256	; 0x100
  4034a8:	b672      	cpsid	i
  4034aa:	f383 8811 	msr	BASEPRI, r3
  4034ae:	f3bf 8f6f 	isb	sy
  4034b2:	f3bf 8f4f 	dsb	sy
  4034b6:	b662      	cpsie	i
  4034b8:	e7fe      	b.n	4034b8 <xTaskCheckForTimeOut+0x64>
			*pxTicksToWait -= (xConstTickCount - pxTimeOut->xTimeOnEntering);
  4034ba:	1a9b      	subs	r3, r3, r2
  4034bc:	440b      	add	r3, r1
  4034be:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState(pxTimeOut);
  4034c0:	4620      	mov	r0, r4
  4034c2:	4b07      	ldr	r3, [pc, #28]	; (4034e0 <xTaskCheckForTimeOut+0x8c>)
  4034c4:	4798      	blx	r3
			xReturn = pdFALSE;
  4034c6:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
  4034c8:	4b06      	ldr	r3, [pc, #24]	; (4034e4 <xTaskCheckForTimeOut+0x90>)
  4034ca:	4798      	blx	r3
}
  4034cc:	4620      	mov	r0, r4
  4034ce:	bd38      	pop	{r3, r4, r5, pc}
			xReturn = pdFALSE;
  4034d0:	2400      	movs	r4, #0
  4034d2:	e7f9      	b.n	4034c8 <xTaskCheckForTimeOut+0x74>
			xReturn = pdTRUE;
  4034d4:	2401      	movs	r4, #1
  4034d6:	e7f7      	b.n	4034c8 <xTaskCheckForTimeOut+0x74>
  4034d8:	00402065 	.word	0x00402065
  4034dc:	20400ae4 	.word	0x20400ae4
  4034e0:	00403429 	.word	0x00403429
  4034e4:	004020b1 	.word	0x004020b1

004034e8 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
  4034e8:	2201      	movs	r2, #1
  4034ea:	4b02      	ldr	r3, [pc, #8]	; (4034f4 <vTaskMissedYield+0xc>)
  4034ec:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
  4034f0:	4770      	bx	lr
  4034f2:	bf00      	nop
  4034f4:	20400ae4 	.word	0x20400ae4

004034f8 <xTaskGetSchedulerState>:
	if (xSchedulerRunning == pdFALSE) {
  4034f8:	4b06      	ldr	r3, [pc, #24]	; (403514 <xTaskGetSchedulerState+0x1c>)
  4034fa:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
  4034fe:	b13b      	cbz	r3, 403510 <xTaskGetSchedulerState+0x18>
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
  403500:	4b04      	ldr	r3, [pc, #16]	; (403514 <xTaskGetSchedulerState+0x1c>)
  403502:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
			xReturn = taskSCHEDULER_SUSPENDED;
  403506:	2b00      	cmp	r3, #0
  403508:	bf0c      	ite	eq
  40350a:	2002      	moveq	r0, #2
  40350c:	2000      	movne	r0, #0
  40350e:	4770      	bx	lr
		xReturn = taskSCHEDULER_NOT_STARTED;
  403510:	2001      	movs	r0, #1
}
  403512:	4770      	bx	lr
  403514:	20400ae4 	.word	0x20400ae4

00403518 <vTaskPriorityInherit>:
	if (pxMutexHolder != NULL) {
  403518:	2800      	cmp	r0, #0
  40351a:	d039      	beq.n	403590 <vTaskPriorityInherit+0x78>
{
  40351c:	b538      	push	{r3, r4, r5, lr}
  40351e:	4605      	mov	r5, r0
		if (pxTCB->uxPriority < pxCurrentTCB->uxPriority) {
  403520:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  403522:	491c      	ldr	r1, [pc, #112]	; (403594 <vTaskPriorityInherit+0x7c>)
  403524:	f8d1 1098 	ldr.w	r1, [r1, #152]	; 0x98
  403528:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  40352a:	428a      	cmp	r2, r1
  40352c:	d216      	bcs.n	40355c <vTaskPriorityInherit+0x44>
			if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL) {
  40352e:	6981      	ldr	r1, [r0, #24]
  403530:	2900      	cmp	r1, #0
  403532:	db06      	blt.n	403542 <vTaskPriorityInherit+0x2a>
				listSET_LIST_ITEM_VALUE(
  403534:	4917      	ldr	r1, [pc, #92]	; (403594 <vTaskPriorityInherit+0x7c>)
  403536:	f8d1 1098 	ldr.w	r1, [r1, #152]	; 0x98
  40353a:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  40353c:	f1c1 0105 	rsb	r1, r1, #5
  403540:	6181      	str	r1, [r0, #24]
			if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[pxTCB->uxPriority]), &(pxTCB->xStateListItem)) != pdFALSE) {
  403542:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  403546:	4914      	ldr	r1, [pc, #80]	; (403598 <vTaskPriorityInherit+0x80>)
  403548:	eb01 0282 	add.w	r2, r1, r2, lsl #2
  40354c:	6969      	ldr	r1, [r5, #20]
  40354e:	4291      	cmp	r1, r2
  403550:	d005      	beq.n	40355e <vTaskPriorityInherit+0x46>
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  403552:	4a10      	ldr	r2, [pc, #64]	; (403594 <vTaskPriorityInherit+0x7c>)
  403554:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
  403558:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  40355a:	62ea      	str	r2, [r5, #44]	; 0x2c
  40355c:	bd38      	pop	{r3, r4, r5, pc}
				if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
  40355e:	1d2c      	adds	r4, r5, #4
  403560:	4620      	mov	r0, r4
  403562:	4b0e      	ldr	r3, [pc, #56]	; (40359c <vTaskPriorityInherit+0x84>)
  403564:	4798      	blx	r3
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  403566:	4b0b      	ldr	r3, [pc, #44]	; (403594 <vTaskPriorityInherit+0x7c>)
  403568:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
  40356c:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
  40356e:	62e8      	str	r0, [r5, #44]	; 0x2c
				prvAddTaskToReadyList(pxTCB);
  403570:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
  403574:	4298      	cmp	r0, r3
  403576:	d902      	bls.n	40357e <vTaskPriorityInherit+0x66>
  403578:	4b06      	ldr	r3, [pc, #24]	; (403594 <vTaskPriorityInherit+0x7c>)
  40357a:	f8c3 00d4 	str.w	r0, [r3, #212]	; 0xd4
  40357e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  403582:	4621      	mov	r1, r4
  403584:	4b04      	ldr	r3, [pc, #16]	; (403598 <vTaskPriorityInherit+0x80>)
  403586:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  40358a:	4b05      	ldr	r3, [pc, #20]	; (4035a0 <vTaskPriorityInherit+0x88>)
  40358c:	4798      	blx	r3
  40358e:	bd38      	pop	{r3, r4, r5, pc}
  403590:	4770      	bx	lr
  403592:	bf00      	nop
  403594:	20400ae4 	.word	0x20400ae4
  403598:	20400b0c 	.word	0x20400b0c
  40359c:	00401f79 	.word	0x00401f79
  4035a0:	00401f2d 	.word	0x00401f2d

004035a4 <xTaskPriorityDisinherit>:
	if (pxMutexHolder != NULL) {
  4035a4:	2800      	cmp	r0, #0
  4035a6:	d040      	beq.n	40362a <xTaskPriorityDisinherit+0x86>
{
  4035a8:	b538      	push	{r3, r4, r5, lr}
  4035aa:	4604      	mov	r4, r0
		configASSERT(pxTCB == pxCurrentTCB);
  4035ac:	4a21      	ldr	r2, [pc, #132]	; (403634 <xTaskPriorityDisinherit+0x90>)
  4035ae:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
  4035b2:	4290      	cmp	r0, r2
  4035b4:	d00a      	beq.n	4035cc <xTaskPriorityDisinherit+0x28>
  4035b6:	f44f 7380 	mov.w	r3, #256	; 0x100
  4035ba:	b672      	cpsid	i
  4035bc:	f383 8811 	msr	BASEPRI, r3
  4035c0:	f3bf 8f6f 	isb	sy
  4035c4:	f3bf 8f4f 	dsb	sy
  4035c8:	b662      	cpsie	i
  4035ca:	e7fe      	b.n	4035ca <xTaskPriorityDisinherit+0x26>
		configASSERT(pxTCB->uxMutexesHeld);
  4035cc:	6c82      	ldr	r2, [r0, #72]	; 0x48
  4035ce:	b952      	cbnz	r2, 4035e6 <xTaskPriorityDisinherit+0x42>
  4035d0:	f44f 7380 	mov.w	r3, #256	; 0x100
  4035d4:	b672      	cpsid	i
  4035d6:	f383 8811 	msr	BASEPRI, r3
  4035da:	f3bf 8f6f 	isb	sy
  4035de:	f3bf 8f4f 	dsb	sy
  4035e2:	b662      	cpsie	i
  4035e4:	e7fe      	b.n	4035e4 <xTaskPriorityDisinherit+0x40>
		(pxTCB->uxMutexesHeld)--;
  4035e6:	3a01      	subs	r2, #1
  4035e8:	6482      	str	r2, [r0, #72]	; 0x48
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
  4035ea:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
  4035ec:	6c61      	ldr	r1, [r4, #68]	; 0x44
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
  4035ee:	4288      	cmp	r0, r1
  4035f0:	d01d      	beq.n	40362e <xTaskPriorityDisinherit+0x8a>
  4035f2:	b9e2      	cbnz	r2, 40362e <xTaskPriorityDisinherit+0x8a>
				if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
  4035f4:	1d25      	adds	r5, r4, #4
  4035f6:	4628      	mov	r0, r5
  4035f8:	4b0f      	ldr	r3, [pc, #60]	; (403638 <xTaskPriorityDisinherit+0x94>)
  4035fa:	4798      	blx	r3
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  4035fc:	6c60      	ldr	r0, [r4, #68]	; 0x44
  4035fe:	62e0      	str	r0, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE(
  403600:	f1c0 0305 	rsb	r3, r0, #5
  403604:	61a3      	str	r3, [r4, #24]
				prvAddTaskToReadyList(pxTCB);
  403606:	4b0b      	ldr	r3, [pc, #44]	; (403634 <xTaskPriorityDisinherit+0x90>)
  403608:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
  40360c:	4298      	cmp	r0, r3
  40360e:	d902      	bls.n	403616 <xTaskPriorityDisinherit+0x72>
  403610:	4b08      	ldr	r3, [pc, #32]	; (403634 <xTaskPriorityDisinherit+0x90>)
  403612:	f8c3 00d4 	str.w	r0, [r3, #212]	; 0xd4
  403616:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  40361a:	4629      	mov	r1, r5
  40361c:	4b07      	ldr	r3, [pc, #28]	; (40363c <xTaskPriorityDisinherit+0x98>)
  40361e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  403622:	4b07      	ldr	r3, [pc, #28]	; (403640 <xTaskPriorityDisinherit+0x9c>)
  403624:	4798      	blx	r3
				xReturn = pdTRUE;
  403626:	2001      	movs	r0, #1
  403628:	bd38      	pop	{r3, r4, r5, pc}
	BaseType_t   xReturn = pdFALSE;
  40362a:	2000      	movs	r0, #0
  40362c:	4770      	bx	lr
  40362e:	2000      	movs	r0, #0
}
  403630:	bd38      	pop	{r3, r4, r5, pc}
  403632:	bf00      	nop
  403634:	20400ae4 	.word	0x20400ae4
  403638:	00401f79 	.word	0x00401f79
  40363c:	20400b0c 	.word	0x20400b0c
  403640:	00401f2d 	.word	0x00401f2d

00403644 <pvTaskIncrementMutexHeldCount>:
	if (pxCurrentTCB != NULL) {
  403644:	4b06      	ldr	r3, [pc, #24]	; (403660 <pvTaskIncrementMutexHeldCount+0x1c>)
  403646:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  40364a:	b12b      	cbz	r3, 403658 <pvTaskIncrementMutexHeldCount+0x14>
		(pxCurrentTCB->uxMutexesHeld)++;
  40364c:	4b04      	ldr	r3, [pc, #16]	; (403660 <pvTaskIncrementMutexHeldCount+0x1c>)
  40364e:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
  403652:	6c93      	ldr	r3, [r2, #72]	; 0x48
  403654:	3301      	adds	r3, #1
  403656:	6493      	str	r3, [r2, #72]	; 0x48
	return pxCurrentTCB;
  403658:	4b01      	ldr	r3, [pc, #4]	; (403660 <pvTaskIncrementMutexHeldCount+0x1c>)
  40365a:	f8d3 0098 	ldr.w	r0, [r3, #152]	; 0x98
}
  40365e:	4770      	bx	lr
  403660:	20400ae4 	.word	0x20400ae4

00403664 <prvInsertTimerInActiveList>:
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList(Timer_t *const pxTimer, const TickType_t xNextExpiryTime,
                                             const TickType_t xTimeNow, const TickType_t xCommandTime)
{
  403664:	b508      	push	{r3, lr}
	BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
  403666:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
  403668:	6100      	str	r0, [r0, #16]

	if (xNextExpiryTime <= xTimeNow) {
  40366a:	4291      	cmp	r1, r2
  40366c:	d80c      	bhi.n	403688 <prvInsertTimerInActiveList+0x24>
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if (((TickType_t)(xTimeNow - xCommandTime))
  40366e:	1ad2      	subs	r2, r2, r3
  403670:	6983      	ldr	r3, [r0, #24]
  403672:	429a      	cmp	r2, r3
  403674:	d301      	bcc.n	40367a <prvInsertTimerInActiveList+0x16>
		    >= pxTimer->xTimerPeriodInTicks) /*lint !e961 MISRA exception as the casts are only redundant for some
		                                        ports. */
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
  403676:	2001      	movs	r0, #1
  403678:	bd08      	pop	{r3, pc}
		} else {
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
  40367a:	1d01      	adds	r1, r0, #4
  40367c:	4b09      	ldr	r3, [pc, #36]	; (4036a4 <prvInsertTimerInActiveList+0x40>)
  40367e:	6818      	ldr	r0, [r3, #0]
  403680:	4b09      	ldr	r3, [pc, #36]	; (4036a8 <prvInsertTimerInActiveList+0x44>)
  403682:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
  403684:	2000      	movs	r0, #0
  403686:	bd08      	pop	{r3, pc}
		}
	} else {
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
  403688:	429a      	cmp	r2, r3
  40368a:	d203      	bcs.n	403694 <prvInsertTimerInActiveList+0x30>
  40368c:	4299      	cmp	r1, r3
  40368e:	d301      	bcc.n	403694 <prvInsertTimerInActiveList+0x30>
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
  403690:	2001      	movs	r0, #1
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
		}
	}

	return xProcessTimerNow;
}
  403692:	bd08      	pop	{r3, pc}
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
  403694:	1d01      	adds	r1, r0, #4
  403696:	4b03      	ldr	r3, [pc, #12]	; (4036a4 <prvInsertTimerInActiveList+0x40>)
  403698:	6858      	ldr	r0, [r3, #4]
  40369a:	4b03      	ldr	r3, [pc, #12]	; (4036a8 <prvInsertTimerInActiveList+0x44>)
  40369c:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
  40369e:	2000      	movs	r0, #0
  4036a0:	bd08      	pop	{r3, pc}
  4036a2:	bf00      	nop
  4036a4:	20400bd0 	.word	0x20400bd0
  4036a8:	00401f45 	.word	0x00401f45

004036ac <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
  4036ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
  4036ae:	4b0d      	ldr	r3, [pc, #52]	; (4036e4 <prvCheckForValidListAndQueue+0x38>)
  4036b0:	4798      	blx	r3
	{
		if (xTimerQueue == NULL) {
  4036b2:	4b0d      	ldr	r3, [pc, #52]	; (4036e8 <prvCheckForValidListAndQueue+0x3c>)
  4036b4:	689b      	ldr	r3, [r3, #8]
  4036b6:	b113      	cbz	r3, 4036be <prvCheckForValidListAndQueue+0x12>
#endif /* configQUEUE_REGISTRY_SIZE */
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
  4036b8:	4b0c      	ldr	r3, [pc, #48]	; (4036ec <prvCheckForValidListAndQueue+0x40>)
  4036ba:	4798      	blx	r3
  4036bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInitialise(&xActiveTimerList1);
  4036be:	4c0a      	ldr	r4, [pc, #40]	; (4036e8 <prvCheckForValidListAndQueue+0x3c>)
  4036c0:	f104 060c 	add.w	r6, r4, #12
  4036c4:	4630      	mov	r0, r6
  4036c6:	4f0a      	ldr	r7, [pc, #40]	; (4036f0 <prvCheckForValidListAndQueue+0x44>)
  4036c8:	47b8      	blx	r7
			vListInitialise(&xActiveTimerList2);
  4036ca:	f104 0520 	add.w	r5, r4, #32
  4036ce:	4628      	mov	r0, r5
  4036d0:	47b8      	blx	r7
			pxCurrentTimerList  = &xActiveTimerList1;
  4036d2:	6066      	str	r6, [r4, #4]
			pxOverflowTimerList = &xActiveTimerList2;
  4036d4:	6025      	str	r5, [r4, #0]
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
  4036d6:	2200      	movs	r2, #0
  4036d8:	210c      	movs	r1, #12
  4036da:	2002      	movs	r0, #2
  4036dc:	4b05      	ldr	r3, [pc, #20]	; (4036f4 <prvCheckForValidListAndQueue+0x48>)
  4036de:	4798      	blx	r3
  4036e0:	60a0      	str	r0, [r4, #8]
  4036e2:	e7e9      	b.n	4036b8 <prvCheckForValidListAndQueue+0xc>
  4036e4:	00402065 	.word	0x00402065
  4036e8:	20400bd0 	.word	0x20400bd0
  4036ec:	004020b1 	.word	0x004020b1
  4036f0:	00401f11 	.word	0x00401f11
  4036f4:	00402595 	.word	0x00402595

004036f8 <xTimerCreateTimerTask>:
{
  4036f8:	b510      	push	{r4, lr}
  4036fa:	b082      	sub	sp, #8
	prvCheckForValidListAndQueue();
  4036fc:	4b0e      	ldr	r3, [pc, #56]	; (403738 <xTimerCreateTimerTask+0x40>)
  4036fe:	4798      	blx	r3
	if (xTimerQueue != NULL) {
  403700:	4b0e      	ldr	r3, [pc, #56]	; (40373c <xTimerCreateTimerTask+0x44>)
  403702:	689b      	ldr	r3, [r3, #8]
  403704:	b163      	cbz	r3, 403720 <xTimerCreateTimerTask+0x28>
			xReturn = xTaskCreate(prvTimerTask,
  403706:	4b0e      	ldr	r3, [pc, #56]	; (403740 <xTimerCreateTimerTask+0x48>)
  403708:	9301      	str	r3, [sp, #4]
  40370a:	2302      	movs	r3, #2
  40370c:	9300      	str	r3, [sp, #0]
  40370e:	2300      	movs	r3, #0
  403710:	2240      	movs	r2, #64	; 0x40
  403712:	490c      	ldr	r1, [pc, #48]	; (403744 <xTimerCreateTimerTask+0x4c>)
  403714:	480c      	ldr	r0, [pc, #48]	; (403748 <xTimerCreateTimerTask+0x50>)
  403716:	4c0d      	ldr	r4, [pc, #52]	; (40374c <xTimerCreateTimerTask+0x54>)
  403718:	47a0      	blx	r4
	configASSERT(xReturn);
  40371a:	b108      	cbz	r0, 403720 <xTimerCreateTimerTask+0x28>
}
  40371c:	b002      	add	sp, #8
  40371e:	bd10      	pop	{r4, pc}
  403720:	f44f 7380 	mov.w	r3, #256	; 0x100
  403724:	b672      	cpsid	i
  403726:	f383 8811 	msr	BASEPRI, r3
  40372a:	f3bf 8f6f 	isb	sy
  40372e:	f3bf 8f4f 	dsb	sy
  403732:	b662      	cpsie	i
  403734:	e7fe      	b.n	403734 <xTimerCreateTimerTask+0x3c>
  403736:	bf00      	nop
  403738:	004036ad 	.word	0x004036ad
  40373c:	20400bd0 	.word	0x20400bd0
  403740:	20400c04 	.word	0x20400c04
  403744:	004045d0 	.word	0x004045d0
  403748:	00403871 	.word	0x00403871
  40374c:	00402d4d 	.word	0x00402d4d

00403750 <xTimerGenericCommand>:
	configASSERT(xTimer);
  403750:	b1d8      	cbz	r0, 40378a <xTimerGenericCommand+0x3a>
{
  403752:	b530      	push	{r4, r5, lr}
  403754:	b085      	sub	sp, #20
  403756:	4615      	mov	r5, r2
  403758:	4604      	mov	r4, r0
	if (xTimerQueue != NULL) {
  40375a:	4a15      	ldr	r2, [pc, #84]	; (4037b0 <xTimerGenericCommand+0x60>)
  40375c:	6890      	ldr	r0, [r2, #8]
  40375e:	b320      	cbz	r0, 4037aa <xTimerGenericCommand+0x5a>
  403760:	461a      	mov	r2, r3
		xMessage.xMessageID                       = xCommandID;
  403762:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
  403764:	9502      	str	r5, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
  403766:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
  403768:	2905      	cmp	r1, #5
  40376a:	dc19      	bgt.n	4037a0 <xTimerGenericCommand+0x50>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
  40376c:	4b11      	ldr	r3, [pc, #68]	; (4037b4 <xTimerGenericCommand+0x64>)
  40376e:	4798      	blx	r3
  403770:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
  403772:	f04f 0300 	mov.w	r3, #0
  403776:	bf0c      	ite	eq
  403778:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
  40377a:	461a      	movne	r2, r3
  40377c:	a901      	add	r1, sp, #4
  40377e:	480c      	ldr	r0, [pc, #48]	; (4037b0 <xTimerGenericCommand+0x60>)
  403780:	6880      	ldr	r0, [r0, #8]
  403782:	4c0d      	ldr	r4, [pc, #52]	; (4037b8 <xTimerGenericCommand+0x68>)
  403784:	47a0      	blx	r4
}
  403786:	b005      	add	sp, #20
  403788:	bd30      	pop	{r4, r5, pc}
  40378a:	f44f 7380 	mov.w	r3, #256	; 0x100
  40378e:	b672      	cpsid	i
  403790:	f383 8811 	msr	BASEPRI, r3
  403794:	f3bf 8f6f 	isb	sy
  403798:	f3bf 8f4f 	dsb	sy
  40379c:	b662      	cpsie	i
  40379e:	e7fe      	b.n	40379e <xTimerGenericCommand+0x4e>
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
  4037a0:	2300      	movs	r3, #0
  4037a2:	a901      	add	r1, sp, #4
  4037a4:	4c05      	ldr	r4, [pc, #20]	; (4037bc <xTimerGenericCommand+0x6c>)
  4037a6:	47a0      	blx	r4
  4037a8:	e7ed      	b.n	403786 <xTimerGenericCommand+0x36>
	BaseType_t          xReturn = pdFAIL;
  4037aa:	2000      	movs	r0, #0
	return xReturn;
  4037ac:	e7eb      	b.n	403786 <xTimerGenericCommand+0x36>
  4037ae:	bf00      	nop
  4037b0:	20400bd0 	.word	0x20400bd0
  4037b4:	004034f9 	.word	0x004034f9
  4037b8:	0040263d 	.word	0x0040263d
  4037bc:	0040282d 	.word	0x0040282d

004037c0 <prvSampleTimeNow>:
{
  4037c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  4037c4:	b082      	sub	sp, #8
  4037c6:	4680      	mov	r8, r0
	xTimeNow = xTaskGetTickCount();
  4037c8:	4b24      	ldr	r3, [pc, #144]	; (40385c <prvSampleTimeNow+0x9c>)
  4037ca:	4798      	blx	r3
  4037cc:	4607      	mov	r7, r0
	if (xTimeNow < xLastTime) {
  4037ce:	4b24      	ldr	r3, [pc, #144]	; (403860 <prvSampleTimeNow+0xa0>)
  4037d0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  4037d2:	4298      	cmp	r0, r3
  4037d4:	d31b      	bcc.n	40380e <prvSampleTimeNow+0x4e>
		*pxTimerListsWereSwitched = pdFALSE;
  4037d6:	2300      	movs	r3, #0
  4037d8:	f8c8 3000 	str.w	r3, [r8]
	xLastTime = xTimeNow;
  4037dc:	4b20      	ldr	r3, [pc, #128]	; (403860 <prvSampleTimeNow+0xa0>)
  4037de:	639f      	str	r7, [r3, #56]	; 0x38
}
  4037e0:	4638      	mov	r0, r7
  4037e2:	b002      	add	sp, #8
  4037e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
  4037e8:	2100      	movs	r1, #0
  4037ea:	9100      	str	r1, [sp, #0]
  4037ec:	460b      	mov	r3, r1
  4037ee:	4652      	mov	r2, sl
  4037f0:	4620      	mov	r0, r4
  4037f2:	4c1c      	ldr	r4, [pc, #112]	; (403864 <prvSampleTimeNow+0xa4>)
  4037f4:	47a0      	blx	r4
				configASSERT(xResult);
  4037f6:	b960      	cbnz	r0, 403812 <prvSampleTimeNow+0x52>
  4037f8:	f44f 7380 	mov.w	r3, #256	; 0x100
  4037fc:	b672      	cpsid	i
  4037fe:	f383 8811 	msr	BASEPRI, r3
  403802:	f3bf 8f6f 	isb	sy
  403806:	f3bf 8f4f 	dsb	sy
  40380a:	b662      	cpsie	i
  40380c:	e7fe      	b.n	40380c <prvSampleTimeNow+0x4c>
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
  40380e:	4d14      	ldr	r5, [pc, #80]	; (403860 <prvSampleTimeNow+0xa0>)
		(void)uxListRemove(&(pxTimer->xTimerListItem));
  403810:	4e15      	ldr	r6, [pc, #84]	; (403868 <prvSampleTimeNow+0xa8>)
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
  403812:	686b      	ldr	r3, [r5, #4]
  403814:	681a      	ldr	r2, [r3, #0]
  403816:	b1c2      	cbz	r2, 40384a <prvSampleTimeNow+0x8a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
  403818:	68db      	ldr	r3, [r3, #12]
  40381a:	f8d3 a000 	ldr.w	sl, [r3]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
  40381e:	68dc      	ldr	r4, [r3, #12]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
  403820:	f104 0904 	add.w	r9, r4, #4
  403824:	4648      	mov	r0, r9
  403826:	47b0      	blx	r6
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
  403828:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40382a:	4620      	mov	r0, r4
  40382c:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
  40382e:	69e3      	ldr	r3, [r4, #28]
  403830:	2b01      	cmp	r3, #1
  403832:	d1ee      	bne.n	403812 <prvSampleTimeNow+0x52>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
  403834:	69a3      	ldr	r3, [r4, #24]
  403836:	4453      	add	r3, sl
			if (xReloadTime > xNextExpireTime) {
  403838:	459a      	cmp	sl, r3
  40383a:	d2d5      	bcs.n	4037e8 <prvSampleTimeNow+0x28>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
  40383c:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
  40383e:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
  403840:	4649      	mov	r1, r9
  403842:	6868      	ldr	r0, [r5, #4]
  403844:	4b09      	ldr	r3, [pc, #36]	; (40386c <prvSampleTimeNow+0xac>)
  403846:	4798      	blx	r3
  403848:	e7e3      	b.n	403812 <prvSampleTimeNow+0x52>
	pxCurrentTimerList  = pxOverflowTimerList;
  40384a:	4a05      	ldr	r2, [pc, #20]	; (403860 <prvSampleTimeNow+0xa0>)
  40384c:	6811      	ldr	r1, [r2, #0]
  40384e:	6051      	str	r1, [r2, #4]
	pxOverflowTimerList = pxTemp;
  403850:	6013      	str	r3, [r2, #0]
		*pxTimerListsWereSwitched = pdTRUE;
  403852:	2301      	movs	r3, #1
  403854:	f8c8 3000 	str.w	r3, [r8]
  403858:	e7c0      	b.n	4037dc <prvSampleTimeNow+0x1c>
  40385a:	bf00      	nop
  40385c:	00402fc5 	.word	0x00402fc5
  403860:	20400bd0 	.word	0x20400bd0
  403864:	00403751 	.word	0x00403751
  403868:	00401f79 	.word	0x00401f79
  40386c:	00401f45 	.word	0x00401f45

00403870 <prvTimerTask>:
{
  403870:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  403874:	b086      	sub	sp, #24
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
  403876:	4c6b      	ldr	r4, [pc, #428]	; (403a24 <prvTimerTask+0x1b4>)
	vTaskSuspendAll();
  403878:	4f6b      	ldr	r7, [pc, #428]	; (403a28 <prvTimerTask+0x1b8>)
					portYIELD_WITHIN_API();
  40387a:	f8df 91cc 	ldr.w	r9, [pc, #460]	; 403a48 <prvTimerTask+0x1d8>
	(void)uxListRemove(&(pxTimer->xTimerListItem));
  40387e:	f8df 81cc 	ldr.w	r8, [pc, #460]	; 403a4c <prvTimerTask+0x1dc>
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
  403882:	6863      	ldr	r3, [r4, #4]
	if (*pxListWasEmpty == pdFALSE) {
  403884:	681a      	ldr	r2, [r3, #0]
  403886:	2a00      	cmp	r2, #0
  403888:	f000 80bd 	beq.w	403a06 <prvTimerTask+0x196>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
  40388c:	68db      	ldr	r3, [r3, #12]
  40388e:	681d      	ldr	r5, [r3, #0]
	vTaskSuspendAll();
  403890:	47b8      	blx	r7
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
  403892:	a803      	add	r0, sp, #12
  403894:	4b65      	ldr	r3, [pc, #404]	; (403a2c <prvTimerTask+0x1bc>)
  403896:	4798      	blx	r3
  403898:	4606      	mov	r6, r0
		if (xTimerListsWereSwitched == pdFALSE) {
  40389a:	9b03      	ldr	r3, [sp, #12]
  40389c:	2b00      	cmp	r3, #0
  40389e:	d143      	bne.n	403928 <prvTimerTask+0xb8>
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
  4038a0:	42a8      	cmp	r0, r5
  4038a2:	d211      	bcs.n	4038c8 <prvTimerTask+0x58>
  4038a4:	2200      	movs	r2, #0
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
  4038a6:	1ba9      	subs	r1, r5, r6
  4038a8:	68a0      	ldr	r0, [r4, #8]
  4038aa:	4b61      	ldr	r3, [pc, #388]	; (403a30 <prvTimerTask+0x1c0>)
  4038ac:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
  4038ae:	4b61      	ldr	r3, [pc, #388]	; (403a34 <prvTimerTask+0x1c4>)
  4038b0:	4798      	blx	r3
  4038b2:	2800      	cmp	r0, #0
  4038b4:	d13a      	bne.n	40392c <prvTimerTask+0xbc>
					portYIELD_WITHIN_API();
  4038b6:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  4038ba:	f8c9 3000 	str.w	r3, [r9]
  4038be:	f3bf 8f4f 	dsb	sy
  4038c2:	f3bf 8f6f 	isb	sy
  4038c6:	e031      	b.n	40392c <prvTimerTask+0xbc>
				(void)xTaskResumeAll();
  4038c8:	4b5a      	ldr	r3, [pc, #360]	; (403a34 <prvTimerTask+0x1c4>)
  4038ca:	4798      	blx	r3
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
  4038cc:	6863      	ldr	r3, [r4, #4]
  4038ce:	68db      	ldr	r3, [r3, #12]
  4038d0:	f8d3 a00c 	ldr.w	sl, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
  4038d4:	f10a 0004 	add.w	r0, sl, #4
  4038d8:	47c0      	blx	r8
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
  4038da:	f8da 301c 	ldr.w	r3, [sl, #28]
  4038de:	2b01      	cmp	r3, #1
  4038e0:	d004      	beq.n	4038ec <prvTimerTask+0x7c>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
  4038e2:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
  4038e6:	4650      	mov	r0, sl
  4038e8:	4798      	blx	r3
  4038ea:	e01f      	b.n	40392c <prvTimerTask+0xbc>
		if (prvInsertTimerInActiveList(
  4038ec:	f8da 1018 	ldr.w	r1, [sl, #24]
  4038f0:	462b      	mov	r3, r5
  4038f2:	4632      	mov	r2, r6
  4038f4:	4429      	add	r1, r5
  4038f6:	4650      	mov	r0, sl
  4038f8:	4e4f      	ldr	r6, [pc, #316]	; (403a38 <prvTimerTask+0x1c8>)
  4038fa:	47b0      	blx	r6
  4038fc:	2800      	cmp	r0, #0
  4038fe:	d0f0      	beq.n	4038e2 <prvTimerTask+0x72>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
  403900:	2100      	movs	r1, #0
  403902:	9100      	str	r1, [sp, #0]
  403904:	460b      	mov	r3, r1
  403906:	462a      	mov	r2, r5
  403908:	4650      	mov	r0, sl
  40390a:	4d4c      	ldr	r5, [pc, #304]	; (403a3c <prvTimerTask+0x1cc>)
  40390c:	47a8      	blx	r5
			configASSERT(xResult);
  40390e:	2800      	cmp	r0, #0
  403910:	d1e7      	bne.n	4038e2 <prvTimerTask+0x72>
  403912:	f44f 7380 	mov.w	r3, #256	; 0x100
  403916:	b672      	cpsid	i
  403918:	f383 8811 	msr	BASEPRI, r3
  40391c:	f3bf 8f6f 	isb	sy
  403920:	f3bf 8f4f 	dsb	sy
  403924:	b662      	cpsie	i
  403926:	e7fe      	b.n	403926 <prvTimerTask+0xb6>
			(void)xTaskResumeAll();
  403928:	4b42      	ldr	r3, [pc, #264]	; (403a34 <prvTimerTask+0x1c4>)
  40392a:	4798      	blx	r3
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
  40392c:	4d44      	ldr	r5, [pc, #272]	; (403a40 <prvTimerTask+0x1d0>)
  40392e:	2300      	movs	r3, #0
  403930:	461a      	mov	r2, r3
  403932:	a903      	add	r1, sp, #12
  403934:	68a0      	ldr	r0, [r4, #8]
  403936:	47a8      	blx	r5
  403938:	2800      	cmp	r0, #0
  40393a:	d0a2      	beq.n	403882 <prvTimerTask+0x12>
		if (xMessage.xMessageID >= (BaseType_t)0) {
  40393c:	9b03      	ldr	r3, [sp, #12]
  40393e:	2b00      	cmp	r3, #0
  403940:	dbf5      	blt.n	40392e <prvTimerTask+0xbe>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
  403942:	9e05      	ldr	r6, [sp, #20]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem)) == pdFALSE) {
  403944:	6973      	ldr	r3, [r6, #20]
  403946:	b10b      	cbz	r3, 40394c <prvTimerTask+0xdc>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
  403948:	1d30      	adds	r0, r6, #4
  40394a:	47c0      	blx	r8
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
  40394c:	a802      	add	r0, sp, #8
  40394e:	4b37      	ldr	r3, [pc, #220]	; (403a2c <prvTimerTask+0x1bc>)
  403950:	4798      	blx	r3
			switch (xMessage.xMessageID) {
  403952:	9b03      	ldr	r3, [sp, #12]
  403954:	2b09      	cmp	r3, #9
  403956:	d8ea      	bhi.n	40392e <prvTimerTask+0xbe>
  403958:	a201      	add	r2, pc, #4	; (adr r2, 403960 <prvTimerTask+0xf0>)
  40395a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40395e:	bf00      	nop
  403960:	00403989 	.word	0x00403989
  403964:	00403989 	.word	0x00403989
  403968:	00403989 	.word	0x00403989
  40396c:	0040392f 	.word	0x0040392f
  403970:	004039d5 	.word	0x004039d5
  403974:	004039ff 	.word	0x004039ff
  403978:	00403989 	.word	0x00403989
  40397c:	00403989 	.word	0x00403989
  403980:	0040392f 	.word	0x0040392f
  403984:	004039d5 	.word	0x004039d5
				                               xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks,
  403988:	9d04      	ldr	r5, [sp, #16]
				if (prvInsertTimerInActiveList(pxTimer,
  40398a:	69b1      	ldr	r1, [r6, #24]
  40398c:	462b      	mov	r3, r5
  40398e:	4602      	mov	r2, r0
  403990:	4429      	add	r1, r5
  403992:	4630      	mov	r0, r6
  403994:	4d28      	ldr	r5, [pc, #160]	; (403a38 <prvTimerTask+0x1c8>)
  403996:	47a8      	blx	r5
  403998:	2800      	cmp	r0, #0
  40399a:	d0c7      	beq.n	40392c <prvTimerTask+0xbc>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
  40399c:	6a73      	ldr	r3, [r6, #36]	; 0x24
  40399e:	4630      	mov	r0, r6
  4039a0:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
  4039a2:	69f3      	ldr	r3, [r6, #28]
  4039a4:	2b01      	cmp	r3, #1
  4039a6:	d1c1      	bne.n	40392c <prvTimerTask+0xbc>
						xResult = xTimerGenericCommand(pxTimer,
  4039a8:	69b2      	ldr	r2, [r6, #24]
  4039aa:	2100      	movs	r1, #0
  4039ac:	9100      	str	r1, [sp, #0]
  4039ae:	460b      	mov	r3, r1
  4039b0:	9804      	ldr	r0, [sp, #16]
  4039b2:	4402      	add	r2, r0
  4039b4:	4630      	mov	r0, r6
  4039b6:	4d21      	ldr	r5, [pc, #132]	; (403a3c <prvTimerTask+0x1cc>)
  4039b8:	47a8      	blx	r5
						configASSERT(xResult);
  4039ba:	2800      	cmp	r0, #0
  4039bc:	d1b6      	bne.n	40392c <prvTimerTask+0xbc>
  4039be:	f44f 7380 	mov.w	r3, #256	; 0x100
  4039c2:	b672      	cpsid	i
  4039c4:	f383 8811 	msr	BASEPRI, r3
  4039c8:	f3bf 8f6f 	isb	sy
  4039cc:	f3bf 8f4f 	dsb	sy
  4039d0:	b662      	cpsie	i
  4039d2:	e7fe      	b.n	4039d2 <prvTimerTask+0x162>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
  4039d4:	9904      	ldr	r1, [sp, #16]
  4039d6:	61b1      	str	r1, [r6, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
  4039d8:	b131      	cbz	r1, 4039e8 <prvTimerTask+0x178>
				(void)prvInsertTimerInActiveList(
  4039da:	4603      	mov	r3, r0
  4039dc:	4602      	mov	r2, r0
  4039de:	4401      	add	r1, r0
  4039e0:	4630      	mov	r0, r6
  4039e2:	4d15      	ldr	r5, [pc, #84]	; (403a38 <prvTimerTask+0x1c8>)
  4039e4:	47a8      	blx	r5
  4039e6:	e7a1      	b.n	40392c <prvTimerTask+0xbc>
  4039e8:	f44f 7380 	mov.w	r3, #256	; 0x100
  4039ec:	b672      	cpsid	i
  4039ee:	f383 8811 	msr	BASEPRI, r3
  4039f2:	f3bf 8f6f 	isb	sy
  4039f6:	f3bf 8f4f 	dsb	sy
  4039fa:	b662      	cpsie	i
  4039fc:	e7fe      	b.n	4039fc <prvTimerTask+0x18c>
				vPortFree(pxTimer);
  4039fe:	4630      	mov	r0, r6
  403a00:	4b10      	ldr	r3, [pc, #64]	; (403a44 <prvTimerTask+0x1d4>)
  403a02:	4798      	blx	r3
  403a04:	e792      	b.n	40392c <prvTimerTask+0xbc>
	vTaskSuspendAll();
  403a06:	47b8      	blx	r7
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
  403a08:	a803      	add	r0, sp, #12
  403a0a:	4b08      	ldr	r3, [pc, #32]	; (403a2c <prvTimerTask+0x1bc>)
  403a0c:	4798      	blx	r3
  403a0e:	4606      	mov	r6, r0
		if (xTimerListsWereSwitched == pdFALSE) {
  403a10:	9b03      	ldr	r3, [sp, #12]
  403a12:	2b00      	cmp	r3, #0
  403a14:	d188      	bne.n	403928 <prvTimerTask+0xb8>
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
  403a16:	6823      	ldr	r3, [r4, #0]
  403a18:	681a      	ldr	r2, [r3, #0]
  403a1a:	fab2 f282 	clz	r2, r2
  403a1e:	0952      	lsrs	r2, r2, #5
  403a20:	2500      	movs	r5, #0
  403a22:	e740      	b.n	4038a6 <prvTimerTask+0x36>
  403a24:	20400bd0 	.word	0x20400bd0
  403a28:	00402fb1 	.word	0x00402fb1
  403a2c:	004037c1 	.word	0x004037c1
  403a30:	00402c1d 	.word	0x00402c1d
  403a34:	004030f9 	.word	0x004030f9
  403a38:	00403665 	.word	0x00403665
  403a3c:	00403751 	.word	0x00403751
  403a40:	00402a25 	.word	0x00402a25
  403a44:	0040230d 	.word	0x0040230d
  403a48:	e000ed04 	.word	0xe000ed04
  403a4c:	00401f79 	.word	0x00401f79

00403a50 <cdcdf_acm_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t cdcdf_acm_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
  403a50:	b5f0      	push	{r4, r5, r6, r7, lr}
  403a52:	b083      	sub	sp, #12
	if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
  403a54:	780b      	ldrb	r3, [r1, #0]
  403a56:	f3c3 1441 	ubfx	r4, r3, #5, #2
  403a5a:	2c01      	cmp	r4, #1
  403a5c:	d15e      	bne.n	403b1c <cdcdf_acm_req+0xcc>
		return ERR_NOT_FOUND;
	}
	if ((req->wIndex == _cdcdf_acm_funcd.func_iface[0]) || (req->wIndex == _cdcdf_acm_funcd.func_iface[1])) {
  403a5e:	888c      	ldrh	r4, [r1, #4]
  403a60:	4d35      	ldr	r5, [pc, #212]	; (403b38 <cdcdf_acm_req+0xe8>)
  403a62:	782d      	ldrb	r5, [r5, #0]
  403a64:	42a5      	cmp	r5, r4
  403a66:	d003      	beq.n	403a70 <cdcdf_acm_req+0x20>
  403a68:	4d33      	ldr	r5, [pc, #204]	; (403b38 <cdcdf_acm_req+0xe8>)
  403a6a:	786d      	ldrb	r5, [r5, #1]
  403a6c:	42a5      	cmp	r5, r4
  403a6e:	d158      	bne.n	403b22 <cdcdf_acm_req+0xd2>
  403a70:	4616      	mov	r6, r2
  403a72:	460c      	mov	r4, r1
  403a74:	4605      	mov	r5, r0
		if (req->bmRequestType & USB_EP_DIR_IN) {
  403a76:	f013 0f80 	tst.w	r3, #128	; 0x80
  403a7a:	d10c      	bne.n	403a96 <cdcdf_acm_req+0x46>
	uint16_t                   len      = req->wLength;
  403a7c:	88cf      	ldrh	r7, [r1, #6]
	uint8_t *                  ctrl_buf = usbdc_get_ctrl_buffer();
  403a7e:	4b2f      	ldr	r3, [pc, #188]	; (403b3c <cdcdf_acm_req+0xec>)
  403a80:	4798      	blx	r3
  403a82:	4601      	mov	r1, r0
	switch (req->bRequest) {
  403a84:	7863      	ldrb	r3, [r4, #1]
  403a86:	2b20      	cmp	r3, #32
  403a88:	d013      	beq.n	403ab2 <cdcdf_acm_req+0x62>
  403a8a:	2b22      	cmp	r3, #34	; 0x22
  403a8c:	d032      	beq.n	403af4 <cdcdf_acm_req+0xa4>
		return ERR_INVALID_ARG;
  403a8e:	f06f 000c 	mvn.w	r0, #12
			return cdcdf_acm_set_req(ep, req, stage);
		}
	} else {
		return ERR_NOT_FOUND;
	}
}
  403a92:	b003      	add	sp, #12
  403a94:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (USB_DATA_STAGE == stage) {
  403a96:	2a01      	cmp	r2, #1
  403a98:	d046      	beq.n	403b28 <cdcdf_acm_req+0xd8>
	switch (req->bRequest) {
  403a9a:	784b      	ldrb	r3, [r1, #1]
  403a9c:	2b21      	cmp	r3, #33	; 0x21
  403a9e:	d145      	bne.n	403b2c <cdcdf_acm_req+0xdc>
		if (sizeof(struct usb_cdc_line_coding) != len) {
  403aa0:	88cb      	ldrh	r3, [r1, #6]
  403aa2:	2b07      	cmp	r3, #7
  403aa4:	d145      	bne.n	403b32 <cdcdf_acm_req+0xe2>
		return usbdc_xfer(ep, (uint8_t *)&usbd_cdc_line_coding, len, false);
  403aa6:	2300      	movs	r3, #0
  403aa8:	2207      	movs	r2, #7
  403aaa:	4925      	ldr	r1, [pc, #148]	; (403b40 <cdcdf_acm_req+0xf0>)
  403aac:	4c25      	ldr	r4, [pc, #148]	; (403b44 <cdcdf_acm_req+0xf4>)
  403aae:	47a0      	blx	r4
  403ab0:	e7ef      	b.n	403a92 <cdcdf_acm_req+0x42>
		if (sizeof(struct usb_cdc_line_coding) != len) {
  403ab2:	2f07      	cmp	r7, #7
  403ab4:	d12b      	bne.n	403b0e <cdcdf_acm_req+0xbe>
		if (USB_SETUP_STAGE == stage) {
  403ab6:	b1be      	cbz	r6, 403ae8 <cdcdf_acm_req+0x98>
			memcpy(&line_coding_tmp, ctrl_buf, sizeof(struct usb_cdc_line_coding));
  403ab8:	6800      	ldr	r0, [r0, #0]
  403aba:	9000      	str	r0, [sp, #0]
  403abc:	888a      	ldrh	r2, [r1, #4]
  403abe:	798b      	ldrb	r3, [r1, #6]
  403ac0:	f8ad 2004 	strh.w	r2, [sp, #4]
  403ac4:	f88d 3006 	strb.w	r3, [sp, #6]
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
  403ac8:	4b1b      	ldr	r3, [pc, #108]	; (403b38 <cdcdf_acm_req+0xe8>)
  403aca:	691b      	ldr	r3, [r3, #16]
  403acc:	b113      	cbz	r3, 403ad4 <cdcdf_acm_req+0x84>
  403ace:	4668      	mov	r0, sp
  403ad0:	4798      	blx	r3
  403ad2:	b1f8      	cbz	r0, 403b14 <cdcdf_acm_req+0xc4>
				usbd_cdc_line_coding = line_coding_tmp;
  403ad4:	4b18      	ldr	r3, [pc, #96]	; (403b38 <cdcdf_acm_req+0xe8>)
  403ad6:	aa02      	add	r2, sp, #8
  403ad8:	e912 0003 	ldmdb	r2, {r0, r1}
  403adc:	6098      	str	r0, [r3, #8]
  403ade:	8199      	strh	r1, [r3, #12]
  403ae0:	0c09      	lsrs	r1, r1, #16
  403ae2:	7399      	strb	r1, [r3, #14]
			return ERR_NONE;
  403ae4:	2000      	movs	r0, #0
  403ae6:	e7d4      	b.n	403a92 <cdcdf_acm_req+0x42>
			return usbdc_xfer(ep, ctrl_buf, len, false);
  403ae8:	2300      	movs	r3, #0
  403aea:	2207      	movs	r2, #7
  403aec:	4628      	mov	r0, r5
  403aee:	4c15      	ldr	r4, [pc, #84]	; (403b44 <cdcdf_acm_req+0xf4>)
  403af0:	47a0      	blx	r4
  403af2:	e7ce      	b.n	403a92 <cdcdf_acm_req+0x42>
		usbdc_xfer(0, NULL, 0, 0);
  403af4:	2300      	movs	r3, #0
  403af6:	461a      	mov	r2, r3
  403af8:	4619      	mov	r1, r3
  403afa:	4618      	mov	r0, r3
  403afc:	4d11      	ldr	r5, [pc, #68]	; (403b44 <cdcdf_acm_req+0xf4>)
  403afe:	47a8      	blx	r5
		if (NULL != cdcdf_acm_notify_state) {
  403b00:	4b0d      	ldr	r3, [pc, #52]	; (403b38 <cdcdf_acm_req+0xe8>)
  403b02:	695b      	ldr	r3, [r3, #20]
  403b04:	b143      	cbz	r3, 403b18 <cdcdf_acm_req+0xc8>
			cdcdf_acm_notify_state(req->wValue);
  403b06:	8860      	ldrh	r0, [r4, #2]
  403b08:	4798      	blx	r3
		return ERR_NONE;
  403b0a:	2000      	movs	r0, #0
  403b0c:	e7c1      	b.n	403a92 <cdcdf_acm_req+0x42>
			return ERR_INVALID_DATA;
  403b0e:	f04f 30ff 	mov.w	r0, #4294967295
  403b12:	e7be      	b.n	403a92 <cdcdf_acm_req+0x42>
			return ERR_NONE;
  403b14:	2000      	movs	r0, #0
  403b16:	e7bc      	b.n	403a92 <cdcdf_acm_req+0x42>
		return ERR_NONE;
  403b18:	2000      	movs	r0, #0
			return cdcdf_acm_set_req(ep, req, stage);
  403b1a:	e7ba      	b.n	403a92 <cdcdf_acm_req+0x42>
		return ERR_NOT_FOUND;
  403b1c:	f06f 0009 	mvn.w	r0, #9
  403b20:	e7b7      	b.n	403a92 <cdcdf_acm_req+0x42>
		return ERR_NOT_FOUND;
  403b22:	f06f 0009 	mvn.w	r0, #9
  403b26:	e7b4      	b.n	403a92 <cdcdf_acm_req+0x42>
		return ERR_NONE;
  403b28:	2000      	movs	r0, #0
  403b2a:	e7b2      	b.n	403a92 <cdcdf_acm_req+0x42>
		return ERR_INVALID_ARG;
  403b2c:	f06f 000c 	mvn.w	r0, #12
  403b30:	e7af      	b.n	403a92 <cdcdf_acm_req+0x42>
			return ERR_INVALID_DATA;
  403b32:	f04f 30ff 	mov.w	r0, #4294967295
  403b36:	e7ac      	b.n	403a92 <cdcdf_acm_req+0x42>
  403b38:	20400c0c 	.word	0x20400c0c
  403b3c:	00404309 	.word	0x00404309
  403b40:	20400c14 	.word	0x20400c14
  403b44:	00403f3d 	.word	0x00403f3d

00403b48 <cdcdf_acm_ctrl>:
{
  403b48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403b4c:	b083      	sub	sp, #12
  403b4e:	4616      	mov	r6, r2
	switch (ctrl) {
  403b50:	2901      	cmp	r1, #1
  403b52:	d06c      	beq.n	403c2e <cdcdf_acm_ctrl+0xe6>
  403b54:	b141      	cbz	r1, 403b68 <cdcdf_acm_ctrl+0x20>
		return ERR_INVALID_ARG;
  403b56:	2902      	cmp	r1, #2
  403b58:	bf0c      	ite	eq
  403b5a:	f06f 001a 	mvneq.w	r0, #26
  403b5e:	f06f 000c 	mvnne.w	r0, #12
}
  403b62:	b003      	add	sp, #12
  403b64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ifc = desc->sod;
  403b68:	6813      	ldr	r3, [r2, #0]
		if (NULL == ifc) {
  403b6a:	2b00      	cmp	r3, #0
  403b6c:	f000 808a 	beq.w	403c84 <cdcdf_acm_ctrl+0x13c>
		ifc_desc.bInterfaceNumber = ifc[2];
  403b70:	789a      	ldrb	r2, [r3, #2]
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
  403b72:	7959      	ldrb	r1, [r3, #5]
  403b74:	f001 01f7 	and.w	r1, r1, #247	; 0xf7
  403b78:	2902      	cmp	r1, #2
  403b7a:	f040 8086 	bne.w	403c8a <cdcdf_acm_ctrl+0x142>
	struct cdcdf_acm_func_data *func_data = (struct cdcdf_acm_func_data *)(drv->func_data);
  403b7e:	f8d0 a008 	ldr.w	sl, [r0, #8]
			if (func_data->func_iface[i] == ifc_desc.bInterfaceNumber) { // Initialized
  403b82:	f89a 1000 	ldrb.w	r1, [sl]
  403b86:	428a      	cmp	r2, r1
  403b88:	f000 8082 	beq.w	403c90 <cdcdf_acm_ctrl+0x148>
			} else if (func_data->func_iface[i] != 0xFF) { // Occupied
  403b8c:	29ff      	cmp	r1, #255	; 0xff
  403b8e:	f040 8082 	bne.w	403c96 <cdcdf_acm_ctrl+0x14e>
  403b92:	46d3      	mov	fp, sl
  403b94:	f10a 0102 	add.w	r1, sl, #2
  403b98:	9101      	str	r1, [sp, #4]
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
  403b9a:	4f48      	ldr	r7, [pc, #288]	; (403cbc <cdcdf_acm_ctrl+0x174>)
				usb_d_ep_enable(func_data->func_ep_out);
  403b9c:	f8df 912c 	ldr.w	r9, [pc, #300]	; 403ccc <cdcdf_acm_ctrl+0x184>
			ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
  403ba0:	f8df 812c 	ldr.w	r8, [pc, #300]	; 403cd0 <cdcdf_acm_ctrl+0x188>
  403ba4:	4618      	mov	r0, r3
				func_data->func_iface[i] = ifc_desc.bInterfaceNumber;
  403ba6:	f80b 2b01 	strb.w	r2, [fp], #1
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
  403baa:	2205      	movs	r2, #5
  403bac:	6871      	ldr	r1, [r6, #4]
  403bae:	4b44      	ldr	r3, [pc, #272]	; (403cc0 <cdcdf_acm_ctrl+0x178>)
  403bb0:	4798      	blx	r3
		while (NULL != ep) {
  403bb2:	4604      	mov	r4, r0
  403bb4:	b1d8      	cbz	r0, 403bee <cdcdf_acm_ctrl+0xa6>
			ep_desc.bEndpointAddress = ep[2];
  403bb6:	78a5      	ldrb	r5, [r4, #2]
 *  \param[in] ptr Byte pointer to the address to get data
 *  \return a 16-bit word
 */
static inline uint16_t usb_get_u16(const uint8_t *ptr)
{
	return (ptr[0] + (ptr[1] << 8));
  403bb8:	7963      	ldrb	r3, [r4, #5]
  403bba:	7922      	ldrb	r2, [r4, #4]
  403bbc:	eb02 2203 	add.w	r2, r2, r3, lsl #8
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
  403bc0:	b292      	uxth	r2, r2
  403bc2:	78e1      	ldrb	r1, [r4, #3]
  403bc4:	4628      	mov	r0, r5
  403bc6:	47b8      	blx	r7
  403bc8:	2800      	cmp	r0, #0
  403bca:	d170      	bne.n	403cae <cdcdf_acm_ctrl+0x166>
			if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
  403bcc:	f015 0f80 	tst.w	r5, #128	; 0x80
				func_data->func_ep_in[i] = ep_desc.bEndpointAddress;
  403bd0:	bf14      	ite	ne
  403bd2:	f88b 5001 	strbne.w	r5, [fp, #1]
				func_data->func_ep_out = ep_desc.bEndpointAddress;
  403bd6:	f88a 5004 	strbeq.w	r5, [sl, #4]
				usb_d_ep_enable(func_data->func_ep_out);
  403bda:	4628      	mov	r0, r5
  403bdc:	47c8      	blx	r9
			desc->sod = ep;
  403bde:	6034      	str	r4, [r6, #0]
 *  \param[in] desc Byte pointer to the descriptor start address
 *  \return Byte pointer to the next descriptor
 */
static inline uint8_t *usb_desc_next(uint8_t *desc)
{
	return (desc + usb_desc_len(desc));
  403be0:	7820      	ldrb	r0, [r4, #0]
			ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
  403be2:	6871      	ldr	r1, [r6, #4]
  403be4:	4420      	add	r0, r4
  403be6:	47c0      	blx	r8
		while (NULL != ep) {
  403be8:	4604      	mov	r4, r0
  403bea:	2800      	cmp	r0, #0
  403bec:	d1e3      	bne.n	403bb6 <cdcdf_acm_ctrl+0x6e>
		ifc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_INTERFACE);
  403bee:	6833      	ldr	r3, [r6, #0]
  403bf0:	7818      	ldrb	r0, [r3, #0]
  403bf2:	2204      	movs	r2, #4
  403bf4:	6871      	ldr	r1, [r6, #4]
  403bf6:	4418      	add	r0, r3
  403bf8:	4b31      	ldr	r3, [pc, #196]	; (403cc0 <cdcdf_acm_ctrl+0x178>)
  403bfa:	4798      	blx	r3
	for (i = 0; i < 2; i++) {
  403bfc:	9b01      	ldr	r3, [sp, #4]
  403bfe:	455b      	cmp	r3, fp
  403c00:	d010      	beq.n	403c24 <cdcdf_acm_ctrl+0xdc>
		if (NULL == ifc) {
  403c02:	2800      	cmp	r0, #0
  403c04:	d04a      	beq.n	403c9c <cdcdf_acm_ctrl+0x154>
		ifc_desc.bInterfaceNumber = ifc[2];
  403c06:	7882      	ldrb	r2, [r0, #2]
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
  403c08:	7943      	ldrb	r3, [r0, #5]
  403c0a:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
  403c0e:	2b02      	cmp	r3, #2
  403c10:	d147      	bne.n	403ca2 <cdcdf_acm_ctrl+0x15a>
			if (func_data->func_iface[i] == ifc_desc.bInterfaceNumber) { // Initialized
  403c12:	f89b 3000 	ldrb.w	r3, [fp]
  403c16:	429a      	cmp	r2, r3
  403c18:	d046      	beq.n	403ca8 <cdcdf_acm_ctrl+0x160>
			} else if (func_data->func_iface[i] != 0xFF) { // Occupied
  403c1a:	2bff      	cmp	r3, #255	; 0xff
  403c1c:	d0c3      	beq.n	403ba6 <cdcdf_acm_ctrl+0x5e>
				return ERR_NO_RESOURCE;
  403c1e:	f06f 001b 	mvn.w	r0, #27
  403c22:	e79e      	b.n	403b62 <cdcdf_acm_ctrl+0x1a>
	_cdcdf_acm_funcd.enabled = true;
  403c24:	2201      	movs	r2, #1
  403c26:	4b27      	ldr	r3, [pc, #156]	; (403cc4 <cdcdf_acm_ctrl+0x17c>)
  403c28:	715a      	strb	r2, [r3, #5]
	return ERR_NONE;
  403c2a:	2000      	movs	r0, #0
  403c2c:	e799      	b.n	403b62 <cdcdf_acm_ctrl+0x1a>
	struct cdcdf_acm_func_data *func_data = (struct cdcdf_acm_func_data *)(drv->func_data);
  403c2e:	6884      	ldr	r4, [r0, #8]
	if (desc) {
  403c30:	b12a      	cbz	r2, 403c3e <cdcdf_acm_ctrl+0xf6>
		ifc_desc.bInterfaceClass = desc->sod[5];
  403c32:	6813      	ldr	r3, [r2, #0]
		if ((ifc_desc.bInterfaceClass != CDC_CLASS_COMM) && (ifc_desc.bInterfaceClass != CDC_CLASS_DATA)) {
  403c34:	795b      	ldrb	r3, [r3, #5]
  403c36:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
  403c3a:	2b02      	cmp	r3, #2
  403c3c:	d13a      	bne.n	403cb4 <cdcdf_acm_ctrl+0x16c>
		if (func_data->func_iface[i] == 0xFF) {
  403c3e:	7823      	ldrb	r3, [r4, #0]
  403c40:	2bff      	cmp	r3, #255	; 0xff
  403c42:	d008      	beq.n	403c56 <cdcdf_acm_ctrl+0x10e>
			func_data->func_iface[i] = 0xFF;
  403c44:	23ff      	movs	r3, #255	; 0xff
  403c46:	7023      	strb	r3, [r4, #0]
			if (func_data->func_ep_in[i] != 0xFF) {
  403c48:	78a0      	ldrb	r0, [r4, #2]
  403c4a:	4298      	cmp	r0, r3
  403c4c:	d003      	beq.n	403c56 <cdcdf_acm_ctrl+0x10e>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
  403c4e:	4b1e      	ldr	r3, [pc, #120]	; (403cc8 <cdcdf_acm_ctrl+0x180>)
  403c50:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
  403c52:	23ff      	movs	r3, #255	; 0xff
  403c54:	70a3      	strb	r3, [r4, #2]
		if (func_data->func_iface[i] == 0xFF) {
  403c56:	7863      	ldrb	r3, [r4, #1]
  403c58:	2bff      	cmp	r3, #255	; 0xff
  403c5a:	d008      	beq.n	403c6e <cdcdf_acm_ctrl+0x126>
			func_data->func_iface[i] = 0xFF;
  403c5c:	23ff      	movs	r3, #255	; 0xff
  403c5e:	7063      	strb	r3, [r4, #1]
			if (func_data->func_ep_in[i] != 0xFF) {
  403c60:	78e0      	ldrb	r0, [r4, #3]
  403c62:	4298      	cmp	r0, r3
  403c64:	d003      	beq.n	403c6e <cdcdf_acm_ctrl+0x126>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
  403c66:	4b18      	ldr	r3, [pc, #96]	; (403cc8 <cdcdf_acm_ctrl+0x180>)
  403c68:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
  403c6a:	23ff      	movs	r3, #255	; 0xff
  403c6c:	70e3      	strb	r3, [r4, #3]
	if (func_data->func_ep_out != 0xFF) {
  403c6e:	7920      	ldrb	r0, [r4, #4]
  403c70:	28ff      	cmp	r0, #255	; 0xff
  403c72:	d003      	beq.n	403c7c <cdcdf_acm_ctrl+0x134>
		usb_d_ep_deinit(func_data->func_ep_out);
  403c74:	4b14      	ldr	r3, [pc, #80]	; (403cc8 <cdcdf_acm_ctrl+0x180>)
  403c76:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
  403c78:	23ff      	movs	r3, #255	; 0xff
  403c7a:	7123      	strb	r3, [r4, #4]
	_cdcdf_acm_funcd.enabled = false;
  403c7c:	2000      	movs	r0, #0
  403c7e:	4b11      	ldr	r3, [pc, #68]	; (403cc4 <cdcdf_acm_ctrl+0x17c>)
  403c80:	7158      	strb	r0, [r3, #5]
  403c82:	e76e      	b.n	403b62 <cdcdf_acm_ctrl+0x1a>
			return ERR_NOT_FOUND;
  403c84:	f06f 0009 	mvn.w	r0, #9
  403c88:	e76b      	b.n	403b62 <cdcdf_acm_ctrl+0x1a>
			return ERR_NOT_FOUND;
  403c8a:	f06f 0009 	mvn.w	r0, #9
  403c8e:	e768      	b.n	403b62 <cdcdf_acm_ctrl+0x1a>
				return ERR_ALREADY_INITIALIZED;
  403c90:	f06f 0011 	mvn.w	r0, #17
  403c94:	e765      	b.n	403b62 <cdcdf_acm_ctrl+0x1a>
				return ERR_NO_RESOURCE;
  403c96:	f06f 001b 	mvn.w	r0, #27
  403c9a:	e762      	b.n	403b62 <cdcdf_acm_ctrl+0x1a>
			return ERR_NOT_FOUND;
  403c9c:	f06f 0009 	mvn.w	r0, #9
  403ca0:	e75f      	b.n	403b62 <cdcdf_acm_ctrl+0x1a>
			return ERR_NOT_FOUND;
  403ca2:	f06f 0009 	mvn.w	r0, #9
  403ca6:	e75c      	b.n	403b62 <cdcdf_acm_ctrl+0x1a>
				return ERR_ALREADY_INITIALIZED;
  403ca8:	f06f 0011 	mvn.w	r0, #17
  403cac:	e759      	b.n	403b62 <cdcdf_acm_ctrl+0x1a>
				return ERR_NOT_INITIALIZED;
  403cae:	f06f 0013 	mvn.w	r0, #19
  403cb2:	e756      	b.n	403b62 <cdcdf_acm_ctrl+0x1a>
			return ERR_NOT_FOUND;
  403cb4:	f06f 0009 	mvn.w	r0, #9
  403cb8:	e753      	b.n	403b62 <cdcdf_acm_ctrl+0x1a>
  403cba:	bf00      	nop
  403cbc:	00400951 	.word	0x00400951
  403cc0:	00404329 	.word	0x00404329
  403cc4:	20400c0c 	.word	0x20400c0c
  403cc8:	004009b9 	.word	0x004009b9
  403ccc:	004009e5 	.word	0x004009e5
  403cd0:	00404363 	.word	0x00404363

00403cd4 <cdcdf_acm_init>:

/**
 * \brief Initialize the USB CDC ACM Function Driver
 */
int32_t cdcdf_acm_init(void)
{
  403cd4:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
  403cd6:	4b0a      	ldr	r3, [pc, #40]	; (403d00 <cdcdf_acm_init+0x2c>)
  403cd8:	4798      	blx	r3
  403cda:	2801      	cmp	r0, #1
  403cdc:	d80c      	bhi.n	403cf8 <cdcdf_acm_init+0x24>
		return ERR_DENIED;
	}

	_cdcdf_acm.ctrl      = cdcdf_acm_ctrl;
  403cde:	4809      	ldr	r0, [pc, #36]	; (403d04 <cdcdf_acm_init+0x30>)
  403ce0:	4b09      	ldr	r3, [pc, #36]	; (403d08 <cdcdf_acm_init+0x34>)
  403ce2:	61c3      	str	r3, [r0, #28]
	_cdcdf_acm.func_data = &_cdcdf_acm_funcd;
  403ce4:	6200      	str	r0, [r0, #32]

	usbdc_register_function(&_cdcdf_acm);
  403ce6:	3018      	adds	r0, #24
  403ce8:	4b08      	ldr	r3, [pc, #32]	; (403d0c <cdcdf_acm_init+0x38>)
  403cea:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &cdcdf_acm_req_h);
  403cec:	4908      	ldr	r1, [pc, #32]	; (403d10 <cdcdf_acm_init+0x3c>)
  403cee:	2001      	movs	r0, #1
  403cf0:	4b08      	ldr	r3, [pc, #32]	; (403d14 <cdcdf_acm_init+0x40>)
  403cf2:	4798      	blx	r3
	return ERR_NONE;
  403cf4:	2000      	movs	r0, #0
  403cf6:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
  403cf8:	f06f 0010 	mvn.w	r0, #16
}
  403cfc:	bd08      	pop	{r3, pc}
  403cfe:	bf00      	nop
  403d00:	00404315 	.word	0x00404315
  403d04:	20400c0c 	.word	0x20400c0c
  403d08:	00403b49 	.word	0x00403b49
  403d0c:	004042b5 	.word	0x004042b5
  403d10:	20400004 	.word	0x20400004
  403d14:	00404221 	.word	0x00404221

00403d18 <usbdc_unconfig>:

/**
 * \brief Unconfig, close all interfaces
 */
static void usbdc_unconfig(void)
{
  403d18:	b570      	push	{r4, r5, r6, lr}
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
  403d1a:	4b07      	ldr	r3, [pc, #28]	; (403d38 <usbdc_unconfig+0x20>)
  403d1c:	691c      	ldr	r4, [r3, #16]
	while (NULL != func) {
  403d1e:	b14c      	cbz	r4, 403d34 <usbdc_unconfig+0x1c>
		func->ctrl(func, USBDF_DISABLE, NULL);
  403d20:	2600      	movs	r6, #0
  403d22:	2501      	movs	r5, #1
  403d24:	6863      	ldr	r3, [r4, #4]
  403d26:	4632      	mov	r2, r6
  403d28:	4629      	mov	r1, r5
  403d2a:	4620      	mov	r0, r4
  403d2c:	4798      	blx	r3
		func = func->next;
  403d2e:	6824      	ldr	r4, [r4, #0]
	while (NULL != func) {
  403d30:	2c00      	cmp	r4, #0
  403d32:	d1f7      	bne.n	403d24 <usbdc_unconfig+0xc>
  403d34:	bd70      	pop	{r4, r5, r6, pc}
  403d36:	bf00      	nop
  403d38:	20400c30 	.word	0x20400c30

00403d3c <usbdc_change_notify>:
	}
}

/** Invoke all registered Change notification callbacks. */
static void usbdc_change_notify(enum usbdc_change_type change, uint32_t value)
{
  403d3c:	b570      	push	{r4, r5, r6, lr}
  403d3e:	4606      	mov	r6, r0
  403d40:	460d      	mov	r5, r1
	struct usbdc_change_handler *cg = (struct usbdc_change_handler *)usbdc.handlers.change_list.head;
  403d42:	4b07      	ldr	r3, [pc, #28]	; (403d60 <usbdc_change_notify+0x24>)
  403d44:	68dc      	ldr	r4, [r3, #12]

	while (cg != NULL) {
  403d46:	b91c      	cbnz	r4, 403d50 <usbdc_change_notify+0x14>
  403d48:	bd70      	pop	{r4, r5, r6, pc}
		if (NULL != cg->cb) {
			cg->cb(change, value);
		}
		cg = cg->next;
  403d4a:	6824      	ldr	r4, [r4, #0]
	while (cg != NULL) {
  403d4c:	2c00      	cmp	r4, #0
  403d4e:	d0fb      	beq.n	403d48 <usbdc_change_notify+0xc>
		if (NULL != cg->cb) {
  403d50:	6863      	ldr	r3, [r4, #4]
  403d52:	2b00      	cmp	r3, #0
  403d54:	d0f9      	beq.n	403d4a <usbdc_change_notify+0xe>
			cg->cb(change, value);
  403d56:	4629      	mov	r1, r5
  403d58:	4630      	mov	r0, r6
  403d5a:	4798      	blx	r3
  403d5c:	e7f5      	b.n	403d4a <usbdc_change_notify+0xe>
  403d5e:	bf00      	nop
  403d60:	20400c30 	.word	0x20400c30

00403d64 <usbdc_request_handler>:
	}
}

/** Invoke all registered request callbacks until request handled. */
static bool usbdc_request_handler(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
  403d64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  403d66:	4607      	mov	r7, r0
  403d68:	460e      	mov	r6, r1
  403d6a:	4615      	mov	r5, r2
	struct usbdc_req_handler *h = (struct usbdc_req_handler *)usbdc.handlers.req_list.head;
  403d6c:	4b0b      	ldr	r3, [pc, #44]	; (403d9c <usbdc_request_handler+0x38>)
  403d6e:	689c      	ldr	r4, [r3, #8]
	int32_t                   rc;

	while (h != NULL) {
  403d70:	b91c      	cbnz	r4, 403d7a <usbdc_request_handler+0x16>
				return false;
			}
		}
		h = h->next;
	}
	return false;
  403d72:	2000      	movs	r0, #0
  403d74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		h = h->next;
  403d76:	6824      	ldr	r4, [r4, #0]
	while (h != NULL) {
  403d78:	b164      	cbz	r4, 403d94 <usbdc_request_handler+0x30>
		if (NULL != h->cb) {
  403d7a:	6863      	ldr	r3, [r4, #4]
  403d7c:	2b00      	cmp	r3, #0
  403d7e:	d0fa      	beq.n	403d76 <usbdc_request_handler+0x12>
			rc = h->cb(ep, req, stage);
  403d80:	462a      	mov	r2, r5
  403d82:	4631      	mov	r1, r6
  403d84:	4638      	mov	r0, r7
  403d86:	4798      	blx	r3
			if (0 == rc) {
  403d88:	b130      	cbz	r0, 403d98 <usbdc_request_handler+0x34>
			} else if (ERR_NOT_FOUND != rc) {
  403d8a:	f110 0f0a 	cmn.w	r0, #10
  403d8e:	d0f2      	beq.n	403d76 <usbdc_request_handler+0x12>
				return false;
  403d90:	2000      	movs	r0, #0
}
  403d92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return false;
  403d94:	2000      	movs	r0, #0
  403d96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				return true;
  403d98:	2001      	movs	r0, #1
  403d9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  403d9c:	20400c30 	.word	0x20400c30

00403da0 <usbd_sof_cb>:

/**
 * \brief Callback invoked on USB device SOF
 */
static void usbd_sof_cb(void)
{
  403da0:	b510      	push	{r4, lr}
	struct usbdc_sof_handler *sof = (struct usbdc_sof_handler *)usbdc.handlers.sof_list.head;
  403da2:	4b06      	ldr	r3, [pc, #24]	; (403dbc <usbd_sof_cb+0x1c>)
  403da4:	685c      	ldr	r4, [r3, #4]
	while (sof != NULL) {
  403da6:	b91c      	cbnz	r4, 403db0 <usbd_sof_cb+0x10>
  403da8:	bd10      	pop	{r4, pc}
		sof = sof->next;
  403daa:	6824      	ldr	r4, [r4, #0]
	while (sof != NULL) {
  403dac:	2c00      	cmp	r4, #0
  403dae:	d0fb      	beq.n	403da8 <usbd_sof_cb+0x8>
		if (NULL != sof->cb) {
  403db0:	6863      	ldr	r3, [r4, #4]
  403db2:	2b00      	cmp	r3, #0
  403db4:	d0f9      	beq.n	403daa <usbd_sof_cb+0xa>
			sof->cb();
  403db6:	4798      	blx	r3
  403db8:	e7f7      	b.n	403daa <usbd_sof_cb+0xa>
  403dba:	bf00      	nop
  403dbc:	20400c30 	.word	0x20400c30

00403dc0 <usbdc_cb_ctl_done>:
 * \return Data has error or not.
 * \retval true There is data error, protocol error.
 * \retval false There is no data error.
 */
static bool usbdc_cb_ctl_done(const uint8_t ep, const enum usb_xfer_code code, struct usb_req *req)
{
  403dc0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  403dc4:	b083      	sub	sp, #12
  403dc6:	4616      	mov	r6, r2
	(void)ep;

	switch (code) {
  403dc8:	b129      	cbz	r1, 403dd6 <usbdc_cb_ctl_done+0x16>
  403dca:	2901      	cmp	r1, #1
  403dcc:	d065      	beq.n	403e9a <usbdc_cb_ctl_done+0xda>
		return usbdc_ctrl_data_end(req);
	default:
		break;
	}
	return false;
}
  403dce:	2000      	movs	r0, #0
  403dd0:	b003      	add	sp, #12
  403dd2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	switch (req->bRequest) {
  403dd6:	7853      	ldrb	r3, [r2, #1]
  403dd8:	2b05      	cmp	r3, #5
  403dda:	d04f      	beq.n	403e7c <usbdc_cb_ctl_done+0xbc>
  403ddc:	2b09      	cmp	r3, #9
  403dde:	d1f6      	bne.n	403dce <usbdc_cb_ctl_done+0xe>
		usbdc.cfg_value = req->wValue;
  403de0:	8852      	ldrh	r2, [r2, #2]
  403de2:	b2d2      	uxtb	r2, r2
  403de4:	4b30      	ldr	r3, [pc, #192]	; (403ea8 <usbdc_cb_ctl_done+0xe8>)
  403de6:	76da      	strb	r2, [r3, #27]
	if (usbdc.cfg_value == 0) {
  403de8:	b962      	cbnz	r2, 403e04 <usbdc_cb_ctl_done+0x44>
		usbdc_unconfig();
  403dea:	4b30      	ldr	r3, [pc, #192]	; (403eac <usbdc_cb_ctl_done+0xec>)
  403dec:	4798      	blx	r3
		usbdc.state = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
  403dee:	8873      	ldrh	r3, [r6, #2]
  403df0:	2b00      	cmp	r3, #0
  403df2:	bf14      	ite	ne
  403df4:	2104      	movne	r1, #4
  403df6:	2103      	moveq	r1, #3
  403df8:	4b2b      	ldr	r3, [pc, #172]	; (403ea8 <usbdc_cb_ctl_done+0xe8>)
  403dfa:	7699      	strb	r1, [r3, #26]
		usbdc_change_notify(USBDC_C_STATE, usbdc.state);
  403dfc:	2001      	movs	r0, #1
  403dfe:	4b2c      	ldr	r3, [pc, #176]	; (403eb0 <usbdc_cb_ctl_done+0xf0>)
  403e00:	4798      	blx	r3
  403e02:	e7e4      	b.n	403dce <usbdc_cb_ctl_done+0xe>
	cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
  403e04:	4b28      	ldr	r3, [pc, #160]	; (403ea8 <usbdc_cb_ctl_done+0xe8>)
  403e06:	681b      	ldr	r3, [r3, #0]
  403e08:	6859      	ldr	r1, [r3, #4]
  403e0a:	6818      	ldr	r0, [r3, #0]
  403e0c:	4b29      	ldr	r3, [pc, #164]	; (403eb4 <usbdc_cb_ctl_done+0xf4>)
  403e0e:	4798      	blx	r3
	if (NULL == cfg_desc) {
  403e10:	2800      	cmp	r0, #0
  403e12:	d0ec      	beq.n	403dee <usbdc_cb_ctl_done+0x2e>
	return (ptr[0] + (ptr[1] << 8));
  403e14:	78c2      	ldrb	r2, [r0, #3]
  403e16:	7881      	ldrb	r1, [r0, #2]
  403e18:	eb01 2102 	add.w	r1, r1, r2, lsl #8
	desc.eod  = cfg_desc + total_len;
  403e1c:	fa10 f181 	uxtah	r1, r0, r1
  403e20:	9101      	str	r1, [sp, #4]
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
  403e22:	2204      	movs	r2, #4
  403e24:	4b24      	ldr	r3, [pc, #144]	; (403eb8 <usbdc_cb_ctl_done+0xf8>)
  403e26:	4798      	blx	r3
  403e28:	9000      	str	r0, [sp, #0]
	while (NULL != desc.sod) {
  403e2a:	2800      	cmp	r0, #0
  403e2c:	d0df      	beq.n	403dee <usbdc_cb_ctl_done+0x2e>
  403e2e:	24ff      	movs	r4, #255	; 0xff
			func       = (struct usbdf_driver *)usbdc.func_list.head;
  403e30:	f8df 8074 	ldr.w	r8, [pc, #116]	; 403ea8 <usbdc_cb_ctl_done+0xe8>
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
  403e34:	4f20      	ldr	r7, [pc, #128]	; (403eb8 <usbdc_cb_ctl_done+0xf8>)
  403e36:	e00c      	b.n	403e52 <usbdc_cb_ctl_done+0x92>
			last_iface = desc.sod[2];
  403e38:	464c      	mov	r4, r9
  403e3a:	e000      	b.n	403e3e <usbdc_cb_ctl_done+0x7e>
  403e3c:	464c      	mov	r4, r9
		desc.sod = usb_desc_next(desc.sod);
  403e3e:	9800      	ldr	r0, [sp, #0]
	return (desc + usb_desc_len(desc));
  403e40:	7803      	ldrb	r3, [r0, #0]
  403e42:	4418      	add	r0, r3
  403e44:	9000      	str	r0, [sp, #0]
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
  403e46:	2204      	movs	r2, #4
  403e48:	9901      	ldr	r1, [sp, #4]
  403e4a:	47b8      	blx	r7
  403e4c:	9000      	str	r0, [sp, #0]
	while (NULL != desc.sod) {
  403e4e:	2800      	cmp	r0, #0
  403e50:	d0cd      	beq.n	403dee <usbdc_cb_ctl_done+0x2e>
		if (last_iface != desc.sod[2] /* bInterfaceNumber */) {
  403e52:	f890 9002 	ldrb.w	r9, [r0, #2]
  403e56:	45a1      	cmp	r9, r4
  403e58:	d0f1      	beq.n	403e3e <usbdc_cb_ctl_done+0x7e>
			func       = (struct usbdf_driver *)usbdc.func_list.head;
  403e5a:	f8d8 4010 	ldr.w	r4, [r8, #16]
			while (NULL != func) {
  403e5e:	2c00      	cmp	r4, #0
  403e60:	d0ea      	beq.n	403e38 <usbdc_cb_ctl_done+0x78>
				if (func->ctrl(func, USBDF_ENABLE, &desc)) {
  403e62:	2500      	movs	r5, #0
  403e64:	6863      	ldr	r3, [r4, #4]
  403e66:	466a      	mov	r2, sp
  403e68:	4629      	mov	r1, r5
  403e6a:	4620      	mov	r0, r4
  403e6c:	4798      	blx	r3
  403e6e:	2800      	cmp	r0, #0
  403e70:	d0e4      	beq.n	403e3c <usbdc_cb_ctl_done+0x7c>
					func = func->next;
  403e72:	6824      	ldr	r4, [r4, #0]
			while (NULL != func) {
  403e74:	2c00      	cmp	r4, #0
  403e76:	d1f5      	bne.n	403e64 <usbdc_cb_ctl_done+0xa4>
			last_iface = desc.sod[2];
  403e78:	464c      	mov	r4, r9
  403e7a:	e7e0      	b.n	403e3e <usbdc_cb_ctl_done+0x7e>
		usbdc_set_address(req->wValue);
  403e7c:	8850      	ldrh	r0, [r2, #2]
	usb_d_set_address(addr);
  403e7e:	b2c0      	uxtb	r0, r0
  403e80:	4b0e      	ldr	r3, [pc, #56]	; (403ebc <usbdc_cb_ctl_done+0xfc>)
  403e82:	4798      	blx	r3
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
  403e84:	8873      	ldrh	r3, [r6, #2]
  403e86:	2b00      	cmp	r3, #0
  403e88:	bf14      	ite	ne
  403e8a:	2103      	movne	r1, #3
  403e8c:	2102      	moveq	r1, #2
  403e8e:	4b06      	ldr	r3, [pc, #24]	; (403ea8 <usbdc_cb_ctl_done+0xe8>)
  403e90:	7699      	strb	r1, [r3, #26]
		usbdc_change_notify(USBDC_C_STATE, usbdc.state);
  403e92:	2001      	movs	r0, #1
  403e94:	4b06      	ldr	r3, [pc, #24]	; (403eb0 <usbdc_cb_ctl_done+0xf0>)
  403e96:	4798      	blx	r3
  403e98:	e799      	b.n	403dce <usbdc_cb_ctl_done+0xe>
	usbdc_request_handler(0, req, USB_DATA_STAGE);
  403e9a:	2201      	movs	r2, #1
  403e9c:	4631      	mov	r1, r6
  403e9e:	2000      	movs	r0, #0
  403ea0:	4b07      	ldr	r3, [pc, #28]	; (403ec0 <usbdc_cb_ctl_done+0x100>)
  403ea2:	4798      	blx	r3
		return usbdc_ctrl_data_end(req);
  403ea4:	e793      	b.n	403dce <usbdc_cb_ctl_done+0xe>
  403ea6:	bf00      	nop
  403ea8:	20400c30 	.word	0x20400c30
  403eac:	00403d19 	.word	0x00403d19
  403eb0:	00403d3d 	.word	0x00403d3d
  403eb4:	004043a9 	.word	0x004043a9
  403eb8:	00404329 	.word	0x00404329
  403ebc:	00400945 	.word	0x00400945
  403ec0:	00403d65 	.word	0x00403d65

00403ec4 <usbdc_reset>:

/**
 * \brief USB Device Core Reset
 */
void usbdc_reset(void)
{
  403ec4:	b570      	push	{r4, r5, r6, lr}
	usbdc_unconfig();
  403ec6:	4b0d      	ldr	r3, [pc, #52]	; (403efc <usbdc_reset+0x38>)
  403ec8:	4798      	blx	r3

	usbdc.state     = USBD_S_DEFAULT;
  403eca:	4d0d      	ldr	r5, [pc, #52]	; (403f00 <usbdc_reset+0x3c>)
  403ecc:	2602      	movs	r6, #2
  403ece:	76ae      	strb	r6, [r5, #26]
	usbdc.cfg_value = 0;
  403ed0:	2400      	movs	r4, #0
  403ed2:	76ec      	strb	r4, [r5, #27]

	// Setup EP0
	usb_d_ep_deinit(0);
  403ed4:	4620      	mov	r0, r4
  403ed6:	4b0b      	ldr	r3, [pc, #44]	; (403f04 <usbdc_reset+0x40>)
  403ed8:	4798      	blx	r3
	usb_d_ep0_init(usbdc.ctrl_size);
  403eda:	7f28      	ldrb	r0, [r5, #28]
  403edc:	4b0a      	ldr	r3, [pc, #40]	; (403f08 <usbdc_reset+0x44>)
  403ede:	4798      	blx	r3
	usb_d_ep_register_callback(0, USB_D_EP_CB_SETUP, (FUNC_PTR)usbdc_cb_ctl_req);
  403ee0:	4a0a      	ldr	r2, [pc, #40]	; (403f0c <usbdc_reset+0x48>)
  403ee2:	4621      	mov	r1, r4
  403ee4:	4620      	mov	r0, r4
  403ee6:	4d0a      	ldr	r5, [pc, #40]	; (403f10 <usbdc_reset+0x4c>)
  403ee8:	47a8      	blx	r5
	usb_d_ep_register_callback(0, USB_D_EP_CB_XFER, (FUNC_PTR)usbdc_cb_ctl_done);
  403eea:	4a0a      	ldr	r2, [pc, #40]	; (403f14 <usbdc_reset+0x50>)
  403eec:	4631      	mov	r1, r6
  403eee:	4620      	mov	r0, r4
  403ef0:	47a8      	blx	r5
	usb_d_ep_enable(0);
  403ef2:	4620      	mov	r0, r4
  403ef4:	4b08      	ldr	r3, [pc, #32]	; (403f18 <usbdc_reset+0x54>)
  403ef6:	4798      	blx	r3
  403ef8:	bd70      	pop	{r4, r5, r6, pc}
  403efa:	bf00      	nop
  403efc:	00403d19 	.word	0x00403d19
  403f00:	20400c30 	.word	0x20400c30
  403f04:	004009b9 	.word	0x004009b9
  403f08:	004009a5 	.word	0x004009a5
  403f0c:	00403f5d 	.word	0x00403f5d
  403f10:	00400bb5 	.word	0x00400bb5
  403f14:	00403dc1 	.word	0x00403dc1
  403f18:	004009e5 	.word	0x004009e5

00403f1c <usbd_event_cb>:
 * \brief Callback invoked on USB device events
 * \param[in] ev Event code.
 * \param[in] param Event parameter for event handling.
 */
static void usbd_event_cb(const enum usb_event ev, const uint32_t param)
{
  403f1c:	b508      	push	{r3, lr}
	(void)param;

	switch (ev) {
  403f1e:	b110      	cbz	r0, 403f26 <usbd_event_cb+0xa>
  403f20:	2801      	cmp	r0, #1
  403f22:	d004      	beq.n	403f2e <usbd_event_cb+0x12>
  403f24:	bd08      	pop	{r3, pc}
	case USB_EV_VBUS:
		usbdc_change_notify(USBDC_C_CONN, param);
  403f26:	2000      	movs	r0, #0
  403f28:	4b02      	ldr	r3, [pc, #8]	; (403f34 <usbd_event_cb+0x18>)
  403f2a:	4798      	blx	r3
		break;
  403f2c:	bd08      	pop	{r3, pc}

	case USB_EV_RESET:
		usbdc_reset();
  403f2e:	4b02      	ldr	r3, [pc, #8]	; (403f38 <usbd_event_cb+0x1c>)
  403f30:	4798      	blx	r3
  403f32:	bd08      	pop	{r3, pc}
  403f34:	00403d3d 	.word	0x00403d3d
  403f38:	00403ec5 	.word	0x00403ec5

00403f3c <usbdc_xfer>:

/**
 * \brief Issue USB device transfer
 */
int32_t usbdc_xfer(uint8_t ep, uint8_t *buf, uint32_t size, bool zlp)
{
  403f3c:	b500      	push	{lr}
  403f3e:	b085      	sub	sp, #20
	struct usb_d_transfer xfer = {(uint8_t *)buf, size, ep, zlp};
  403f40:	9101      	str	r1, [sp, #4]
  403f42:	9202      	str	r2, [sp, #8]
  403f44:	f88d 000c 	strb.w	r0, [sp, #12]
  403f48:	f88d 300d 	strb.w	r3, [sp, #13]
	return usb_d_ep_transfer(&xfer);
  403f4c:	a801      	add	r0, sp, #4
  403f4e:	4b02      	ldr	r3, [pc, #8]	; (403f58 <usbdc_xfer+0x1c>)
  403f50:	4798      	blx	r3
}
  403f52:	b005      	add	sp, #20
  403f54:	f85d fb04 	ldr.w	pc, [sp], #4
  403f58:	00400a31 	.word	0x00400a31

00403f5c <usbdc_cb_ctl_req>:
{
  403f5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  403f60:	b082      	sub	sp, #8
  403f62:	4606      	mov	r6, r0
  403f64:	460c      	mov	r4, r1
	if (usbdc_request_handler(ep, req, USB_SETUP_STAGE)) {
  403f66:	2200      	movs	r2, #0
  403f68:	4ba6      	ldr	r3, [pc, #664]	; (404204 <usbdc_cb_ctl_req+0x2a8>)
  403f6a:	4798      	blx	r3
  403f6c:	4605      	mov	r5, r0
  403f6e:	b930      	cbnz	r0, 403f7e <usbdc_cb_ctl_req+0x22>
	switch (req->bmRequestType & (USB_REQT_TYPE_MASK | USB_REQT_DIR_IN)) {
  403f70:	7823      	ldrb	r3, [r4, #0]
  403f72:	f013 02e0 	ands.w	r2, r3, #224	; 0xe0
  403f76:	d006      	beq.n	403f86 <usbdc_cb_ctl_req+0x2a>
  403f78:	2a80      	cmp	r2, #128	; 0x80
  403f7a:	f000 8089 	beq.w	404090 <usbdc_cb_ctl_req+0x134>
}
  403f7e:	4628      	mov	r0, r5
  403f80:	b002      	add	sp, #8
  403f82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (req->bRequest) {
  403f86:	7862      	ldrb	r2, [r4, #1]
  403f88:	3a01      	subs	r2, #1
  403f8a:	2a0a      	cmp	r2, #10
  403f8c:	d8f7      	bhi.n	403f7e <usbdc_cb_ctl_req+0x22>
  403f8e:	a101      	add	r1, pc, #4	; (adr r1, 403f94 <usbdc_cb_ctl_req+0x38>)
  403f90:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
  403f94:	00403fd5 	.word	0x00403fd5
  403f98:	00403f7f 	.word	0x00403f7f
  403f9c:	00403ff1 	.word	0x00403ff1
  403fa0:	00403f7f 	.word	0x00403f7f
  403fa4:	00403fc1 	.word	0x00403fc1
  403fa8:	00403f7f 	.word	0x00403f7f
  403fac:	00403f7f 	.word	0x00403f7f
  403fb0:	00403f7f 	.word	0x00403f7f
  403fb4:	00403fc1 	.word	0x00403fc1
  403fb8:	00403f7f 	.word	0x00403f7f
  403fbc:	0040400d 	.word	0x0040400d
		if (ERR_NONE == usbdc_xfer(ep, NULL, 0, true)) {
  403fc0:	2301      	movs	r3, #1
  403fc2:	2200      	movs	r2, #0
  403fc4:	4611      	mov	r1, r2
  403fc6:	4630      	mov	r0, r6
  403fc8:	4c8f      	ldr	r4, [pc, #572]	; (404208 <usbdc_cb_ctl_req+0x2ac>)
  403fca:	47a0      	blx	r4
  403fcc:	fab0 f580 	clz	r5, r0
  403fd0:	096d      	lsrs	r5, r5, #5
  403fd2:	e7d4      	b.n	403f7e <usbdc_cb_ctl_req+0x22>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
  403fd4:	f003 031f 	and.w	r3, r3, #31
  403fd8:	2b02      	cmp	r3, #2
  403fda:	d1d0      	bne.n	403f7e <usbdc_cb_ctl_req+0x22>
		if (req->wLength != 0) {
  403fdc:	88e3      	ldrh	r3, [r4, #6]
  403fde:	2b00      	cmp	r3, #0
  403fe0:	d1cd      	bne.n	403f7e <usbdc_cb_ctl_req+0x22>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_CLR);
  403fe2:	88a0      	ldrh	r0, [r4, #4]
  403fe4:	2100      	movs	r1, #0
  403fe6:	b2c0      	uxtb	r0, r0
  403fe8:	4b88      	ldr	r3, [pc, #544]	; (40420c <usbdc_cb_ctl_req+0x2b0>)
  403fea:	4798      	blx	r3
		return true;
  403fec:	2501      	movs	r5, #1
  403fee:	e7c6      	b.n	403f7e <usbdc_cb_ctl_req+0x22>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
  403ff0:	f003 031f 	and.w	r3, r3, #31
  403ff4:	2b02      	cmp	r3, #2
  403ff6:	d1c2      	bne.n	403f7e <usbdc_cb_ctl_req+0x22>
		if (req->wLength != 0) {
  403ff8:	88e3      	ldrh	r3, [r4, #6]
  403ffa:	2b00      	cmp	r3, #0
  403ffc:	d1bf      	bne.n	403f7e <usbdc_cb_ctl_req+0x22>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_SET);
  403ffe:	88a0      	ldrh	r0, [r4, #4]
  404000:	2101      	movs	r1, #1
  404002:	b2c0      	uxtb	r0, r0
  404004:	4b81      	ldr	r3, [pc, #516]	; (40420c <usbdc_cb_ctl_req+0x2b0>)
  404006:	4798      	blx	r3
		return true;
  404008:	2501      	movs	r5, #1
  40400a:	e7b8      	b.n	403f7e <usbdc_cb_ctl_req+0x22>
		return usbdc_set_interface(req->wValue, req->wIndex);
  40400c:	8867      	ldrh	r7, [r4, #2]
  40400e:	88a4      	ldrh	r4, [r4, #4]
	desc.sod = usbdc.desces.ls_fs->sod;
  404010:	4b7f      	ldr	r3, [pc, #508]	; (404210 <usbdc_cb_ctl_req+0x2b4>)
  404012:	681b      	ldr	r3, [r3, #0]
  404014:	6818      	ldr	r0, [r3, #0]
  404016:	9000      	str	r0, [sp, #0]
	desc.eod = usbdc.desces.ls_fs->eod;
  404018:	6859      	ldr	r1, [r3, #4]
  40401a:	9101      	str	r1, [sp, #4]
	if (NULL == (ifc = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE))) {
  40401c:	2204      	movs	r2, #4
  40401e:	4b7d      	ldr	r3, [pc, #500]	; (404214 <usbdc_cb_ctl_req+0x2b8>)
  404020:	4798      	blx	r3
  404022:	4603      	mov	r3, r0
  404024:	2800      	cmp	r0, #0
  404026:	d0aa      	beq.n	403f7e <usbdc_cb_ctl_req+0x22>
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
  404028:	f04f 0804 	mov.w	r8, #4
  40402c:	4e79      	ldr	r6, [pc, #484]	; (404214 <usbdc_cb_ctl_req+0x2b8>)
  40402e:	e009      	b.n	404044 <usbdc_cb_ctl_req+0xe8>
		desc.sod = usb_desc_next(desc.sod);
  404030:	9800      	ldr	r0, [sp, #0]
  404032:	7803      	ldrb	r3, [r0, #0]
  404034:	4418      	add	r0, r3
  404036:	9000      	str	r0, [sp, #0]
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
  404038:	4642      	mov	r2, r8
  40403a:	9901      	ldr	r1, [sp, #4]
  40403c:	47b0      	blx	r6
		if (NULL == ifc) {
  40403e:	4603      	mov	r3, r0
  404040:	2800      	cmp	r0, #0
  404042:	d09c      	beq.n	403f7e <usbdc_cb_ctl_req+0x22>
	while (ifc[2] != ifc_id || ifc[3] != alt_set) {
  404044:	789a      	ldrb	r2, [r3, #2]
  404046:	42a2      	cmp	r2, r4
  404048:	d1f2      	bne.n	404030 <usbdc_cb_ctl_req+0xd4>
  40404a:	78da      	ldrb	r2, [r3, #3]
  40404c:	42ba      	cmp	r2, r7
  40404e:	d1ef      	bne.n	404030 <usbdc_cb_ctl_req+0xd4>
	desc.sod = ifc;
  404050:	9300      	str	r3, [sp, #0]
	func     = (struct usbdf_driver *)usbdc.func_list.head;
  404052:	4b6f      	ldr	r3, [pc, #444]	; (404210 <usbdc_cb_ctl_req+0x2b4>)
  404054:	691c      	ldr	r4, [r3, #16]
	while (NULL != func) {
  404056:	2c00      	cmp	r4, #0
  404058:	d091      	beq.n	403f7e <usbdc_cb_ctl_req+0x22>
		if (func->ctrl(func, USBDF_DISABLE, &desc)) {
  40405a:	2601      	movs	r6, #1
  40405c:	6863      	ldr	r3, [r4, #4]
  40405e:	466a      	mov	r2, sp
  404060:	4631      	mov	r1, r6
  404062:	4620      	mov	r0, r4
  404064:	4798      	blx	r3
  404066:	b118      	cbz	r0, 404070 <usbdc_cb_ctl_req+0x114>
			func = func->next;
  404068:	6824      	ldr	r4, [r4, #0]
	while (NULL != func) {
  40406a:	2c00      	cmp	r4, #0
  40406c:	d1f6      	bne.n	40405c <usbdc_cb_ctl_req+0x100>
  40406e:	e786      	b.n	403f7e <usbdc_cb_ctl_req+0x22>
		} else if (ERR_NONE == func->ctrl(func, USBDF_ENABLE, &desc)) {
  404070:	6863      	ldr	r3, [r4, #4]
  404072:	466a      	mov	r2, sp
  404074:	2100      	movs	r1, #0
  404076:	4620      	mov	r0, r4
  404078:	4798      	blx	r3
  40407a:	2800      	cmp	r0, #0
  40407c:	f47f af7f 	bne.w	403f7e <usbdc_cb_ctl_req+0x22>
			usbdc_xfer(0, NULL, 0, 0);
  404080:	2300      	movs	r3, #0
  404082:	461a      	mov	r2, r3
  404084:	4619      	mov	r1, r3
  404086:	4618      	mov	r0, r3
  404088:	4c5f      	ldr	r4, [pc, #380]	; (404208 <usbdc_cb_ctl_req+0x2ac>)
  40408a:	47a0      	blx	r4
			return true;
  40408c:	2501      	movs	r5, #1
  40408e:	e776      	b.n	403f7e <usbdc_cb_ctl_req+0x22>
	switch (req->bRequest) {
  404090:	7862      	ldrb	r2, [r4, #1]
  404092:	2a0a      	cmp	r2, #10
  404094:	f63f af73 	bhi.w	403f7e <usbdc_cb_ctl_req+0x22>
  404098:	a101      	add	r1, pc, #4	; (adr r1, 4040a0 <usbdc_cb_ctl_req+0x144>)
  40409a:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
  40409e:	bf00      	nop
  4040a0:	00404187 	.word	0x00404187
  4040a4:	00403f7f 	.word	0x00403f7f
  4040a8:	00403f7f 	.word	0x00403f7f
  4040ac:	00403f7f 	.word	0x00403f7f
  4040b0:	00403f7f 	.word	0x00403f7f
  4040b4:	00403f7f 	.word	0x00403f7f
  4040b8:	004040cd 	.word	0x004040cd
  4040bc:	00403f7f 	.word	0x00403f7f
  4040c0:	0040416f 	.word	0x0040416f
  4040c4:	00403f7f 	.word	0x00403f7f
  4040c8:	004041cb 	.word	0x004041cb
	uint16_t length   = req->wLength;
  4040cc:	88e7      	ldrh	r7, [r4, #6]
	uint8_t  type     = (uint8_t)(req->wValue >> 8);
  4040ce:	8863      	ldrh	r3, [r4, #2]
	uint8_t  index    = req->wValue & 0x00FF;
  4040d0:	b2da      	uxtb	r2, r3
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
  4040d2:	494f      	ldr	r1, [pc, #316]	; (404210 <usbdc_cb_ctl_req+0x2b4>)
  4040d4:	7f09      	ldrb	r1, [r1, #28]
  4040d6:	3901      	subs	r1, #1
  4040d8:	4239      	tst	r1, r7
  4040da:	bf0c      	ite	eq
  4040dc:	2401      	moveq	r4, #1
  4040de:	2400      	movne	r4, #0
	switch (type) {
  4040e0:	0a1b      	lsrs	r3, r3, #8
  4040e2:	2b02      	cmp	r3, #2
  4040e4:	d011      	beq.n	40410a <usbdc_cb_ctl_req+0x1ae>
  4040e6:	2b03      	cmp	r3, #3
  4040e8:	d02b      	beq.n	404142 <usbdc_cb_ctl_req+0x1e6>
  4040ea:	2b01      	cmp	r3, #1
  4040ec:	f47f af47 	bne.w	403f7e <usbdc_cb_ctl_req+0x22>
		usbdc_xfer(ep, usbdc.desces.ls_fs->sod, length, false);
  4040f0:	4b47      	ldr	r3, [pc, #284]	; (404210 <usbdc_cb_ctl_req+0x2b4>)
  4040f2:	6819      	ldr	r1, [r3, #0]
  4040f4:	2300      	movs	r3, #0
  4040f6:	463a      	mov	r2, r7
  4040f8:	2f12      	cmp	r7, #18
  4040fa:	bf28      	it	cs
  4040fc:	2212      	movcs	r2, #18
  4040fe:	6809      	ldr	r1, [r1, #0]
  404100:	4630      	mov	r0, r6
  404102:	4c41      	ldr	r4, [pc, #260]	; (404208 <usbdc_cb_ctl_req+0x2ac>)
  404104:	47a0      	blx	r4
		return true;
  404106:	2501      	movs	r5, #1
  404108:	e739      	b.n	403f7e <usbdc_cb_ctl_req+0x22>
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index + 1);
  40410a:	4b41      	ldr	r3, [pc, #260]	; (404210 <usbdc_cb_ctl_req+0x2b4>)
  40410c:	681b      	ldr	r3, [r3, #0]
  40410e:	3201      	adds	r2, #1
  404110:	b2d2      	uxtb	r2, r2
  404112:	6859      	ldr	r1, [r3, #4]
  404114:	6818      	ldr	r0, [r3, #0]
  404116:	4b40      	ldr	r3, [pc, #256]	; (404218 <usbdc_cb_ctl_req+0x2bc>)
  404118:	4798      	blx	r3
		if (NULL == cfg_desc) {
  40411a:	4601      	mov	r1, r0
  40411c:	2800      	cmp	r0, #0
  40411e:	f43f af2e 	beq.w	403f7e <usbdc_cb_ctl_req+0x22>
	return (ptr[0] + (ptr[1] << 8));
  404122:	78c2      	ldrb	r2, [r0, #3]
  404124:	7883      	ldrb	r3, [r0, #2]
  404126:	eb03 2302 	add.w	r3, r3, r2, lsl #8
  40412a:	b29b      	uxth	r3, r3
		if (length <= total_len) {
  40412c:	429f      	cmp	r7, r3
  40412e:	d901      	bls.n	404134 <usbdc_cb_ctl_req+0x1d8>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
  404130:	4625      	mov	r5, r4
			length = total_len;
  404132:	461f      	mov	r7, r3
		usbdc_xfer(ep, cfg_desc, length, need_zlp);
  404134:	462b      	mov	r3, r5
  404136:	463a      	mov	r2, r7
  404138:	4630      	mov	r0, r6
  40413a:	4c33      	ldr	r4, [pc, #204]	; (404208 <usbdc_cb_ctl_req+0x2ac>)
  40413c:	47a0      	blx	r4
		return true;
  40413e:	2501      	movs	r5, #1
  404140:	e71d      	b.n	403f7e <usbdc_cb_ctl_req+0x22>
		str_desc = usb_find_str_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index);
  404142:	4b33      	ldr	r3, [pc, #204]	; (404210 <usbdc_cb_ctl_req+0x2b4>)
  404144:	681b      	ldr	r3, [r3, #0]
  404146:	6859      	ldr	r1, [r3, #4]
  404148:	6818      	ldr	r0, [r3, #0]
  40414a:	4b34      	ldr	r3, [pc, #208]	; (40421c <usbdc_cb_ctl_req+0x2c0>)
  40414c:	4798      	blx	r3
		if (NULL == str_desc) {
  40414e:	4601      	mov	r1, r0
  404150:	2800      	cmp	r0, #0
  404152:	f43f af14 	beq.w	403f7e <usbdc_cb_ctl_req+0x22>
		total_len = str_desc[0];
  404156:	7803      	ldrb	r3, [r0, #0]
		if (length <= total_len) {
  404158:	429f      	cmp	r7, r3
  40415a:	d901      	bls.n	404160 <usbdc_cb_ctl_req+0x204>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
  40415c:	4625      	mov	r5, r4
			length = total_len;
  40415e:	461f      	mov	r7, r3
		usbdc_xfer(ep, str_desc, length, need_zlp);
  404160:	462b      	mov	r3, r5
  404162:	463a      	mov	r2, r7
  404164:	4630      	mov	r0, r6
  404166:	4c28      	ldr	r4, [pc, #160]	; (404208 <usbdc_cb_ctl_req+0x2ac>)
  404168:	47a0      	blx	r4
		return true;
  40416a:	2501      	movs	r5, #1
  40416c:	e707      	b.n	403f7e <usbdc_cb_ctl_req+0x22>
		*(uint8_t *)usbdc.ctrl_buf = usbdc.cfg_value;
  40416e:	4928      	ldr	r1, [pc, #160]	; (404210 <usbdc_cb_ctl_req+0x2b4>)
  404170:	694b      	ldr	r3, [r1, #20]
  404172:	7eca      	ldrb	r2, [r1, #27]
  404174:	701a      	strb	r2, [r3, #0]
		usbdc_xfer(ep, usbdc.ctrl_buf, 1, false);
  404176:	2300      	movs	r3, #0
  404178:	2201      	movs	r2, #1
  40417a:	6949      	ldr	r1, [r1, #20]
  40417c:	4630      	mov	r0, r6
  40417e:	4c22      	ldr	r4, [pc, #136]	; (404208 <usbdc_cb_ctl_req+0x2ac>)
  404180:	47a0      	blx	r4
		return true;
  404182:	2501      	movs	r5, #1
  404184:	e6fb      	b.n	403f7e <usbdc_cb_ctl_req+0x22>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
  404186:	f003 031f 	and.w	r3, r3, #31
  40418a:	2b01      	cmp	r3, #1
  40418c:	d90e      	bls.n	4041ac <usbdc_cb_ctl_req+0x250>
  40418e:	2b02      	cmp	r3, #2
  404190:	f47f aef5 	bne.w	403f7e <usbdc_cb_ctl_req+0x22>
		st = usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_GET);
  404194:	88a0      	ldrh	r0, [r4, #4]
  404196:	2102      	movs	r1, #2
  404198:	b2c0      	uxtb	r0, r0
  40419a:	4b1c      	ldr	r3, [pc, #112]	; (40420c <usbdc_cb_ctl_req+0x2b0>)
  40419c:	4798      	blx	r3
		if (st < 0) {
  40419e:	2800      	cmp	r0, #0
  4041a0:	f6ff aeed 	blt.w	403f7e <usbdc_cb_ctl_req+0x22>
		st = st & 0x1;
  4041a4:	f000 0001 	and.w	r0, r0, #1
  4041a8:	9000      	str	r0, [sp, #0]
  4041aa:	e001      	b.n	4041b0 <usbdc_cb_ctl_req+0x254>
		st = 0;
  4041ac:	2300      	movs	r3, #0
  4041ae:	9300      	str	r3, [sp, #0]
	memcpy(usbdc.ctrl_buf, &st, 2);
  4041b0:	4917      	ldr	r1, [pc, #92]	; (404210 <usbdc_cb_ctl_req+0x2b4>)
  4041b2:	694b      	ldr	r3, [r1, #20]
  4041b4:	f8bd 2000 	ldrh.w	r2, [sp]
  4041b8:	801a      	strh	r2, [r3, #0]
	usbdc_xfer(ep, usbdc.ctrl_buf, 2, false);
  4041ba:	2300      	movs	r3, #0
  4041bc:	2202      	movs	r2, #2
  4041be:	6949      	ldr	r1, [r1, #20]
  4041c0:	4630      	mov	r0, r6
  4041c2:	4c11      	ldr	r4, [pc, #68]	; (404208 <usbdc_cb_ctl_req+0x2ac>)
  4041c4:	47a0      	blx	r4
	return true;
  4041c6:	2501      	movs	r5, #1
  4041c8:	e6d9      	b.n	403f7e <usbdc_cb_ctl_req+0x22>
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
  4041ca:	4b11      	ldr	r3, [pc, #68]	; (404210 <usbdc_cb_ctl_req+0x2b4>)
  4041cc:	691e      	ldr	r6, [r3, #16]
	while (NULL != func) {
  4041ce:	2e00      	cmp	r6, #0
  4041d0:	f43f aed5 	beq.w	403f7e <usbdc_cb_ctl_req+0x22>
		if (0 > (rc = func->ctrl(func, USBDF_GET_IFACE, req))) {
  4041d4:	2702      	movs	r7, #2
  4041d6:	6873      	ldr	r3, [r6, #4]
  4041d8:	4622      	mov	r2, r4
  4041da:	4639      	mov	r1, r7
  4041dc:	4630      	mov	r0, r6
  4041de:	4798      	blx	r3
  4041e0:	2800      	cmp	r0, #0
  4041e2:	da03      	bge.n	4041ec <usbdc_cb_ctl_req+0x290>
			func = func->next;
  4041e4:	6836      	ldr	r6, [r6, #0]
	while (NULL != func) {
  4041e6:	2e00      	cmp	r6, #0
  4041e8:	d1f5      	bne.n	4041d6 <usbdc_cb_ctl_req+0x27a>
  4041ea:	e6c8      	b.n	403f7e <usbdc_cb_ctl_req+0x22>
			usbdc.ctrl_buf[0] = (uint8_t)rc;
  4041ec:	4908      	ldr	r1, [pc, #32]	; (404210 <usbdc_cb_ctl_req+0x2b4>)
  4041ee:	694b      	ldr	r3, [r1, #20]
  4041f0:	7018      	strb	r0, [r3, #0]
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
  4041f2:	2300      	movs	r3, #0
  4041f4:	2201      	movs	r2, #1
  4041f6:	6949      	ldr	r1, [r1, #20]
  4041f8:	4618      	mov	r0, r3
  4041fa:	4c03      	ldr	r4, [pc, #12]	; (404208 <usbdc_cb_ctl_req+0x2ac>)
  4041fc:	47a0      	blx	r4
			return true;
  4041fe:	2501      	movs	r5, #1
  404200:	e6bd      	b.n	403f7e <usbdc_cb_ctl_req+0x22>
  404202:	bf00      	nop
  404204:	00403d65 	.word	0x00403d65
  404208:	00403f3d 	.word	0x00403f3d
  40420c:	00400b51 	.word	0x00400b51
  404210:	20400c30 	.word	0x20400c30
  404214:	00404329 	.word	0x00404329
  404218:	004043a9 	.word	0x004043a9
  40421c:	00404411 	.word	0x00404411

00404220 <usbdc_register_handler>:

/**
 * \brief Register the handler
 */
void usbdc_register_handler(enum usbdc_handler_type type, const struct usbdc_handler *h)
{
  404220:	b508      	push	{r3, lr}
	switch (type) {
  404222:	2801      	cmp	r0, #1
  404224:	d007      	beq.n	404236 <usbdc_register_handler+0x16>
  404226:	b110      	cbz	r0, 40422e <usbdc_register_handler+0xe>
  404228:	2802      	cmp	r0, #2
  40422a:	d008      	beq.n	40423e <usbdc_register_handler+0x1e>
  40422c:	bd08      	pop	{r3, pc}
	case USBDC_HDL_SOF:
		list_insert_at_end(&usbdc.handlers.sof_list, (void *)h);
  40422e:	4806      	ldr	r0, [pc, #24]	; (404248 <usbdc_register_handler+0x28>)
  404230:	4b06      	ldr	r3, [pc, #24]	; (40424c <usbdc_register_handler+0x2c>)
  404232:	4798      	blx	r3
		break;
  404234:	bd08      	pop	{r3, pc}
	case USBDC_HDL_REQ:
		list_insert_at_end(&usbdc.handlers.req_list, (void *)h);
  404236:	4806      	ldr	r0, [pc, #24]	; (404250 <usbdc_register_handler+0x30>)
  404238:	4b04      	ldr	r3, [pc, #16]	; (40424c <usbdc_register_handler+0x2c>)
  40423a:	4798      	blx	r3
		break;
  40423c:	bd08      	pop	{r3, pc}
	case USBDC_HDL_CHANGE:
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
  40423e:	4805      	ldr	r0, [pc, #20]	; (404254 <usbdc_register_handler+0x34>)
  404240:	4b02      	ldr	r3, [pc, #8]	; (40424c <usbdc_register_handler+0x2c>)
  404242:	4798      	blx	r3
  404244:	bd08      	pop	{r3, pc}
  404246:	bf00      	nop
  404248:	20400c34 	.word	0x20400c34
  40424c:	00400c29 	.word	0x00400c29
  404250:	20400c38 	.word	0x20400c38
  404254:	20400c3c 	.word	0x20400c3c

00404258 <usbdc_init>:

/**
 * \brief Initialize the USB device core driver
 */
int32_t usbdc_init(uint8_t *ctrl_buf)
{
  404258:	b538      	push	{r3, r4, r5, lr}
	ASSERT(ctrl_buf);
  40425a:	4605      	mov	r5, r0
  40425c:	f240 2299 	movw	r2, #665	; 0x299
  404260:	490c      	ldr	r1, [pc, #48]	; (404294 <usbdc_init+0x3c>)
  404262:	3000      	adds	r0, #0
  404264:	bf18      	it	ne
  404266:	2001      	movne	r0, #1
  404268:	4b0b      	ldr	r3, [pc, #44]	; (404298 <usbdc_init+0x40>)
  40426a:	4798      	blx	r3

	int32_t rc;

	rc = usb_d_init();
  40426c:	4b0b      	ldr	r3, [pc, #44]	; (40429c <usbdc_init+0x44>)
  40426e:	4798      	blx	r3
	if (rc < 0) {
  404270:	2800      	cmp	r0, #0
  404272:	db0e      	blt.n	404292 <usbdc_init+0x3a>
		return rc;
	}

	memset(&usbdc, 0, sizeof(usbdc));
  404274:	4c0a      	ldr	r4, [pc, #40]	; (4042a0 <usbdc_init+0x48>)
  404276:	2220      	movs	r2, #32
  404278:	2100      	movs	r1, #0
  40427a:	4620      	mov	r0, r4
  40427c:	4b09      	ldr	r3, [pc, #36]	; (4042a4 <usbdc_init+0x4c>)
  40427e:	4798      	blx	r3
	usbdc.ctrl_buf = ctrl_buf;
  404280:	6165      	str	r5, [r4, #20]
	usb_d_register_callback(USB_D_CB_SOF, (FUNC_PTR)usbd_sof_cb);
  404282:	4909      	ldr	r1, [pc, #36]	; (4042a8 <usbdc_init+0x50>)
  404284:	2000      	movs	r0, #0
  404286:	4c09      	ldr	r4, [pc, #36]	; (4042ac <usbdc_init+0x54>)
  404288:	47a0      	blx	r4
	usb_d_register_callback(USB_D_CB_EVENT, (FUNC_PTR)usbd_event_cb);
  40428a:	4909      	ldr	r1, [pc, #36]	; (4042b0 <usbdc_init+0x58>)
  40428c:	2001      	movs	r0, #1
  40428e:	47a0      	blx	r4

	return 0;
  404290:	2000      	movs	r0, #0
}
  404292:	bd38      	pop	{r3, r4, r5, pc}
  404294:	004045d8 	.word	0x004045d8
  404298:	00400c01 	.word	0x00400c01
  40429c:	004008b9 	.word	0x004008b9
  4042a0:	20400c30 	.word	0x20400c30
  4042a4:	004044f3 	.word	0x004044f3
  4042a8:	00403da1 	.word	0x00403da1
  4042ac:	00400921 	.word	0x00400921
  4042b0:	00403f1d 	.word	0x00403f1d

004042b4 <usbdc_register_function>:
 * \brief Register/unregister function support of a USB device function
 *
 * Must be invoked when USB device is stopped.
 */
void usbdc_register_function(struct usbdf_driver *func)
{
  4042b4:	b508      	push	{r3, lr}
	list_insert_at_end(&usbdc.func_list, func);
  4042b6:	4601      	mov	r1, r0
  4042b8:	4801      	ldr	r0, [pc, #4]	; (4042c0 <usbdc_register_function+0xc>)
  4042ba:	4b02      	ldr	r3, [pc, #8]	; (4042c4 <usbdc_register_function+0x10>)
  4042bc:	4798      	blx	r3
  4042be:	bd08      	pop	{r3, pc}
  4042c0:	20400c40 	.word	0x20400c40
  4042c4:	00400c29 	.word	0x00400c29

004042c8 <usbdc_start>:

/**
 * \brief Start the USB device driver with specific descriptors set
 */
int32_t usbdc_start(struct usbd_descriptors *desces)
{
  4042c8:	b508      	push	{r3, lr}
	if (usbdc.state >= USBD_S_POWER) {
  4042ca:	4b0a      	ldr	r3, [pc, #40]	; (4042f4 <usbdc_start+0x2c>)
  4042cc:	7e9b      	ldrb	r3, [r3, #26]
  4042ce:	b95b      	cbnz	r3, 4042e8 <usbdc_start+0x20>
		return ERR_BUSY;
	}

	if (desces) {
  4042d0:	b168      	cbz	r0, 4042ee <usbdc_start+0x26>
		usbdc.desces.ls_fs = desces;
  4042d2:	4b08      	ldr	r3, [pc, #32]	; (4042f4 <usbdc_start+0x2c>)
  4042d4:	6018      	str	r0, [r3, #0]
	} else {
		return ERR_BAD_DATA;
	}

	usbdc.ctrl_size = desces->sod[7];
  4042d6:	6802      	ldr	r2, [r0, #0]
  4042d8:	79d2      	ldrb	r2, [r2, #7]
  4042da:	771a      	strb	r2, [r3, #28]
	usbdc.state     = USBD_S_POWER;
  4042dc:	2201      	movs	r2, #1
  4042de:	769a      	strb	r2, [r3, #26]
	usb_d_enable();
  4042e0:	4b05      	ldr	r3, [pc, #20]	; (4042f8 <usbdc_start+0x30>)
  4042e2:	4798      	blx	r3
	return ERR_NONE;
  4042e4:	2000      	movs	r0, #0
  4042e6:	bd08      	pop	{r3, pc}
		return ERR_BUSY;
  4042e8:	f06f 0003 	mvn.w	r0, #3
  4042ec:	bd08      	pop	{r3, pc}
		return ERR_BAD_DATA;
  4042ee:	f06f 0008 	mvn.w	r0, #8
}
  4042f2:	bd08      	pop	{r3, pc}
  4042f4:	20400c30 	.word	0x20400c30
  4042f8:	0040092d 	.word	0x0040092d

004042fc <usbdc_attach>:

/**
 * \brief Attach the USB device to host
 */
void usbdc_attach(void)
{
  4042fc:	b508      	push	{r3, lr}
	usb_d_attach();
  4042fe:	4b01      	ldr	r3, [pc, #4]	; (404304 <usbdc_attach+0x8>)
  404300:	4798      	blx	r3
  404302:	bd08      	pop	{r3, pc}
  404304:	00400939 	.word	0x00400939

00404308 <usbdc_get_ctrl_buffer>:
 * \brief Return USB Device endpoint0 buffer
 */
uint8_t *usbdc_get_ctrl_buffer(void)
{
	return usbdc.ctrl_buf;
}
  404308:	4b01      	ldr	r3, [pc, #4]	; (404310 <usbdc_get_ctrl_buffer+0x8>)
  40430a:	6958      	ldr	r0, [r3, #20]
  40430c:	4770      	bx	lr
  40430e:	bf00      	nop
  404310:	20400c30 	.word	0x20400c30

00404314 <usbdc_get_state>:
/**
 * \brief Return current USB state
 */
uint8_t usbdc_get_state(void)
{
	if (usbdc.state & USBD_S_SUSPEND) {
  404314:	4b03      	ldr	r3, [pc, #12]	; (404324 <usbdc_get_state+0x10>)
  404316:	7e98      	ldrb	r0, [r3, #26]
  404318:	f000 0310 	and.w	r3, r0, #16
		return USBD_S_SUSPEND;
  40431c:	2b00      	cmp	r3, #0
	}
	return usbdc.state;
}
  40431e:	bf18      	it	ne
  404320:	2010      	movne	r0, #16
  404322:	4770      	bx	lr
  404324:	20400c30 	.word	0x20400c30

00404328 <usb_find_desc>:

uint8_t *usb_find_desc(uint8_t *desc, uint8_t *eof, uint8_t type)
{
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
  404328:	4288      	cmp	r0, r1
  40432a:	d214      	bcs.n	404356 <usb_find_desc+0x2e>
	return desc[0];
  40432c:	7803      	ldrb	r3, [r0, #0]
		_desc_len_check();
  40432e:	2b01      	cmp	r3, #1
  404330:	d913      	bls.n	40435a <usb_find_desc+0x32>
{
  404332:	b410      	push	{r4}
		if (type == usb_desc_type(desc)) {
  404334:	7844      	ldrb	r4, [r0, #1]
  404336:	4294      	cmp	r4, r2
  404338:	d00a      	beq.n	404350 <usb_find_desc+0x28>
	return (desc + usb_desc_len(desc));
  40433a:	4418      	add	r0, r3
	while (desc < eof) {
  40433c:	4281      	cmp	r1, r0
  40433e:	d906      	bls.n	40434e <usb_find_desc+0x26>
	return desc[0];
  404340:	7803      	ldrb	r3, [r0, #0]
		_desc_len_check();
  404342:	2b01      	cmp	r3, #1
  404344:	d90b      	bls.n	40435e <usb_find_desc+0x36>
	return desc[1];
  404346:	7844      	ldrb	r4, [r0, #1]
		if (type == usb_desc_type(desc)) {
  404348:	4294      	cmp	r4, r2
  40434a:	d1f6      	bne.n	40433a <usb_find_desc+0x12>
  40434c:	e000      	b.n	404350 <usb_find_desc+0x28>
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
  40434e:	2000      	movs	r0, #0
}
  404350:	f85d 4b04 	ldr.w	r4, [sp], #4
  404354:	4770      	bx	lr
	return NULL;
  404356:	2000      	movs	r0, #0
  404358:	4770      	bx	lr
		_desc_len_check();
  40435a:	2000      	movs	r0, #0
  40435c:	4770      	bx	lr
  40435e:	2000      	movs	r0, #0
  404360:	e7f6      	b.n	404350 <usb_find_desc+0x28>

00404362 <usb_find_ep_desc>:

uint8_t *usb_find_ep_desc(uint8_t *desc, uint8_t *eof)
{
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
  404362:	4288      	cmp	r0, r1
  404364:	d216      	bcs.n	404394 <usb_find_ep_desc+0x32>
	return desc[0];
  404366:	7803      	ldrb	r3, [r0, #0]
		_desc_len_check();
  404368:	2b01      	cmp	r3, #1
  40436a:	d915      	bls.n	404398 <usb_find_ep_desc+0x36>
	return desc[1];
  40436c:	7842      	ldrb	r2, [r0, #1]
		if (USB_DT_INTERFACE == usb_desc_type(desc)) {
  40436e:	2a04      	cmp	r2, #4
  404370:	d014      	beq.n	40439c <usb_find_ep_desc+0x3a>
			break;
		}
		if (USB_DT_ENDPOINT == usb_desc_type(desc)) {
  404372:	2a05      	cmp	r2, #5
  404374:	d00b      	beq.n	40438e <usb_find_ep_desc+0x2c>
	return (desc + usb_desc_len(desc));
  404376:	4418      	add	r0, r3
	while (desc < eof) {
  404378:	4281      	cmp	r1, r0
  40437a:	d909      	bls.n	404390 <usb_find_ep_desc+0x2e>
	return desc[0];
  40437c:	7803      	ldrb	r3, [r0, #0]
		_desc_len_check();
  40437e:	2b01      	cmp	r3, #1
  404380:	d90e      	bls.n	4043a0 <usb_find_ep_desc+0x3e>
	return desc[1];
  404382:	7842      	ldrb	r2, [r0, #1]
		if (USB_DT_INTERFACE == usb_desc_type(desc)) {
  404384:	2a04      	cmp	r2, #4
  404386:	d00d      	beq.n	4043a4 <usb_find_ep_desc+0x42>
		if (USB_DT_ENDPOINT == usb_desc_type(desc)) {
  404388:	2a05      	cmp	r2, #5
  40438a:	d1f4      	bne.n	404376 <usb_find_ep_desc+0x14>
  40438c:	e00b      	b.n	4043a6 <usb_find_ep_desc+0x44>
  40438e:	4770      	bx	lr
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
  404390:	2000      	movs	r0, #0
  404392:	4770      	bx	lr
  404394:	2000      	movs	r0, #0
  404396:	4770      	bx	lr
		_desc_len_check();
  404398:	2000      	movs	r0, #0
  40439a:	4770      	bx	lr
	return NULL;
  40439c:	2000      	movs	r0, #0
  40439e:	4770      	bx	lr
		_desc_len_check();
  4043a0:	2000      	movs	r0, #0
  4043a2:	4770      	bx	lr
	return NULL;
  4043a4:	2000      	movs	r0, #0
}
  4043a6:	4770      	bx	lr

004043a8 <usb_find_cfg_desc>:

uint8_t *usb_find_cfg_desc(uint8_t *desc, uint8_t *eof, uint8_t cfg_value)
{
  4043a8:	b538      	push	{r3, r4, r5, lr}
  4043aa:	460c      	mov	r4, r1
  4043ac:	4615      	mov	r5, r2
	_param_error_check(desc && eof && (desc < eof));

	desc = usb_find_desc(desc, eof, USB_DT_CONFIG);
  4043ae:	2202      	movs	r2, #2
  4043b0:	4b16      	ldr	r3, [pc, #88]	; (40440c <usb_find_cfg_desc+0x64>)
  4043b2:	4798      	blx	r3
	if (!desc) {
  4043b4:	4603      	mov	r3, r0
  4043b6:	b1e8      	cbz	r0, 4043f4 <usb_find_cfg_desc+0x4c>
		return NULL;
	}
	while (desc < eof) {
  4043b8:	4284      	cmp	r4, r0
  4043ba:	d91d      	bls.n	4043f8 <usb_find_cfg_desc+0x50>
		_desc_len_check();
  4043bc:	7802      	ldrb	r2, [r0, #0]
  4043be:	2a01      	cmp	r2, #1
  4043c0:	d91c      	bls.n	4043fc <usb_find_cfg_desc+0x54>
		if (desc[1] != USB_DT_CONFIG) {
  4043c2:	7842      	ldrb	r2, [r0, #1]
  4043c4:	2a02      	cmp	r2, #2
  4043c6:	d11b      	bne.n	404400 <usb_find_cfg_desc+0x58>
			break;
		}
		if (desc[5] == cfg_value) {
  4043c8:	7942      	ldrb	r2, [r0, #5]
  4043ca:	42aa      	cmp	r2, r5
  4043cc:	d012      	beq.n	4043f4 <usb_find_cfg_desc+0x4c>
	return (ptr[0] + (ptr[1] << 8));
  4043ce:	78d9      	ldrb	r1, [r3, #3]
  4043d0:	789a      	ldrb	r2, [r3, #2]
  4043d2:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 *  \param[in] cfg_desc Byte pointer to the descriptor start address
 *  \return Byte pointer to descriptor after configuration end
 */
static inline uint8_t *usb_cfg_desc_next(uint8_t *cfg_desc)
{
	return (cfg_desc + usb_cfg_desc_total_len(cfg_desc));
  4043d6:	fa13 f382 	uxtah	r3, r3, r2
	while (desc < eof) {
  4043da:	429c      	cmp	r4, r3
  4043dc:	d909      	bls.n	4043f2 <usb_find_cfg_desc+0x4a>
		_desc_len_check();
  4043de:	781a      	ldrb	r2, [r3, #0]
  4043e0:	2a01      	cmp	r2, #1
  4043e2:	d90f      	bls.n	404404 <usb_find_cfg_desc+0x5c>
		if (desc[1] != USB_DT_CONFIG) {
  4043e4:	785a      	ldrb	r2, [r3, #1]
  4043e6:	2a02      	cmp	r2, #2
  4043e8:	d10e      	bne.n	404408 <usb_find_cfg_desc+0x60>
		if (desc[5] == cfg_value) {
  4043ea:	795a      	ldrb	r2, [r3, #5]
  4043ec:	42aa      	cmp	r2, r5
  4043ee:	d1ee      	bne.n	4043ce <usb_find_cfg_desc+0x26>
  4043f0:	e000      	b.n	4043f4 <usb_find_cfg_desc+0x4c>
			return desc;
		}
		desc = usb_cfg_desc_next(desc);
	}
	return NULL;
  4043f2:	2300      	movs	r3, #0
}
  4043f4:	4618      	mov	r0, r3
  4043f6:	bd38      	pop	{r3, r4, r5, pc}
	return NULL;
  4043f8:	2300      	movs	r3, #0
  4043fa:	e7fb      	b.n	4043f4 <usb_find_cfg_desc+0x4c>
		_desc_len_check();
  4043fc:	2300      	movs	r3, #0
  4043fe:	e7f9      	b.n	4043f4 <usb_find_cfg_desc+0x4c>
	return NULL;
  404400:	2300      	movs	r3, #0
  404402:	e7f7      	b.n	4043f4 <usb_find_cfg_desc+0x4c>
		_desc_len_check();
  404404:	2300      	movs	r3, #0
  404406:	e7f5      	b.n	4043f4 <usb_find_cfg_desc+0x4c>
	return NULL;
  404408:	2300      	movs	r3, #0
  40440a:	e7f3      	b.n	4043f4 <usb_find_cfg_desc+0x4c>
  40440c:	00404329 	.word	0x00404329

00404410 <usb_find_str_desc>:
{
	uint8_t i;

	_param_error_check(desc && eof && (desc < eof));

	for (i = 0; desc < eof;) {
  404410:	4288      	cmp	r0, r1
  404412:	d217      	bcs.n	404444 <usb_find_str_desc+0x34>
{
  404414:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  404418:	460d      	mov	r5, r1
  40441a:	4616      	mov	r6, r2
	for (i = 0; desc < eof;) {
  40441c:	2400      	movs	r4, #0
		desc = usb_find_desc(desc, eof, USB_DT_STRING);
  40441e:	f04f 0803 	mov.w	r8, #3
  404422:	4f0c      	ldr	r7, [pc, #48]	; (404454 <usb_find_str_desc+0x44>)
  404424:	4642      	mov	r2, r8
  404426:	4629      	mov	r1, r5
  404428:	47b8      	blx	r7
		if (desc) {
  40442a:	4603      	mov	r3, r0
  40442c:	b170      	cbz	r0, 40444c <usb_find_str_desc+0x3c>
	return desc[0];
  40442e:	7800      	ldrb	r0, [r0, #0]
			_desc_len_check();
  404430:	2801      	cmp	r0, #1
  404432:	d90a      	bls.n	40444a <usb_find_str_desc+0x3a>
			if (i == str_index) {
  404434:	42a6      	cmp	r6, r4
  404436:	d009      	beq.n	40444c <usb_find_str_desc+0x3c>
	return (desc + usb_desc_len(desc));
  404438:	4418      	add	r0, r3
  40443a:	3401      	adds	r4, #1
	for (i = 0; desc < eof;) {
  40443c:	4285      	cmp	r5, r0
  40443e:	d8f1      	bhi.n	404424 <usb_find_str_desc+0x14>
			desc = usb_desc_next(desc);
		} else {
			return NULL;
		}
	}
	return NULL;
  404440:	2300      	movs	r3, #0
  404442:	e003      	b.n	40444c <usb_find_str_desc+0x3c>
  404444:	2300      	movs	r3, #0
}
  404446:	4618      	mov	r0, r3
  404448:	4770      	bx	lr
			_desc_len_check();
  40444a:	2300      	movs	r3, #0
}
  40444c:	4618      	mov	r0, r3
  40444e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  404452:	bf00      	nop
  404454:	00404329 	.word	0x00404329

00404458 <cdc_device_acm_init>:

/**
 * \brief CDC ACM Init
 */
void cdc_device_acm_init(void)
{
  404458:	b508      	push	{r3, lr}
	/* usb stack init */
	usbdc_init(ctrl_buffer);
  40445a:	4805      	ldr	r0, [pc, #20]	; (404470 <cdc_device_acm_init+0x18>)
  40445c:	4b05      	ldr	r3, [pc, #20]	; (404474 <cdc_device_acm_init+0x1c>)
  40445e:	4798      	blx	r3

	/* usbdc_register_funcion inside */
	cdcdf_acm_init();
  404460:	4b05      	ldr	r3, [pc, #20]	; (404478 <cdc_device_acm_init+0x20>)
  404462:	4798      	blx	r3

	usbdc_start(&single_desc);
  404464:	4805      	ldr	r0, [pc, #20]	; (40447c <cdc_device_acm_init+0x24>)
  404466:	4b06      	ldr	r3, [pc, #24]	; (404480 <cdc_device_acm_init+0x28>)
  404468:	4798      	blx	r3
	usbdc_attach();
  40446a:	4b06      	ldr	r3, [pc, #24]	; (404484 <cdc_device_acm_init+0x2c>)
  40446c:	4798      	blx	r3
  40446e:	bd08      	pop	{r3, pc}
  404470:	20400c90 	.word	0x20400c90
  404474:	00404259 	.word	0x00404259
  404478:	00403cd5 	.word	0x00403cd5
  40447c:	2040000c 	.word	0x2040000c
  404480:	004042c9 	.word	0x004042c9
  404484:	004042fd 	.word	0x004042fd

00404488 <usb_init>:
	while (1) {
	}
}

void usb_init(void)
{
  404488:	b508      	push	{r3, lr}

	cdc_device_acm_init();
  40448a:	4b01      	ldr	r3, [pc, #4]	; (404490 <usb_init+0x8>)
  40448c:	4798      	blx	r3
  40448e:	bd08      	pop	{r3, pc}
  404490:	00404459 	.word	0x00404459

00404494 <__libc_init_array>:
  404494:	b570      	push	{r4, r5, r6, lr}
  404496:	4e0d      	ldr	r6, [pc, #52]	; (4044cc <__libc_init_array+0x38>)
  404498:	4c0d      	ldr	r4, [pc, #52]	; (4044d0 <__libc_init_array+0x3c>)
  40449a:	1ba4      	subs	r4, r4, r6
  40449c:	10a4      	asrs	r4, r4, #2
  40449e:	2500      	movs	r5, #0
  4044a0:	42a5      	cmp	r5, r4
  4044a2:	d109      	bne.n	4044b8 <__libc_init_array+0x24>
  4044a4:	4e0b      	ldr	r6, [pc, #44]	; (4044d4 <__libc_init_array+0x40>)
  4044a6:	4c0c      	ldr	r4, [pc, #48]	; (4044d8 <__libc_init_array+0x44>)
  4044a8:	f000 f8a2 	bl	4045f0 <_init>
  4044ac:	1ba4      	subs	r4, r4, r6
  4044ae:	10a4      	asrs	r4, r4, #2
  4044b0:	2500      	movs	r5, #0
  4044b2:	42a5      	cmp	r5, r4
  4044b4:	d105      	bne.n	4044c2 <__libc_init_array+0x2e>
  4044b6:	bd70      	pop	{r4, r5, r6, pc}
  4044b8:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  4044bc:	4798      	blx	r3
  4044be:	3501      	adds	r5, #1
  4044c0:	e7ee      	b.n	4044a0 <__libc_init_array+0xc>
  4044c2:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  4044c6:	4798      	blx	r3
  4044c8:	3501      	adds	r5, #1
  4044ca:	e7f2      	b.n	4044b2 <__libc_init_array+0x1e>
  4044cc:	004045fc 	.word	0x004045fc
  4044d0:	004045fc 	.word	0x004045fc
  4044d4:	004045fc 	.word	0x004045fc
  4044d8:	00404600 	.word	0x00404600

004044dc <memcpy>:
  4044dc:	b510      	push	{r4, lr}
  4044de:	1e43      	subs	r3, r0, #1
  4044e0:	440a      	add	r2, r1
  4044e2:	4291      	cmp	r1, r2
  4044e4:	d100      	bne.n	4044e8 <memcpy+0xc>
  4044e6:	bd10      	pop	{r4, pc}
  4044e8:	f811 4b01 	ldrb.w	r4, [r1], #1
  4044ec:	f803 4f01 	strb.w	r4, [r3, #1]!
  4044f0:	e7f7      	b.n	4044e2 <memcpy+0x6>

004044f2 <memset>:
  4044f2:	4402      	add	r2, r0
  4044f4:	4603      	mov	r3, r0
  4044f6:	4293      	cmp	r3, r2
  4044f8:	d100      	bne.n	4044fc <memset+0xa>
  4044fa:	4770      	bx	lr
  4044fc:	f803 1b01 	strb.w	r1, [r3], #1
  404500:	e7f9      	b.n	4044f6 <memset+0x4>
  404502:	0000      	movs	r0, r0
  404504:	682f2e2e 	.word	0x682f2e2e
  404508:	732f6c61 	.word	0x732f6c61
  40450c:	682f6372 	.word	0x682f6372
  404510:	735f6c61 	.word	0x735f6c61
  404514:	6d5f6970 	.word	0x6d5f6970
  404518:	2e736f5f 	.word	0x2e736f5f
  40451c:	00000063 	.word	0x00000063
  404520:	682f2e2e 	.word	0x682f2e2e
  404524:	752f6c61 	.word	0x752f6c61
  404528:	736c6974 	.word	0x736c6974
  40452c:	6372732f 	.word	0x6372732f
  404530:	6974752f 	.word	0x6974752f
  404534:	6c5f736c 	.word	0x6c5f736c
  404538:	2e747369 	.word	0x2e747369
  40453c:	00000063 	.word	0x00000063
  404540:	682f2e2e 	.word	0x682f2e2e
  404544:	732f6c70 	.word	0x732f6c70
  404548:	682f6970 	.word	0x682f6970
  40454c:	735f6c70 	.word	0x735f6c70
  404550:	632e6970 	.word	0x632e6970
  404554:	00000000 	.word	0x00000000
  404558:	682f2e2e 	.word	0x682f2e2e
  40455c:	752f6c70 	.word	0x752f6c70
  404560:	73686273 	.word	0x73686273
  404564:	6c70682f 	.word	0x6c70682f
  404568:	6273755f 	.word	0x6273755f
  40456c:	632e7368 	.word	0x632e7368
  404570:	00000000 	.word	0x00000000
  404574:	0064654c 	.word	0x0064654c
  404578:	736e6f43 	.word	0x736e6f43
  40457c:	00656c6f 	.word	0x00656c6f
  404580:	742f2e2e 	.word	0x742f2e2e
  404584:	64726968 	.word	0x64726968
  404588:	74726170 	.word	0x74726170
  40458c:	54522f79 	.word	0x54522f79
  404590:	662f534f 	.word	0x662f534f
  404594:	72656572 	.word	0x72656572
  404598:	2f736f74 	.word	0x2f736f74
  40459c:	65657246 	.word	0x65657246
  4045a0:	534f5452 	.word	0x534f5452
  4045a4:	322e3856 	.word	0x322e3856
  4045a8:	722f332e 	.word	0x722f332e
  4045ac:	5f736f74 	.word	0x5f736f74
  4045b0:	74726f70 	.word	0x74726f70
  4045b4:	0000632e 	.word	0x0000632e
  4045b8:	454c4449 	.word	0x454c4449
  4045bc:	00000000 	.word	0x00000000
  4045c0:	09632509 	.word	0x09632509
  4045c4:	25097525 	.word	0x25097525
  4045c8:	75250975 	.word	0x75250975
  4045cc:	00000a0d 	.word	0x00000a0d
  4045d0:	20726d54 	.word	0x20726d54
  4045d4:	00637653 	.word	0x00637653
  4045d8:	752f2e2e 	.word	0x752f2e2e
  4045dc:	642f6273 	.word	0x642f6273
  4045e0:	63697665 	.word	0x63697665
  4045e4:	73752f65 	.word	0x73752f65
  4045e8:	2e636462 	.word	0x2e636462
  4045ec:	00000063 	.word	0x00000063

004045f0 <_init>:
  4045f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4045f2:	bf00      	nop
  4045f4:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4045f6:	bc08      	pop	{r3}
  4045f8:	469e      	mov	lr, r3
  4045fa:	4770      	bx	lr

004045fc <__init_array_start>:
  4045fc:	00400165 	.word	0x00400165

00404600 <_fini>:
  404600:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  404602:	bf00      	nop
  404604:	bcf8      	pop	{r3, r4, r5, r6, r7}
  404606:	bc08      	pop	{r3}
  404608:	469e      	mov	lr, r3
  40460a:	4770      	bx	lr

0040460c <__fini_array_start>:
  40460c:	00400141 	.word	0x00400141
